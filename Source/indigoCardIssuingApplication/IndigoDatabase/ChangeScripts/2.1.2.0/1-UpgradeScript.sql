/*
Deployment script for indigo_database_2.1.2.0

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "indigo_database_2.1.2.0"
:setvar DefaultFilePrefix "indigo_database_2.1.2.0"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL11.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
/*
The column [dbo].[dist_batch_statuses_flow].[card_issue_method_id] is being dropped, data loss could occur.

The column [dbo].[dist_batch_statuses_flow].[dist_batch_type_id] is being dropped, data loss could occur.

The column [dbo].[dist_batch_statuses_flow].[issuer_id] is being dropped, data loss could occur.
*/

--No need to worry about this table
--IF EXISTS (select top 1 1 from [dbo].[dist_batch_statuses_flow])
--    RAISERROR (N'Rows were detected. The schema update is terminating because data loss might occur.', 16, 127) WITH NOWAIT

GO
PRINT N'Dropping [dbo].[FK_pin_batch_cards_cards]...';


GO
ALTER TABLE [dbo].[pin_batch_cards] DROP CONSTRAINT [FK_pin_batch_cards_cards];


GO
PRINT N'Dropping [dbo].[FK_dist_batch_cards_cards]...';


GO
ALTER TABLE [dbo].[dist_batch_cards] DROP CONSTRAINT [FK_dist_batch_cards_cards];


GO
PRINT N'Dropping [dbo].[FK_branch_card_status_cards]...';


GO
ALTER TABLE [dbo].[branch_card_status] DROP CONSTRAINT [FK_branch_card_status_cards];


GO
PRINT N'Dropping [dbo].[FK_load_batch_cards_cards]...';


GO
ALTER TABLE [dbo].[load_batch_cards] DROP CONSTRAINT [FK_load_batch_cards_cards];


GO
PRINT N'Dropping [dbo].[FK_pin_mailer_reprint_cards]...';


GO
ALTER TABLE [dbo].[pin_mailer_reprint] DROP CONSTRAINT [FK_pin_mailer_reprint_cards];


GO
PRINT N'Dropping [dbo].[FK_cards_issuer_product]...';


GO
ALTER TABLE [dbo].[cards] DROP CONSTRAINT [FK_cards_issuer_product];


GO
PRINT N'Dropping [dbo].[FK__cards__card_issu__67A95F59]...';


GO
ALTER TABLE [dbo].[cards] DROP CONSTRAINT [FK__cards__card_issu__67A95F59];


GO
PRINT N'Dropping [dbo].[FK__cards__card_prio__0539C240]...';


GO
ALTER TABLE [dbo].[cards] DROP CONSTRAINT [FK__cards__card_prio__0539C240];


GO
PRINT N'Dropping [dbo].[FK_cards_cards]...';


GO
ALTER TABLE [dbo].[cards] DROP CONSTRAINT [FK_cards_cards];


GO
PRINT N'Dropping [dbo].[FK_export_batch_cards]...';


GO
ALTER TABLE [dbo].[cards] DROP CONSTRAINT [FK_export_batch_cards];


GO
PRINT N'Dropping [dbo].[FK_origin_branch_id]...';


GO
ALTER TABLE [dbo].[cards] DROP CONSTRAINT [FK_origin_branch_id];


GO
PRINT N'Dropping [dbo].[FK_customer_account_cards]...';


GO
ALTER TABLE [dbo].[customer_account] DROP CONSTRAINT [FK_customer_account_cards];


GO
PRINT N'Dropping [dbo].[FK__customer___custo__46486B8E]...';


GO
ALTER TABLE [dbo].[customer_account] DROP CONSTRAINT [FK__customer___custo__46486B8E];


GO
PRINT N'Dropping [dbo].[usp_get_dist_batches]...';


GO
DROP PROCEDURE [dbo].[usp_get_dist_batches];


GO
PRINT N'Creating [dbo].[fee_charge_array]...';


GO
CREATE TYPE [dbo].[fee_charge_array] AS TABLE (
    [currency_id] INT             NULL,
    [fee_charge]  DECIMAL (10, 4) NULL,
    [vat]         DECIMAL (7, 4)  NULL);


GO
PRINT N'Creating [dbo].[notification_array]...';


GO
CREATE TYPE [dbo].[notification_array] AS TABLE (
    [message_id]   UNIQUEIDENTIFIER NULL,
    [message_text] VARCHAR (MAX)    NULL);


GO
PRINT N'Creating [dbo].[notifications_lang_messages]...';


GO
CREATE TYPE [dbo].[notifications_lang_messages] AS TABLE (
    [language_id]       INT           NOT NULL,
    [channel_id]        INT           NULL,
    [notification_text] VARCHAR (MAX) NOT NULL,
    [subject_text]      VARCHAR (MAX) NOT NULL,
    PRIMARY KEY CLUSTERED ([language_id] ASC));


GO
PRINT N'Altering [dbo].[audit_control]...';


GO
ALTER TABLE [dbo].[audit_control] ALTER COLUMN [data_after] VARCHAR (MAX) NULL;

ALTER TABLE [dbo].[audit_control] ALTER COLUMN [data_before] VARCHAR (MAX) NULL;


GO
PRINT N'Altering [dbo].[branch]...';


GO
ALTER TABLE [dbo].[branch]
    ADD [emp_branch_code] NVARCHAR (10) NULL;


GO
PRINT N'Altering [dbo].[branch_card_status]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

ALTER TABLE [dbo].[branch_card_status]
    ADD [branch_id] INT NOT NULL, 
        CONSTRAINT [SD_branch_card_status_7e73866c88514a7596e5efce4018aa18] DEFAULT 0 FOR [branch_id];

ALTER TABLE [dbo].[branch_card_status] DROP CONSTRAINT [SD_branch_card_status_7e73866c88514a7596e5efce4018aa18];

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [dbo].[branch_card_status].[INDEX_CARD_OPERATOR]...';


GO
CREATE NONCLUSTERED INDEX [INDEX_CARD_OPERATOR]
    ON [dbo].[branch_card_status]([branch_card_statuses_id] ASC, [status_date] ASC)
    INCLUDE([card_id], [operator_user_id]);


GO
PRINT N'Creating [dbo].[branch_card_status].[INDEX_CARD_STATUS_DATE]...';


GO
CREATE NONCLUSTERED INDEX [INDEX_CARD_STATUS_DATE]
    ON [dbo].[branch_card_status]([card_id] ASC)
    INCLUDE([status_date]);


GO
PRINT N'Starting rebuilding table [dbo].[cards]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_cards] (
    [card_id]                 BIGINT          IDENTITY (1, 1) NOT NULL,
    [product_id]              INT             NOT NULL,
    [branch_id]               INT             NOT NULL,
    [card_number]             VARBINARY (MAX) NOT NULL,
    [card_sequence]           INT             NOT NULL,
    [card_index]              VARBINARY (20)  NOT NULL,
    [card_issue_method_id]    INT             NOT NULL,
    [card_priority_id]        INT             NOT NULL,
    [card_request_reference]  VARCHAR (100)   NULL,
    [card_production_date]    VARBINARY (MAX) NULL,
    [card_expiry_date]        VARBINARY (MAX) NULL,
    [card_activation_date]    VARBINARY (MAX) NULL,
    [pvv]                     VARBINARY (MAX) NULL,
    [fee_charged]             DECIMAL (10, 4) NULL,
    [vat]                     DECIMAL (7, 4)  NULL,
    [vat_charged]             AS              (isnull([fee_charged], (0)) * (isnull([vat], (0)) * (0.01))),
    [total_charged]           AS              (isnull([fee_charged], (0)) * ((1) + isnull([vat], (0)) * (0.01))),
    [fee_waiver_YN]           BIT             NULL,
    [fee_editable_YN]         BIT             NULL,
    [fee_overridden_YN]       BIT             NULL,
    [fee_reference_number]    VARCHAR (100)   NULL,
    [fee_reversal_ref_number] VARCHAR (100)   NULL,
    [origin_branch_id]        INT             NOT NULL,
    [export_batch_id]         BIGINT          NULL,
    [ordering_branch_id]      INT             NOT NULL,
    [delivery_branch_id]      INT             NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_cards1] PRIMARY KEY CLUSTERED ([card_id] ASC),
    CONSTRAINT [tmp_ms_xx_constraint_uq_card_request_reference1] UNIQUE NONCLUSTERED ([card_request_reference] ASC)
);

ALTER TABLE [dbo].[tmp_ms_xx_cards]
    ADD CONSTRAINT [SD_cards_7939e3e2922e4193b09696251cd1ab64] DEFAULT 0 FOR [ordering_branch_id],
        CONSTRAINT [SD_cards_96b411585cfe40e7a8a22d7f4024d5ee] DEFAULT 0 FOR [delivery_branch_id];

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[cards])
    BEGIN
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_cards] ON;
        INSERT INTO [dbo].[tmp_ms_xx_cards] ([card_id], [product_id], [branch_id], [card_number], [card_sequence], [card_index], [card_issue_method_id], [card_priority_id], [card_request_reference], [card_production_date], [card_expiry_date], [card_activation_date], [pvv], [fee_charged], [fee_waiver_YN], [fee_editable_YN], [fee_overridden_YN], [fee_reference_number], [fee_reversal_ref_number], [origin_branch_id], [export_batch_id])
        SELECT   [card_id],
                 [product_id],
                 [branch_id],
                 [card_number],
                 [card_sequence],
                 [card_index],
                 [card_issue_method_id],
                 [card_priority_id],
                 [card_request_reference],
                 [card_production_date],
                 [card_expiry_date],
                 [card_activation_date],
                 [pvv],
                 [fee_charged],
                 [fee_waiver_YN],
                 [fee_editable_YN],
                 [fee_overridden_YN],
                 [fee_reference_number],
                 [fee_reversal_ref_number],
                 [origin_branch_id],
                 [export_batch_id]
        FROM     [dbo].[cards]
        ORDER BY [card_id] ASC;
        SET IDENTITY_INSERT [dbo].[tmp_ms_xx_cards] OFF;
    END

ALTER TABLE [dbo].[tmp_ms_xx_cards] DROP CONSTRAINT [SD_cards_7939e3e2922e4193b09696251cd1ab64], CONSTRAINT [SD_cards_96b411585cfe40e7a8a22d7f4024d5ee];

DROP TABLE [dbo].[cards];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_cards]', N'cards';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_cards1]', N'PK_cards', N'OBJECT';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_uq_card_request_reference1]', N'uq_card_request_reference', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Creating [dbo].[cards].[_dta_index_cards_5_1842105603__K3_K17_K6_K1_2_4_7_8_9]...';


GO
CREATE NONCLUSTERED INDEX [_dta_index_cards_5_1842105603__K3_K17_K6_K1_2_4_7_8_9]
    ON [dbo].[cards]([branch_id] ASC, [card_index] ASC, [card_id] ASC)
    INCLUDE([product_id], [card_number], [card_issue_method_id], [card_priority_id], [card_request_reference]);


GO
PRINT N'Creating [dbo].[cards].[_dta_index_cards_5_1842105603__K1]...';


GO
CREATE NONCLUSTERED INDEX [_dta_index_cards_5_1842105603__K1]
    ON [dbo].[cards]([card_id] ASC);


GO
PRINT N'Altering [dbo].[dist_batch]...';


GO
ALTER TABLE [dbo].[dist_batch] ALTER COLUMN [dist_batch_reference] VARCHAR (50) NOT NULL;


GO
PRINT N'Starting rebuilding table [dbo].[dist_batch_statuses_flow]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

CREATE TABLE [dbo].[tmp_ms_xx_dist_batch_statuses_flow] (
    [dist_batch_statuses_id]         INT      NOT NULL,
    [user_role_id]                   INT      NOT NULL,
    [flow_dist_batch_statuses_id]    INT      NOT NULL,
    [flow_dist_batch_type_id]        INT      NOT NULL,
    [main_menu_id]                   SMALLINT NULL,
    [sub_menu_id]                    SMALLINT NULL,
    [sub_menu_order]                 SMALLINT NULL,
    [reject_dist_batch_statuses_id]  INT      NULL,
    [flow_dist_card_statuses_id]     INT      NULL,
    [reject_dist_card_statuses_id]   INT      NULL,
    [branch_card_statuses_id]        INT      NULL,
    [reject_branch_card_statuses_id] INT      NULL,
    [dist_batch_status_flow_id]      INT      NOT NULL,
    CONSTRAINT [tmp_ms_xx_constraint_PK_DistStatusesFlow1] PRIMARY KEY CLUSTERED ([dist_batch_status_flow_id] ASC, [dist_batch_statuses_id] ASC, [flow_dist_batch_statuses_id] ASC)
);

ALTER TABLE [dbo].[tmp_ms_xx_dist_batch_statuses_flow]
    ADD CONSTRAINT [SD_dist_batch_statuses_flow_29970a67d1ad48f68b54192cd549a8d2] DEFAULT 0 FOR [dist_batch_status_flow_id];

IF EXISTS (SELECT TOP 1 1 
           FROM   [dbo].[dist_batch_statuses_flow])
    BEGIN
        INSERT INTO [dbo].[tmp_ms_xx_dist_batch_statuses_flow] ([dist_batch_statuses_id], [flow_dist_batch_statuses_id], [user_role_id], [flow_dist_batch_type_id], [main_menu_id], [sub_menu_id], [sub_menu_order], [reject_dist_batch_statuses_id], [flow_dist_card_statuses_id], [reject_dist_card_statuses_id], [branch_card_statuses_id], [reject_branch_card_statuses_id])
        SELECT   [dist_batch_statuses_id],
                 [flow_dist_batch_statuses_id],
                 [user_role_id],
                 [flow_dist_batch_type_id],
                 [main_menu_id],
                 [sub_menu_id],
                 [sub_menu_order],
                 [reject_dist_batch_statuses_id],
                 [flow_dist_card_statuses_id],
                 [reject_dist_card_statuses_id],
                 [branch_card_statuses_id],
                 [reject_branch_card_statuses_id]
        FROM     [dbo].[dist_batch_statuses_flow]
        ORDER BY [dist_batch_statuses_id] ASC, [flow_dist_batch_statuses_id] ASC;
    END

ALTER TABLE [dbo].[tmp_ms_xx_dist_batch_statuses_flow] DROP CONSTRAINT [SD_dist_batch_statuses_flow_29970a67d1ad48f68b54192cd549a8d2];

DROP TABLE [dbo].[dist_batch_statuses_flow];

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_dist_batch_statuses_flow]', N'dist_batch_statuses_flow';

EXECUTE sp_rename N'[dbo].[tmp_ms_xx_constraint_PK_DistStatusesFlow1]', N'PK_DistStatusesFlow', N'OBJECT';

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[issuer_product]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

ALTER TABLE [dbo].[issuer_product]
    ADD [production_dist_batch_status_flow]   INT NOT NULL,
        [distribution_dist_batch_status_flow] INT NOT NULL,
        [charge_fee_to_issuing_branch_YN]     BIT NOT NULL,
        [print_issue_card_YN]                 BIT DEFAULT ((1)) NOT NULL,
        [allow_manual_uploaded_YN]            BIT CONSTRAINT [DF_issuer_product_allow_manual_uploaded_YN] DEFAULT ((0)) NOT NULL,
        [allow_reupload_YN]                   BIT CONSTRAINT [DF_issuer_product_allow_reupload_YN] DEFAULT ((0)) NOT NULL, 
        CONSTRAINT [SD_issuer_product_438d2aa6df254366acb5d96c086254e4] DEFAULT 0 FOR [production_dist_batch_status_flow],
        CONSTRAINT [SD_issuer_product_b6114dda0d804947bb6a5ee496605d79] DEFAULT 0 FOR [distribution_dist_batch_status_flow],
        CONSTRAINT [SD_issuer_product_b455608cf69c4c5988aa71e75b002484] DEFAULT 0 FOR [charge_fee_to_issuing_branch_YN];

ALTER TABLE [dbo].[issuer_product] DROP CONSTRAINT [SD_issuer_product_438d2aa6df254366acb5d96c086254e4], CONSTRAINT [SD_issuer_product_b6114dda0d804947bb6a5ee496605d79], CONSTRAINT [SD_issuer_product_b455608cf69c4c5988aa71e75b002484];

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[product_fee_charge]...';


GO
ALTER TABLE [dbo].[product_fee_charge]
    ADD [vat] DECIMAL (7, 4) CONSTRAINT [DF_product_fee_charge_vat] DEFAULT ((0)) NOT NULL;


GO
PRINT N'Altering [dbo].[product_fee_scheme]...';


GO
BEGIN TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SET XACT_ABORT ON;

ALTER TABLE [dbo].[product_fee_scheme]
    ADD [fee_accounting_id] INT NOT NULL, 
        CONSTRAINT [SD_product_fee_scheme_131b1e17f53c4d64bc0bc0994b1d533a] DEFAULT 0 FOR [fee_accounting_id];

ALTER TABLE [dbo].[product_fee_scheme] DROP CONSTRAINT [SD_product_fee_scheme_131b1e17f53c4d64bc0bc0994b1d533a];

COMMIT TRANSACTION;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;


GO
PRINT N'Altering [dbo].[terminals]...';


GO
ALTER TABLE [dbo].[terminals]
    ADD [password]  VARBINARY (MAX) NULL,
        [IsMacUsed] BIT             NULL;


GO
PRINT N'Creating [dbo].[dist_batch_status_flow]...';


GO
CREATE TABLE [dbo].[dist_batch_status_flow] (
    [dist_batch_status_flow_id]   INT           NOT NULL,
    [dist_batch_status_flow_name] VARCHAR (150) NOT NULL,
    [dist_batch_type_id]          INT           NOT NULL,
    [card_issue_method_id]        INT           NOT NULL,
    PRIMARY KEY CLUSTERED ([dist_batch_status_flow_id] ASC)
);


GO
PRINT N'Creating [dbo].[notification_batch_log]...';


GO
CREATE TABLE [dbo].[notification_batch_log] (
    [added_time]             DATETIME        NOT NULL,
    [issuer_id]              INT             NOT NULL,
    [dist_batch_id]          INT             NOT NULL,
    [dist_batch_statuses_id] INT             NOT NULL,
    [user_id]                BIGINT          NOT NULL,
    [channel_id]             INT             NOT NULL,
    [notification_text]      VARBINARY (MAX) NOT NULL
);


GO
PRINT N'Creating [dbo].[notification_batch_messages]...';


GO
CREATE TABLE [dbo].[notification_batch_messages] (
    [issuer_id]              INT           NOT NULL,
    [dist_batch_type_id]     INT           NOT NULL,
    [dist_batch_statuses_id] INT           NOT NULL,
    [language_id]            INT           NOT NULL,
    [channel_id]             INT           NOT NULL,
    [notification_text]      VARCHAR (MAX) NOT NULL,
    [subject_text]           VARCHAR (MAX) NOT NULL,
    CONSTRAINT [PK_notification_messages] PRIMARY KEY NONCLUSTERED ([issuer_id] ASC, [dist_batch_statuses_id] ASC, [language_id] ASC, [channel_id] ASC)
);


GO
PRINT N'Creating [dbo].[notification_batch_outbox]...';


GO
CREATE TABLE [dbo].[notification_batch_outbox] (
    [batch_message_id]       UNIQUEIDENTIFIER NOT NULL,
    [added_time]             DATETIME         NOT NULL,
    [dist_batch_id]          BIGINT           NOT NULL,
    [issuer_id]              INT              NOT NULL,
    [dist_batch_statuses_id] INT              NOT NULL,
    [dist_batch_type_id]     INT              NOT NULL,
    [language_id]            INT              NOT NULL,
    [channel_id]             INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[notification_branch_log]...';


GO
CREATE TABLE [dbo].[notification_branch_log] (
    [added_time]              DATETIME        NOT NULL,
    [card_id]                 BIGINT          NOT NULL,
    [issuer_id]               INT             NOT NULL,
    [branch_card_statuses_id] INT             NOT NULL,
    [channel_id]              INT             NOT NULL,
    [notification_text]       VARBINARY (MAX) NOT NULL
);


GO
PRINT N'Creating [dbo].[notification_branch_messages]...';


GO
CREATE TABLE [dbo].[notification_branch_messages] (
    [issuer_id]               INT           NOT NULL,
    [branch_card_statuses_id] INT           NOT NULL,
    [card_issue_method_id]    INT           NOT NULL,
    [language_id]             INT           NOT NULL,
    [channel_id]              INT           NOT NULL,
    [notification_text]       VARCHAR (MAX) NOT NULL,
    [subject_text]            VARCHAR (MAX) NOT NULL,
    CONSTRAINT [PK_notification_branch_messages] PRIMARY KEY NONCLUSTERED ([issuer_id] ASC, [branch_card_statuses_id] ASC, [card_issue_method_id] ASC, [language_id] ASC, [channel_id] ASC)
);


GO
PRINT N'Creating [dbo].[notification_branch_outbox]...';


GO
CREATE TABLE [dbo].[notification_branch_outbox] (
    [branch_message_id]       UNIQUEIDENTIFIER NOT NULL,
    [added_time]              DATETIME         NOT NULL,
    [card_id]                 BIGINT           NOT NULL,
    [issuer_id]               INT              NOT NULL,
    [branch_card_statuses_id] INT              NOT NULL,
    [card_issue_method_id]    INT              NOT NULL,
    [language_id]             INT              NOT NULL,
    [channel_id]              INT              NOT NULL
);


GO
PRINT N'Creating [dbo].[product_fee_accounting]...';


GO
CREATE TABLE [dbo].[product_fee_accounting] (
    [fee_accounting_id]           INT             IDENTITY (1, 1) NOT NULL,
    [fee_accounting_name]         NVARCHAR (100)  NOT NULL,
    [issuer_id]                   INT             NOT NULL,
    [fee_revenue_account_no]      VARBINARY (MAX) NOT NULL,
    [fee_revenue_account_type_id] INT             NOT NULL,
    [fee_revenue_branch_code]     NVARCHAR (10)   NULL,
    [fee_revenue_narration_en]    NVARCHAR (150)  NOT NULL,
    [fee_revenue_narration_fr]    NVARCHAR (150)  NOT NULL,
    [fee_revenue_narration_pt]    NVARCHAR (150)  NOT NULL,
    [fee_revenue_narration_es]    NVARCHAR (150)  NOT NULL,
    [vat_account_no]              VARBINARY (MAX) NOT NULL,
    [vat_account_type_id]         INT             NOT NULL,
    [vat_account_branch_code]     NVARCHAR (10)   NULL,
    [vat_narration_en]            NVARCHAR (150)  NOT NULL,
    [vat_narration_fr]            NVARCHAR (150)  NOT NULL,
    [vat_narration_pt]            NVARCHAR (150)  NOT NULL,
    [vat_narration_es]            NVARCHAR (150)  NOT NULL,
    CONSTRAINT [PK_product_fee_accounting] PRIMARY KEY CLUSTERED ([fee_accounting_id] ASC)
);


GO
PRINT N'Creating [dbo].[cards].[_dta_stat_1842105603_6_1]...';


GO
CREATE STATISTICS [_dta_stat_1842105603_6_1]
    ON [dbo].[cards]([card_index], [card_id]);


GO
PRINT N'Creating [dbo].[FK_pin_batch_cards_cards]...';


GO
ALTER TABLE [dbo].[pin_batch_cards] WITH NOCHECK
    ADD CONSTRAINT [FK_pin_batch_cards_cards] FOREIGN KEY ([card_id]) REFERENCES [dbo].[cards] ([card_id]);


GO
PRINT N'Creating [dbo].[FK_dist_batch_cards_cards]...';


GO
ALTER TABLE [dbo].[dist_batch_cards] WITH NOCHECK
    ADD CONSTRAINT [FK_dist_batch_cards_cards] FOREIGN KEY ([card_id]) REFERENCES [dbo].[cards] ([card_id]);


GO
PRINT N'Creating [dbo].[FK_branch_card_status_cards]...';


GO
ALTER TABLE [dbo].[branch_card_status] WITH NOCHECK
    ADD CONSTRAINT [FK_branch_card_status_cards] FOREIGN KEY ([card_id]) REFERENCES [dbo].[cards] ([card_id]);


GO
PRINT N'Creating [dbo].[FK_load_batch_cards_cards]...';


GO
ALTER TABLE [dbo].[load_batch_cards] WITH NOCHECK
    ADD CONSTRAINT [FK_load_batch_cards_cards] FOREIGN KEY ([card_id]) REFERENCES [dbo].[cards] ([card_id]);


GO
PRINT N'Creating [dbo].[FK_pin_mailer_reprint_cards]...';


GO
ALTER TABLE [dbo].[pin_mailer_reprint] WITH NOCHECK
    ADD CONSTRAINT [FK_pin_mailer_reprint_cards] FOREIGN KEY ([card_id]) REFERENCES [dbo].[cards] ([card_id]);


GO
PRINT N'Creating [dbo].[FK_cards_issuer_product]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK_cards_issuer_product] FOREIGN KEY ([product_id]) REFERENCES [dbo].[issuer_product] ([product_id]);


GO
PRINT N'Creating [dbo].[FK__cards__card_issu__67A95F59]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK__cards__card_issu__67A95F59] FOREIGN KEY ([card_issue_method_id]) REFERENCES [dbo].[card_issue_method] ([card_issue_method_id]);


GO
PRINT N'Creating [dbo].[FK__cards__card_prio__0539C240]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK__cards__card_prio__0539C240] FOREIGN KEY ([card_priority_id]) REFERENCES [dbo].[card_priority] ([card_priority_id]);


GO
PRINT N'Creating [dbo].[FK_cards_cards]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK_cards_cards] FOREIGN KEY ([branch_id]) REFERENCES [dbo].[branch] ([branch_id]);


GO
PRINT N'Creating [dbo].[FK_export_batch_cards]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK_export_batch_cards] FOREIGN KEY ([export_batch_id]) REFERENCES [dbo].[export_batch] ([export_batch_id]);


GO
PRINT N'Creating [dbo].[FK_origin_branch_id]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK_origin_branch_id] FOREIGN KEY ([origin_branch_id]) REFERENCES [dbo].[branch] ([branch_id]);


GO
PRINT N'Creating [dbo].[FK_customer_account_cards]...';


GO
ALTER TABLE [dbo].[customer_account] WITH NOCHECK
    ADD CONSTRAINT [FK_customer_account_cards] FOREIGN KEY ([card_id]) REFERENCES [dbo].[cards] ([card_id]);


GO
ALTER TABLE [dbo].[customer_account] NOCHECK CONSTRAINT [FK_customer_account_cards];


GO
PRINT N'Creating [dbo].[FK_delivery_branch_id]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK_delivery_branch_id] FOREIGN KEY ([delivery_branch_id]) REFERENCES [dbo].[branch] ([branch_id]);


GO
PRINT N'Creating [dbo].[FK_ordering_branch_id]...';


GO
ALTER TABLE [dbo].[cards] WITH NOCHECK
    ADD CONSTRAINT [FK_ordering_branch_id] FOREIGN KEY ([ordering_branch_id]) REFERENCES [dbo].[branch] ([branch_id]);


GO
PRINT N'Creating [dbo].[FK_dist_batch_status_flow_dist_batch_statuses_flow]...';


GO
ALTER TABLE [dbo].[dist_batch_statuses_flow] WITH NOCHECK
    ADD CONSTRAINT [FK_dist_batch_status_flow_dist_batch_statuses_flow] FOREIGN KEY ([dist_batch_status_flow_id]) REFERENCES [dbo].[dist_batch_status_flow] ([dist_batch_status_flow_id]);


GO
PRINT N'Creating [dbo].[FK_dist_batch_status_flow_dist_batcht_ype]...';


GO
ALTER TABLE [dbo].[dist_batch_status_flow] WITH NOCHECK
    ADD CONSTRAINT [FK_dist_batch_status_flow_dist_batcht_ype] FOREIGN KEY ([dist_batch_type_id]) REFERENCES [dbo].[dist_batch_type] ([dist_batch_type_id]);


GO
PRINT N'Creating [dbo].[FK_dist_batch_status_flow_card_issue_method]...';


GO
ALTER TABLE [dbo].[dist_batch_status_flow] WITH NOCHECK
    ADD CONSTRAINT [FK_dist_batch_status_flow_card_issue_method] FOREIGN KEY ([card_issue_method_id]) REFERENCES [dbo].[card_issue_method] ([card_issue_method_id]);


GO
PRINT N'Creating [dbo].[FK_issuer_id]...';


GO
ALTER TABLE [dbo].[notification_batch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_issuer_id] FOREIGN KEY ([issuer_id]) REFERENCES [dbo].[issuer] ([issuer_id]);


GO
PRINT N'Creating [dbo].[FK_dist_batch_statuses]...';


GO
ALTER TABLE [dbo].[notification_batch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_dist_batch_statuses] FOREIGN KEY ([dist_batch_statuses_id]) REFERENCES [dbo].[dist_batch_statuses] ([dist_batch_statuses_id]);


GO
PRINT N'Creating [dbo].[FK_languages]...';


GO
ALTER TABLE [dbo].[notification_batch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_languages] FOREIGN KEY ([language_id]) REFERENCES [dbo].[languages] ([id]);


GO
PRINT N'Creating [dbo].[FK_notification_batch_messages_dist_batch_type_id]...';


GO
ALTER TABLE [dbo].[notification_batch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_notification_batch_messages_dist_batch_type_id] FOREIGN KEY ([dist_batch_type_id]) REFERENCES [dbo].[dist_batch_type] ([dist_batch_type_id]);


GO
PRINT N'Creating [dbo].[FK_notification_branch_messages_issuer_id]...';


GO
ALTER TABLE [dbo].[notification_branch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_notification_branch_messages_issuer_id] FOREIGN KEY ([issuer_id]) REFERENCES [dbo].[issuer] ([issuer_id]);


GO
PRINT N'Creating [dbo].[FK_notification_branch_messages_branch_card_statuses]...';


GO
ALTER TABLE [dbo].[notification_branch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_notification_branch_messages_branch_card_statuses] FOREIGN KEY ([branch_card_statuses_id]) REFERENCES [dbo].[branch_card_statuses] ([branch_card_statuses_id]);


GO
PRINT N'Creating [dbo].[FK_notification_branch_messages_card_issue_method]...';


GO
ALTER TABLE [dbo].[notification_branch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_notification_branch_messages_card_issue_method] FOREIGN KEY ([card_issue_method_id]) REFERENCES [dbo].[card_issue_method] ([card_issue_method_id]);


GO
PRINT N'Creating [dbo].[FK_notification_branch_messages_languages]...';


GO
ALTER TABLE [dbo].[notification_branch_messages] WITH NOCHECK
    ADD CONSTRAINT [FK_notification_branch_messages_languages] FOREIGN KEY ([language_id]) REFERENCES [dbo].[languages] ([id]);


GO
PRINT N'Creating [dbo].[FK_product_fee_accounting_customer_account_type]...';


GO
ALTER TABLE [dbo].[product_fee_accounting] WITH NOCHECK
    ADD CONSTRAINT [FK_product_fee_accounting_customer_account_type] FOREIGN KEY ([fee_revenue_account_type_id]) REFERENCES [dbo].[customer_account_type] ([account_type_id]);


GO
PRINT N'Creating [dbo].[FK_product_fee_accounting_customer_account_type1]...';


GO
ALTER TABLE [dbo].[product_fee_accounting] WITH NOCHECK
    ADD CONSTRAINT [FK_product_fee_accounting_customer_account_type1] FOREIGN KEY ([vat_account_type_id]) REFERENCES [dbo].[customer_account_type] ([account_type_id]);


GO
PRINT N'Creating [dbo].[FK_product_fee_accounting_issuer]...';


GO
ALTER TABLE [dbo].[product_fee_accounting] WITH NOCHECK
    ADD CONSTRAINT [FK_product_fee_accounting_issuer] FOREIGN KEY ([issuer_id]) REFERENCES [dbo].[issuer] ([issuer_id]);


GO
PRINT N'Creating [dbo].[FK_branch_card_status_branch_id]...';


GO
ALTER TABLE [dbo].[branch_card_status] WITH NOCHECK
    ADD CONSTRAINT [FK_branch_card_status_branch_id] FOREIGN KEY ([branch_id]) REFERENCES [dbo].[branch] ([branch_id]);


GO
PRINT N'Creating unnamed constraint on [dbo].[customer_account]...';


GO
ALTER TABLE [dbo].[customer_account] WITH NOCHECK
    ADD FOREIGN KEY ([customer_title_id]) REFERENCES [dbo].[customer_title] ([customer_title_id]);


GO
PRINT N'Creating [dbo].[FK_dist_batch_status_flow_issuer_product]...';


GO
ALTER TABLE [dbo].[issuer_product] WITH NOCHECK
    ADD CONSTRAINT [FK_dist_batch_status_flow_issuer_product] FOREIGN KEY ([production_dist_batch_status_flow]) REFERENCES [dbo].[dist_batch_status_flow] ([dist_batch_status_flow_id]);


GO
PRINT N'Creating [dbo].[FK_production_dist_batch_status_flow_issuer_product]...';


GO
ALTER TABLE [dbo].[issuer_product] WITH NOCHECK
    ADD CONSTRAINT [FK_production_dist_batch_status_flow_issuer_product] FOREIGN KEY ([distribution_dist_batch_status_flow]) REFERENCES [dbo].[dist_batch_status_flow] ([dist_batch_status_flow_id]);


GO
PRINT N'Creating [dbo].[FK_product_fee_scheme_product_fee_accounting]...';


GO
ALTER TABLE [dbo].[product_fee_scheme] WITH NOCHECK
    ADD CONSTRAINT [FK_product_fee_scheme_product_fee_accounting] FOREIGN KEY ([fee_accounting_id]) REFERENCES [dbo].[product_fee_accounting] ([fee_accounting_id]);


GO
PRINT N'Altering [dbo].[DistBatchInCorrectStatus]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER FUNCTION [dbo].[DistBatchInCorrectStatus] 
(
	-- Add the parameters for the function here
	@dist_batch_statuses_id int,
	@new_dispatch_dist_batch_statuses_id int,
	@dist_batch_id int
)
RETURNS bit
AS
BEGIN
	-- Declare the return variable here
	DECLARE @current_dist_batch_status_id int,
			@flow_from_dist_batch_status_id int,
			@dist_batch_status_flow_id int,
			--@dist_batch_type_id int,
			--@card_issue_method_id int,
			@Result bit

	SET @Result = 0

	--get the current status for the distribution batch
	SELECT @current_dist_batch_status_id = [dist_batch_status_current].dist_batch_statuses_id, 
			@dist_batch_status_flow_id = [product_flow].dist_batch_status_flow_id
			--, @dist_batch_type_id = dist_batch_type_id,
			--, @card_issue_method_id = card_issue_method_id
	FROM [dist_batch_status_current]
		INNER JOIN [dist_batch]
			ON [dist_batch_status_current].dist_batch_id = [dist_batch].dist_batch_id
		INNER JOIN [dist_batch_cards]
			ON [dist_batch].dist_batch_id = [dist_batch_cards].dist_batch_id
		INNER JOIN cards  
			ON [dist_batch_cards].card_id = cards.card_id
		INNER JOIN [issuer_product]
			ON cards.product_id = [issuer_product].product_id
		INNER JOIN [dist_batch_statuses_flow] AS [product_flow]
			ON (([dist_batch].dist_batch_type_id = 0 AND 
					[product_flow].dist_batch_status_flow_id = [issuer_product].production_dist_batch_status_flow)
				OR ([dist_batch].dist_batch_type_id = 1 AND 
					[product_flow].dist_batch_status_flow_id = [issuer_product].distribution_dist_batch_status_flow))
				AND [product_flow].dist_batch_statuses_id = [dist_batch_status_current].dist_batch_statuses_id
	WHERE dist_batch_status_current.dist_batch_id = @dist_batch_id

	--If we arent moving to a new status make sure the batch is currently in the same status
	IF(@dist_batch_statuses_id = @new_dispatch_dist_batch_statuses_id)
	BEGIN
		IF(@new_dispatch_dist_batch_statuses_id = @current_dist_batch_status_id)
			SET @Result = 1
	END
	ELSE IF(@dist_batch_statuses_id = @current_dist_batch_status_id)
	BEGIN
		--Check which status the batch must be in to flow to the new status
		SELECT @flow_from_dist_batch_status_id = dist_batch_statuses_id
		FROM dist_batch_statuses_flow
		WHERE dist_batch_status_flow_id = @dist_batch_status_flow_id
		    AND flow_dist_batch_statuses_id = @new_dispatch_dist_batch_statuses_id
			AND dist_batch_statuses_id = @dist_batch_statuses_id
			--AND dist_batch_type_id = @dist_batch_type_id
			--AND card_issue_method_id = @card_issue_method_id


		IF(@flow_from_dist_batch_status_id = @current_dist_batch_status_id)
			SET @Result = 1
	END

	-- Return the result of the function
	RETURN @Result

END
GO
PRINT N'Altering [dbo].[DistBatchInCorrectStatusReject]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER FUNCTION [dbo].[DistBatchInCorrectStatusReject] 
(
	-- Add the parameters for the function here
	@new_dist_batch_statuses_id int,
	@dist_batch_id int
)
RETURNS bit
AS
BEGIN
	-- Declare the return variable here
	DECLARE @current_dist_batch_status_id int,
			@flow_from_dist_batch_status_id int,
			@dist_batch_status_flow_id int,
			--@dist_batch_type_id int,
			--@card_issue_method_id int,
			@Result bit

	SET @Result = 0

	--get the current status for the distribution batch
	SELECT @current_dist_batch_status_id = [dist_batch_status_current].dist_batch_statuses_id,
	       @dist_batch_status_flow_id = dist_batch_status_flow_id
			--@dist_batch_type_id = dist_batch_type_id,
			--@card_issue_method_id = card_issue_method_id
	FROM [dist_batch_status_current]
		INNER JOIN [dist_batch]
			ON [dist_batch_status_current].dist_batch_id = [dist_batch].dist_batch_id
		INNER JOIN [dist_batch_cards]
			ON [dist_batch].dist_batch_id = [dist_batch_cards].dist_batch_id
		INNER JOIN cards  
			ON [dist_batch_cards].card_id = cards.card_id
		INNER JOIN [issuer_product]
			ON cards.product_id = [issuer_product].product_id
		INNER JOIN [dist_batch_statuses_flow] AS [product_flow]
			ON (([dist_batch].dist_batch_type_id = 0 AND 
					[product_flow].dist_batch_status_flow_id = [issuer_product].production_dist_batch_status_flow)
				OR ([dist_batch].dist_batch_type_id = 1 AND 
					[product_flow].dist_batch_status_flow_id = [issuer_product].distribution_dist_batch_status_flow))
				AND [product_flow].dist_batch_statuses_id = [dist_batch_status_current].dist_batch_statuses_id
	WHERE dist_batch_status_current.dist_batch_id = @dist_batch_id

	--Check which status the batch must be in to flow to the new status
	SELECT @flow_from_dist_batch_status_id = dist_batch_statuses_id
	FROM dist_batch_statuses_flow
	WHERE dist_batch_status_flow_id = @dist_batch_status_flow_id
		AND reject_dist_batch_statuses_id = @new_dist_batch_statuses_id
		--AND dist_batch_type_id = @dist_batch_type_id
		--AND card_issue_method_id = @card_issue_method_id


	IF(@flow_from_dist_batch_status_id = @current_dist_batch_status_id)
		SET @Result = 1

	-- Return the result of the function
	RETURN @Result

END
GO
PRINT N'Altering [dbo].[MaskReportPAN]...';


GO
-- =============================================
-- Author:		Richard Brenchey
-- Create date: 
-- Description:	Determins if the users should have PAN masked for screen or not
-- =============================================
ALTER FUNCTION [dbo].[MaskReportPAN] 
(
	-- Add the parameters for the function here
	@user_id bigint
)
RETURNS bit
AS
BEGIN
	-- Declare the return variable here
	DECLARE @Result bit

	--Check if the user belongs to any user groups that have mask screen pan set to true
	SELECT @Result =
		CASE WHEN EXISTS (
			SELECT [user_group].mask_report_pan
			FROM [user_group]
				INNER JOIN [users_to_users_groups]
					ON [user_group].user_group_id = [users_to_users_groups].user_group_id
			WHERE [users_to_users_groups].[user_id] = @user_id
				AND [user_group].mask_report_pan = 1				
		)THEN 1 
		ELSE 0 END

	-- Return the result of the function
	RETURN @Result

END
GO
PRINT N'Altering [dbo].[MaskScreen]...';


GO
-- =============================================
-- Author:		Richard Brenchey
-- Create date: 
-- Description:	Determins if the users should have PAN masked for screen or not
-- =============================================
ALTER FUNCTION [dbo].[MaskScreen] 
(
	-- Add the parameters for the function here
	@user_id bigint
)
RETURNS bit
AS
BEGIN
	-- Declare the return variable here
	DECLARE @Result bit

	--Check if the user belongs to any user groups that have mask screen pan set to true
	SELECT @Result =
		CASE WHEN EXISTS (
			SELECT [user_group].mask_screen_pan
			FROM [user_group]
				INNER JOIN [users_to_users_groups]
					ON [user_group].user_group_id = [users_to_users_groups].user_group_id
			WHERE [users_to_users_groups].[user_id] = @user_id
				AND [user_group].mask_screen_pan = 1				
		)THEN 1 
		ELSE 0 END

	-- Return the result of the function
	RETURN @Result

END
GO
PRINT N'Refreshing [dbo].[user_group_branch_ex_ent]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[user_group_branch_ex_ent]';


GO
PRINT N'Refreshing [dbo].[user_roles_branch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[user_roles_branch]';


GO
PRINT N'Refreshing [dbo].[branch_card_status_current]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[branch_card_status_current]';


GO
PRINT N'Refreshing [dbo].[dist_batch_status_card_current]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[dist_batch_status_card_current]';


GO
PRINT N'Refreshing [dbo].[load_batch_status_card_current]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[load_batch_status_card_current]';


GO
PRINT N'Refreshing [dbo].[pin_mailer_reprint_status_current]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[pin_mailer_reprint_status_current]';


GO
PRINT N'Altering [dbo].[usp_cards_checkInOut]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Mark list of cards as checked in or out
-- =============================================
ALTER PROCEDURE [dbo].[usp_cards_checkInOut] 
	-- Add the parameters for the stored procedure here
	@operator_user_id bigint,
	@branch_id int,
	@product_id int,
	@card_id_array AS card_id_array READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

        BEGIN TRANSACTION [CARD_CHECKINOUT_TRAN]
		BEGIN TRY 

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

			DECLARE @status_date DATETIME
			SET @status_date = GETDATE()

			DECLARE @mask_screen bit = [dbo].MaskScreenPAN(@audit_user_id)

			--DECLARE @product_id int

			--SELECT @product_id = product_id 
			--FROM [cards]
			--WHERE card_id = (SELECT TOP 1 card_id FROM @card_id_array)

			--Temp table for cards to be checked out
			DECLARE @check_out_cards table(card_id bigint, branch_id int)

			--Temp table for cards to be check in
			DECLARE @check_in_cards table(card_id bigint, branch_id int)			

			--Find card to move from checked-in to checked out
			INSERT INTO @check_out_cards (card_id, branch_id)
			SELECT card_id, branch_id
			FROM [branch_card_status_current]
			WHERE  [branch_card_status_current].branch_card_statuses_id = 0
					AND [card_id] IN (SELECT card_id FROM @card_id_array)
					AND [product_id] = @product_id


			--Find cards to move from checked out to checked in
			INSERT INTO @check_in_cards (card_id, branch_id)
			SELECT card_id, branch_id
			FROM [branch_card_status_current]
			WHERE [branch_card_status_current].operator_user_id = @operator_user_id
					AND [branch_card_status_current].branch_card_statuses_id = 1
					AND [card_id] NOT IN (SELECT card_id FROM @card_id_array)
					AND [product_id] = @product_id


			--Audit Checked out cards MUST HAPPEN BEFORE ACTUAL INSERT OR NOTHING WILL SHOW IN AUDIT
			DECLARE @audit_description varchar(max),
					@branch_card_status_name varchar(50),
					@operator_name varchar(100)

			SELECT @operator_name = CONVERT(VARCHAR,DECRYPTBYKEY(username))
			FROM [user]
			WHERE [user_id] = @operator_user_id

			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM branch_card_statuses
			WHERE branch_card_statuses_id = 1			

			INSERT INTO [audit_control]
				([audit_action_id], [user_id], [audit_date], [workstation_address], [action_description]
				,[issuer_id], [data_changed], [data_before], [data_after])
			SELECT 1, @audit_user_id, GETDATE(), @audit_workstation, 
				COALESCE(@branch_card_status_name , 'UNKNWON') + ' (check out)' +
				', ' + dbo.MaskString(CONVERT(VARCHAR(max),DECRYPTBYKEY(card_number)),6,4) +
				', to ' + COALESCE(@operator_name, 'UNKNOWN')
				, NULL, NULL, NULL, NULL
				FROM @check_out_cards cardsArray 
					INNER JOIN [branch_card_status_current]
						ON cardsArray.card_id = [branch_card_status_current].card_id
					INNER JOIN [cards]
						ON [cards].card_id = cardsArray.card_id


			--Update Branch Cards status with checked out cards
			INSERT INTO [branch_card_status]
							(card_id, branch_id, operator_user_id, status_date, [user_id], branch_card_statuses_id)
			SELECT cardsArray.card_id, cardsArray.branch_id, @operator_user_id, @status_date, @audit_user_id, 1
			FROM @check_out_cards cardsArray
		

			--Audit Checked in cards MUST HAPPEN BEFORE ACTUAL INSERT OR NOTHING WILL SHOW IN AUDIT
			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM branch_card_statuses
			WHERE branch_card_statuses_id = 0		

			INSERT INTO [audit_control]
				([audit_action_id], [user_id], [audit_date], [workstation_address], [action_description]
				,[issuer_id], [data_changed], [data_before], [data_after])
			SELECT 
				1
				, @audit_user_id
				, GETDATE()
				, @audit_workstation
				, COALESCE(@branch_card_status_name , 'UNKNWON') + 
					' (check in)' +
					', ' + [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4)
						 +
					', ' + cards.card_request_reference +
					', from ' + COALESCE(@operator_name, 'UNKNOWN')
				, NULL, NULL, NULL, NULL
			FROM 
				@check_in_cards cardsArray 
				INNER JOIN [branch_card_status_current] ON cardsArray.card_id = [branch_card_status_current].card_id
				INNER JOIN [cards] ON [cards].card_id = cardsArray.card_id			
				INNER JOIN [branch] ON [cards].branch_id = [branch].branch_id
				INNER JOIN [issuer] ON [branch].issuer_id = [issuer].issuer_id	
			--WHERE  [branch_card_status_current].branch_card_statuses_id = 1

			--Update Branch Cards status with checked in cards
			INSERT INTO [branch_card_status]
				(card_id, branch_id, operator_user_id, status_date, [user_id], branch_card_statuses_id)
			SELECT cardsArray.card_id, cardsArray.branch_id, null, @status_date, @audit_user_id, 0
			FROM @check_in_cards cardsArray			
			
			--return list of cards that had been checked in and/or out.
			SELECT 
				[cards].card_id, 
				CASE 
					WHEN @mask_screen = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
					ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
				END AS 'card_number'
				, [cards].card_request_reference AS card_reference_number
				, [branch_card_status_current].branch_card_statuses_id
				, [branch_card_statuses].branch_card_statuses_name
				, [branch_card_status_current].operator_user_id
				, [branch_card_status_current].status_date			   
			FROM [cards]
				INNER JOIN [branch_card_status_current]
					ON [cards].card_id = [branch_card_status_current].card_id
				INNER JOIN [branch_card_statuses]
					ON 	[branch_card_statuses].branch_card_statuses_id = [branch_card_status_current].branch_card_statuses_id
			WHERE [cards].card_id IN (SELECT card_id FROM @check_out_cards)
					OR
				  [cards].card_id IN (SELECT card_id FROM @check_in_cards)
			

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

			COMMIT TRANSACTION [CARD_CHECKINOUT_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [CARD_CHECKINOUT_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_card_MakerChecker]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_card_MakerChecker] 
	@card_id bigint,
	@approve bit,
	@notes varchar(1000),
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@card_issue_method_id int OUTPUT,
	@ResultCode int OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [MAKER_CHECKER_TRAN]
		BEGIN TRY 

			DECLARE @current_status int,
					@branch_id int				

			--Get the issue method of the card
			SELECT @card_issue_method_id = card_issue_method_id, @branch_id = branch_id
			FROM [cards]
			where card_id = @card_id

			SELECT @current_status = branch_card_statuses_id
			FROM [branch_card_status_current]
			WHERE card_id = @card_id			

			IF(@current_status != 2)
				BEGIN
					SET @ResultCode = 100
				END
			ELSE
				BEGIN
					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					DECLARE @status_date datetime,
							@new_status_id int,
							@operator_username varchar(100)

					--Operator username needed for audit
					SELECT @operator_username = CONVERT(VARCHAR,DECRYPTBYKEY(username))
					FROM [branch_card_status_current]
							INNER JOIN [user]
								ON [branch_card_status_current].operator_user_id = [user].[user_id]
					WHERE [branch_card_status_current].card_id = @card_id

					SET @status_date = GETDATE()

					IF(@approve = 1)
						SET @new_status_id = 3
					ELSE
						BEGIN
							IF (@card_issue_method_id = 1)
								BEGIN
									SET @new_status_id = 1

									--Delete the customer information, it is not needed.
									DELETE FROM [customer_fields]
									WHERE customer_account_id = (SELECT customer_account_id FROM [customer_account] WHERE card_id = @card_id)

									DELETE FROM [customer_image_fields]
									WHERE customer_account_id = (SELECT customer_account_id FROM [customer_account] WHERE card_id = @card_id)

									DELETE FROM customer_account WHERE card_id = @card_id
								END
							ELSE
								SET @new_status_id = 11
						END

					--Update Branch Cards status with checked out cards
					INSERT INTO [branch_card_status]
									(card_id, branch_id, operator_user_id, status_date, [user_id], branch_card_statuses_id, comments)
					SELECT @card_id, @branch_id, [branch_card_status_current].operator_user_id, @status_date, @audit_user_id, @new_status_id, @notes
					FROM [branch_card_status_current]
					WHERE [branch_card_status_current].card_id = @card_id


					--log the audit record
					DECLARE @audit_description varchar(max),
					        @branchcardstatus  varchar(50),
							@cardnumber varchar(50)	,
							@cardreferencenumber varchar(50)			

					SELECT  @branchcardstatus =  branch_card_statuses_name
					FROM    branch_card_statuses 
					WHERE	branch_card_statuses_id = @new_status_id

					
					 
					SELECT	@cardnumber = [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4)
						, @cardreferencenumber = [cards].card_request_reference
					FROM
						[cards] 				
						INNER JOIN [branch] ON [cards].branch_id = [branch].branch_id
						INNER JOIN [issuer] ON [branch].issuer_id = [issuer].issuer_id	
					WHERE	card_id = @card_id					

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

					IF(@approve = 0)
						BEGIN
							SET @audit_description = COALESCE(@branchcardstatus, 'UNKNOWN') + '(reject)' + 
													', ' + @cardnumber + 
													', ' + @cardreferencenumber +
													', to ' + COALESCE(@operator_username, 'UNKOWN')
						END
					ELSE
						BEGIN
							SET @audit_description = COALESCE(@branchcardstatus, 'UNKNOWN') +
													', ' + @cardnumber + ', ' + @cardreferencenumber
						END					
						
					EXEC usp_insert_audit @audit_user_id, 
										 3, ---IssueCard
										 @status_date, 
										 @audit_workstation, 
										 @audit_description, 
										 NULL, NULL, NULL, NULL

					SET @ResultCode = 0
				END

			COMMIT TRANSACTION [MAKER_CHECKER_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [MAKER_CHECKER_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_create_export_batches]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_create_export_batches]
	-- Add the parameters for the stored procedure here
	@issuer_id int = null,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @product_id int, @issuer_id_cursor int	
	DECLARE @confirmed_export_batches TABLE (export_batch_id bigint)
	DECLARE @export_cards TABLE (card_id bigint)
	DECLARE @export_batch TABLE (ID bigint)
	DECLARE @product_code varchar(50)

	SET @ResultCode = 0

	--Find products who have exportable set to true and are not deleted.
	DECLARE export_product_cursor CURSOR FOR 
		SELECT product_id, issuer_id, product_code 
		FROM [issuer_product] 
		WHERE cms_exportable_YN = 1 
				AND DeletedYN = 0
				AND issuer_id = COALESCE(@issuer_id, issuer_id)
	OPEN export_product_cursor
	FETCH NEXT FROM export_product_cursor
	INTO @product_id, @issuer_id_cursor, @product_code

		WHILE @@FETCH_STATUS = 0
		BEGIN
			
			DECLARE @create_export_batch_statuses_id int = 0
				
			DELETE FROM @export_cards

			INSERT INTO @export_cards (card_id)
			SELECT [cards].card_id 
			FROM [cards] INNER JOIN [branch_card_status_current]						
					ON [cards].card_id = [branch_card_status_current].card_id 					
			WHERE [cards].product_id = @product_id 
				AND [branch_card_status_current].branch_card_statuses_id = 6
				AND [cards].export_batch_id IS NULL
				
			--Are there any cards that need a batch created
			IF EXISTS(SELECT * FROM @export_cards)
				BEGIN
					DECLARE @export_batch_id bigint

					BEGIN TRANSACTION [CREATE_EXPORT_BATCHES]
					BEGIN TRY 
						
						DECLARE @no_cards int						
						DELETE FROM @export_batch

						SELECT @no_cards = COUNT(card_id) FROM @export_cards

						--CREATE NEW EXPORT BATCH
						INSERT INTO [export_batch] (batch_reference, date_created, issuer_id, no_cards)
							OUTPUT inserted.export_batch_id INTO @export_batch(ID)
						VALUES (@product_code + '_' + CAST(SYSDATETIME() as varchar(max)), SYSDATETIME(), @issuer_id_cursor, @no_cards)

						--DECLARE @export_batch_id bigint
						SELECT TOP 1 @export_batch_id = ID FROM @export_batch

						--ADD CREATED STATUS
						INSERT INTO [export_batch_status] (export_batch_id, export_batch_statuses_id, status_date, [user_id], comments)
						VALUES (@export_batch_id, @create_export_batch_statuses_id, SYSDATETIME(), @audit_user_id, 'CREATED')
						
						--LINK CARDS TO EXPORT BATCH
						UPDATE [cards]
						SET export_batch_id = @export_batch_id
						WHERE card_id IN (SELECT card_id FROM @export_cards)
						
						--AUDIT CREATE
						DECLARE @batch_status_name varchar(100),
								@batch_ref varchar(100),
								@audit_msg varchar(max)

						SELECT @batch_status_name =  export_batch_statuses_name
						FROM export_batch_statuses
						WHERE export_batch_statuses_id = @create_export_batch_statuses_id

						SELECT @batch_ref = batch_reference
						FROM export_batch
						WHERE export_batch_id = @export_batch_id

						--Add audit for pin batch update								
						SET @audit_msg = 'Create: ' + CAST(@export_batch_id AS varchar(max)) +
											', ' + COALESCE(@batch_ref, 'UNKNOWN') +
											', ' + COALESCE(@batch_status_name, 'UNKNOWN')
								   
						--log the audit record		
						EXEC usp_insert_audit @audit_user_id, 
												11,
												NULL, 
												@audit_workstation, 
												@audit_msg, 
												NULL, NULL, NULL, NULL


						--AUTO-APPROVE BATCH?
						--DECLARE @ApproveResultCode int
						--DECLARE @hideResults TABLE (newvalue int)
						--INSERT INTO @hideResults 
						--EXEC usp_export_batch_status_approve @export_batch_id, 1, 0, @audit_user_id, @audit_workstation, @ApproveResultCode OUTPUT
						INSERT INTO [export_batch_status] (export_batch_id, export_batch_statuses_id, status_date, [user_id], comments)
						VALUES (@export_batch_id, 1, DATEADD(MILLISECOND, 1, SYSDATETIME()), @audit_user_id, 'AUTO APPROVED')


						--CHECK THAT ALL CARDS HAVE BEEN LINKED, if it doesnt match rollback for this product
						IF ( --@ApproveResultCode = 0 AND
								(SELECT COUNT(*) FROM @export_cards) =
								(SELECT COUNT(*) FROM [cards] WHERE export_batch_id = @export_batch_id
									AND card_id IN (SELECT card_id FROM @export_cards)))
							BEGIN
								INSERT INTO @confirmed_export_batches(export_batch_id)
								VALUES (@export_batch_id)

								COMMIT TRANSACTION [CREATE_EXPORT_BATCHES]
							END
						ELSE
							BEGIN
								SET @ResultCode = 1000				
								ROLLBACK TRANSACTION [CREATE_EXPORT_BATCHES]
							END

					END TRY
					BEGIN CATCH
						SET @ResultCode = 1000	
						ROLLBACK TRANSACTION [CREATE_EXPORT_BATCHES]
						DECLARE @ErrorMessage NVARCHAR(4000);
						DECLARE @ErrorSeverity INT;
						DECLARE @ErrorState INT;

						SELECT 
							@ErrorMessage = ERROR_MESSAGE(),
							@ErrorSeverity = ERROR_SEVERITY(),
							@ErrorState = ERROR_STATE();

						RAISERROR (@ErrorMessage, -- Message text.
									@ErrorSeverity, -- Severity.
									@ErrorState -- State.
									);
					END CATCH	
				END	
		
			FETCH NEXT FROM export_product_cursor
			INTO @product_id, @issuer_id_cursor, @product_code
		END 
	CLOSE export_product_cursor;
	DEALLOCATE export_product_cursor;

	SELECT * FROM [export_batch]
	WHERE export_batch_id IN (SELECT export_batch_id FROM @confirmed_export_batches)
END
GO
PRINT N'Altering [dbo].[usp_create_fee_scheme]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_create_fee_scheme] 
	-- Add the parameters for the stored procedure here
	@issuer_id int,
	@fee_scheme_name varchar(100),
	@fee_accounting_id int,
	@fee_detail_list as dbo.fee_detail_array READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@new_fee_scheme_id int OUTPUT,
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [CREATE_PRODUCT_FEE_SCHEME_TRAN]
		BEGIN TRY 			
			IF (SELECT COUNT(*) FROM [product_fee_scheme] 
					WHERE fee_scheme_name = @fee_scheme_name AND issuer_id = @issuer_id) > 0
				BEGIN
					SET @new_fee_scheme_id = 0
					SET @ResultCode = 226						
				END		
			ELSE
				BEGIN
					DECLARE @effective_from DATETIME = GETDATE()

					INSERT INTO product_fee_scheme (fee_scheme_name, issuer_id, fee_accounting_id, deleted_yn)
						VALUES (@fee_scheme_name, @issuer_id, @fee_accounting_id, 0)

					SET @new_fee_scheme_id = SCOPE_IDENTITY();

					INSERT INTO [product_fee_detail] (fee_scheme_id, fee_detail_name, fee_editable_YN, fee_waiver_YN, 
														effective_from, effective_to, deleted_yn)
					SELECT @new_fee_scheme_id, dl.fee_detail_name, dl.fee_editable_TN, dl.fee_waiver_YN, 
							@effective_from, null, 0
					FROM @fee_detail_list dl

					--log the audit record
			DECLARE @audit_description varchar(max), @fee_details varchar(max)

			SELECT  @fee_details = STUFF(
							(SELECT ' Fee Band Name: ' + dl.fee_detail_name + ', editable: ' +  CAST(dl.fee_editable_TN AS VARCHAR(MAX)) 
								+ ', waiver: ' +  CAST(dl.fee_waiver_YN AS VARCHAR(MAX)) + ';' 
								FROM @fee_detail_list dl
								FOR XML PATH(''))
							, 1
							, 1
							, '')
					

			SET @audit_description = 'Fee Scheme Create: ' + @fee_scheme_name	
										+ ' , Fee Scheme Id: ' + CAST(@new_fee_scheme_id  AS VARCHAR(max))
										+' , Fee Bands : ' + COALESCE(@fee_details, 'NONE')
										 	
			EXEC usp_insert_audit @audit_user_id, 
									4,
									NULL, 
									@audit_workstation, 
									@audit_description, 
									@issuer_id, NULL, NULL, NULL
					
					SET @ResultCode = 0
				END

				COMMIT TRANSACTION [CREATE_PRODUCT_FEE_SCHEME_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [CREATE_PRODUCT_FEE_SCHEME_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_create_terminal]...';


GO
-- =============================================
-- Author:		LTladi
-- Create date: 20150130
-- Description:	Insert new terminals (pin pad/POS)
-- =============================================
ALTER PROCEDURE [dbo].[usp_create_terminal]
	@terminal_name varchar(250)
	, @terminal_model varchar(250)
	, @device_id varchar(max)
	, @branch_id int
	, @terminal_masterkey_id int
	,@password   varchar(max)
	,@IsMacUsed bit 
	, @audit_user_id bigint
	, @audit_workstation varchar(100)
	, @new_terminal_id int OUTPUT
	
	, @ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
			OPEN Symmetric Key Indigo_Symmetric_Key
			DECRYPTION BY Certificate Indigo_Certificate;

	BEGIN TRANSACTION [INSERT_TERMINAL_TRAN]
		BEGIN TRY 

			--Check for duplicate's
			IF (SELECT COUNT(*) FROM [terminals] WHERE [terminals].[terminal_name] = @terminal_name) > 0
				BEGIN
					SET @new_terminal_id = 0
					SET @ResultCode = 604						
				END
			ELSE IF (SELECT COUNT(*) FROM [terminals] WHERE (CONVERT(VARCHAR(max),DECRYPTBYKEY([terminals].[device_id])) = @device_id)) > 0
				BEGIN
					SET @new_terminal_id = 0
					SET @ResultCode = 605
				END
			ELSE			
			BEGIN

		

				INSERT INTO [dbo].[terminals]
					   ( [terminal_name]
					   , [terminal_model]
					   , [device_id]
					   , [branch_id]
					   , [terminal_masterkey_id]
					   ,[password]
					   ,IsMacUsed
					   , [workstation]
					   , [date_created]
					   , [date_changed])
				 VALUES
					   ( @terminal_name
					   , @terminal_model
					   , CONVERT(varbinary(max),ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@device_id)))
					   , @branch_id
					   , @terminal_masterkey_id
					   , CONVERT(varbinary(max),ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@password)))
					   
					   ,@IsMacUsed
					   , @audit_workstation
					   , GETDATE()
					   , GETDATE())

				SET @new_terminal_id = SCOPE_IDENTITY();
			SET @ResultCode = 0	
		

				--log the audit record
				DECLARE @audit_description varchar(max), @issuer_id int, @audit_branch_name varchar(max), 
						@audit_branch_code varchar(max)

				SELECT @issuer_id = issuer_id, @audit_branch_name = branch_name,
						@audit_branch_code = branch_code
				FROM [branch]
				WHERE branch_id = @branch_id

				SET @audit_description = 'Terminal Create: '+ COALESCE(@terminal_name, 'UNKNOWN') 
										 + ' , Terminal Id: ' + CAST(@new_terminal_id as varchar(max))
										  + ' , branch code: ' + @audit_branch_code
										  + ' , branch name: ' + @audit_branch_name
										 	
				EXEC usp_insert_audit @audit_user_id, 
									 9,
									 NULL, 
									 @audit_workstation, 
									 @audit_description, 
									 @issuer_id, NULL, NULL, NULL

									 SET @ResultCode = 0		
					
			END

			COMMIT TRANSACTION [INSERT_TERMINAL_TRAN]
				
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [INSERT_TERMINAL_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
		CLOSE Symmetric Key Indigo_Symmetric_Key;	
END
GO
PRINT N'Altering [dbo].[usp_delete_fee_scheme]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_delete_fee_scheme] 
	-- Add the parameters for the stored procedure here
	@fee_scheme_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int output
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRY
		BEGIN TRANSACTION [DELETE_MASTERKEY_TRAN]


		IF((SELECT count(*) FROM [issuer_product] WHERE fee_scheme_id = @fee_scheme_id) > 0)
			BEGIN
				SET @ResultCode = 702
			END
		ELSE 
			BEGIN
				DECLARE @audit_product_name varchar(400), @issuer_id int
				SELECT @audit_product_name = fee_scheme_name
				FROM [product_fee_scheme]
				WHERE fee_scheme_id = @fee_scheme_id

				SELECT @issuer_id = issuer_id
				FROM [product_fee_scheme]
				WHERE fee_scheme_id = @fee_scheme_id

				--Delete charges
				DELETE FROM [product_fee_charge]
				WHERE fee_detail_id IN (SELECT fee_detail_id
										FROM [product_fee_detail]
										WHERE fee_scheme_id = @fee_scheme_id)

				--Delete details
				DELETE FROM product_fee_detail
				WHERE fee_scheme_id = @fee_scheme_id

				--Delete the Scheme
				DELETE FROM product_fee_scheme
				WHERE fee_scheme_id = @fee_scheme_id

				--Log in audit trail
				DECLARE @audit_description varchar(500)
				SELECT @audit_description = 'Fee Scheme Deleted: ' + @audit_product_name
											+ ' , Fee Scheme Id: ' + CAST(@fee_scheme_id AS VARCHAR(MAX))		
																	
				EXEC usp_insert_audit @audit_user_id, 
										4,
										NULL, 
										@audit_workstation, 
										@audit_description, 
										@issuer_id, NULL, NULL, NULL	

				SET @ResultCode = 0
			END

			COMMIT TRANSACTION [DELETE_MASTERKEY_TRAN]
	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [DELETE_MASTERKEY_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_delete_product]...';


GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_delete_product]
	@productid int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@result_code int =null output
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	BEGIN TRANSACTION [DELETE_PRODUCT_TRAN]
		BEGIN TRY 

			-- delete interface connections first
			DELETE FROM product_interface WHERE product_id = @productid

			
				
			-- then disable the product
			UPDATE issuer_product set DeletedYN=1 where product_id=@productid

			--Hard delete if no cards are linked to product
			IF(NOT EXISTS (SELECT product_id from cards where product_id = @productid))
			BEGIN
				DELETE FROM product_fields
				WHERE product_id = @productid

				DELETE FROM integration_cardnumbers
				WHERE product_id = @productid

				DELETE FROM product_external_system
				WHERE product_id = @productid

				DELETE FROM product_issue_reason
				WHERE product_id = @productid

				DELETE FROM products_account_types
				WHERE product_id = @productid

				DELETE FROM product_currency
				WHERE product_id = @productid

				DELETE FROM issuer_product
				WHERE product_id = @productid

			
				--AND NOT EXISTS (SELECT product_id from cards where product_id = @productid)
			END		


			-- then update the audit information
			DECLARE @audit_description varchar(max), @issuer_id int
			SELECT @audit_description = 'Product Deleted: ' + CAST(@productid as varchar(max))
										+' , Product Id: ' + CAST(@productid as varchar(max))

			IF EXISTS(SELECT product_id from cards where product_id = @productid)
				SET @audit_description += ' , Product soft deleted.'
			ELSE
				SET @audit_description += ' , Product hard deleted.'

			SELECT 	@issuer_id = issuer_id
			FROM [issuer_product]
			WHERE product_id = @productid
																	
			EXEC usp_insert_audit @audit_user_id, 
									4,
									NULL, 
									@audit_workstation, 
									@audit_description, 
									@issuer_id, NULL, NULL, NULL

			COMMIT TRANSACTION [DELETE_PRODUCT_TRAN]
				
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [DELETE_PRODUCT_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_export_batch_status_exported]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_export_batch_status_exported] 
	-- Add the parameters for the stored procedure here
	@export_batch_id bigint,
	@language_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [EXPORT_BATCH_EXPORTED]
		BEGIN TRY 
			
			DECLARE @audit_msg varchar(max),
					@new_export_batch_statuses_id int = 2
						
						  
			--Check that someone hasn't already updated the dist batch
			IF((SELECT export_batch_statuses_id FROM [export_batch_status_current] WHERE export_batch_id = @export_batch_id) != 1)
				BEGIN
					SET @ResultCode = 100
				END
			ELSE
				BEGIN	

					--Adding some milliseconds for fast servers that might log all batches at the same time
					INSERT INTO export_batch_status (export_batch_id, export_batch_statuses_id, status_date, [user_id], comments)
					VALUES (@export_batch_id, @new_export_batch_statuses_id, DATEADD(MILLISECOND, 10, SYSDATETIME()), @audit_user_id, 'BATCH EXPORTED')
					

					--AUDIT 
					DECLARE @batch_status_name varchar(100),
							@batch_ref varchar(100)

					SELECT @batch_status_name =  export_batch_statuses_name
					FROM export_batch_statuses
					WHERE export_batch_statuses_id = @new_export_batch_statuses_id

					SELECT @batch_ref = batch_reference
					FROM export_batch
					WHERE export_batch_id = @export_batch_id

					--Add audit for pin batch update								
					SET @audit_msg = 'Update: ' + CAST(@export_batch_id AS varchar(max)) +
										', ' + COALESCE(@batch_ref, 'UNKNOWN') +
										', ' + COALESCE(@batch_status_name, 'UNKNOWN')
								   
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
											11,
											NULL, 
											@audit_workstation, 
											@audit_msg, 
											NULL, NULL, NULL, NULL

					 

					SET @ResultCode = 0					
				END

				--Fetch the batch with latest details
				EXEC usp_get_export_batch @export_batch_id,
										@language_id,
										@audit_user_id,
										@audit_workstation

				COMMIT TRANSACTION [EXPORT_BATCH_EXPORTED]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [EXPORT_BATCH_EXPORTED]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_finalise_login_failed]...';


GO

-- =============================================
-- Author:		Selebalo Setenane
-- Create date: 11 March 2014
-- Description:	This stored procedure will fanalise the failed login by updating last login, workstation etc.
-- =============================================

ALTER PROCEDURE [dbo].[usp_finalise_login_failed] 
    @user_id bigint,    
	@audit_workstation VARCHAR(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [FINALISE_LOGIN_FAILED_TRAN]
		BEGIN TRY
			
			

			--Fetch number of incorrect login attempts
			--SELECT @incorrect_login_attempts = number_of_incorrect_logins, @uer_status_id = user_status_id, 
			--		@last_login_attempt = last_login_attempt
			--FROM [user]
			--WHERE [user].[user_id] = @user_id


			

			--Check how long the user is locked out for
			--IF( DATEADD(hour, @PasswordAttemptLockoutDuration, @last_login_attempt) >= GETDATE())
			--BEGIN
			--	IF(@incorrect_login_attempts >= @maxInvalidPasswordAttempts)
			--	BEGIN
			--		UPDATE [user] 
			--		SET [user_status_id] = 3 
			--		WHERE [user].[user_id] = @user_id
			--	END
				
			--	--Update last login and increment the incorrect login attempts
			--	UPDATE [user]
			--	SET last_login_attempt = GETDATE(),
			--		number_of_incorrect_logins = (@incorrect_login_attempts + 1)
			--	WHERE [user].[user_id] = @user_id
			--END
			--ELSE
			--BEGIN
			--	UPDATE [user] 
			--	SET [user_status_id] = 0
			--		,number_of_incorrect_logins = 1
			--		,last_login_attempt = GETDATE()
			--	WHERE [user].[user_id] = @user_id
			--END



			DECLARE @maxInvalidPasswordAttempts int
					 
			SELECT @maxInvalidPasswordAttempts = maxInvalidPasswordAttempts
			FROM [user_admin]

			--Increment number of login tried, lockout if limit reached
			UPDATE [user] 
			SET [number_of_incorrect_logins] = [user].[number_of_incorrect_logins] + 1
			    , [last_login_attempt] = GETDATE()
				, [user_status_id] = CASE WHEN [user].[number_of_incorrect_logins] + 1 >= @maxInvalidPasswordAttempts 
										THEN 3 
										ELSE [user_status_id] END
			WHERE [user].[user_id] = @user_id


			--log the audit record
			DECLARE @audit_description varchar(500)
			SELECT @audit_description = 'Login failed'			
			EXEC usp_insert_audit @user_id, 
									6,---Logon
									NULL, 
									@audit_workstation, 
									@audit_description, 
									NULL, NULL, NULL, NULL

			COMMIT TRANSACTION [FINALISE_LOGIN_FAILED_TRAN]

		END TRY
		BEGIN CATCH
		  ROLLBACK TRANSACTION [FINALISE_LOGIN_FAILED_TRAN]
		  			DECLARE @ErrorMessage NVARCHAR(4000);
			DECLARE @ErrorSeverity INT;
			DECLARE @ErrorState INT;

			SELECT 
				@ErrorMessage = ERROR_MESSAGE(),
				@ErrorSeverity = ERROR_SEVERITY(),
				@ErrorState = ERROR_STATE();

			RAISERROR (@ErrorMessage, -- Message text.
						@ErrorSeverity, -- Severity.
						@ErrorState -- State.
						);
		END CATCH 
	RETURN
END
GO
PRINT N'Altering [dbo].[usp_insert_branch]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Persist new branch to db
-- =============================================
ALTER PROCEDURE [dbo].[usp_insert_branch] 
	@branch_status_id int,
	@issuer_id int,
	@branch_code varchar(10),
	@branch_name varchar(30),
	@card_centre_branch_YN bit,
	@location varchar(20),
	@contact_person varchar(30),
	@contact_email varchar(30),
	@card_centre varchar(10),	 
	@emp_branch_code varchar(10),
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@new_branch_id int OUTPUT,
	@ResultCode int OUTPUT
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;	

		

			--Check for duplicate's
			IF (SELECT COUNT(*) FROM [branch] WHERE ([branch_code] = @branch_code AND [issuer_id] = @issuer_id)) > 0
				BEGIN
					SET @new_branch_id = 0
					SET @ResultCode = 211						
				END
			ELSE IF (SELECT COUNT(*) FROM [branch] WHERE ([branch_name] = @branch_name AND [issuer_id] = @issuer_id)) > 0
				BEGIN
					SET @new_branch_id = 0
					SET @ResultCode = 210
				END
			ELSE
			BEGIN	
			
			BEGIN TRANSACTION [INSERT_BRANCH_TRAN]
				BEGIN TRY 		

				INSERT INTO [branch]
						([branch_status_id],[issuer_id],[branch_code],[branch_name],[location]
						,[contact_person],[contact_email],[card_centre], [card_centre_branch_YN],[emp_branch_code])
					VALUES
						(@branch_status_id, @issuer_id, @branch_code, @branch_name, @location,
						@contact_person, @contact_email, @card_centre, @card_centre_branch_YN,@emp_branch_code)

				SET @new_branch_id = SCOPE_IDENTITY();

				DECLARE @issuer_code varchar(10)
				SELECT @issuer_code = issuer_code
				FROM issuer
				WHERE issuer_id = @issuer_id

				DECLARE @group_name varchar(50),
						@new_group_id int
				SET @group_name =  @issuer_code + '_' + @branch_code + '_CUSTODIAN'

				--Insert Default user groups
				INSERT INTO [user_group]
					(all_branch_access, can_create, can_delete, can_read, can_update, issuer_id,
						user_group_name, user_role_id, mask_report_pan, mask_screen_pan)
				VALUES 
					(0, 1, 1, 1, 1, @issuer_id, @group_name, 2, 1, 1)

				SET @new_group_id = SCOPE_IDENTITY();

				INSERT INTO [user_groups_branches]
					(branch_id, user_group_id)
				VALUES 
					(@new_branch_id, @new_group_id)

				SET @group_name =  @issuer_code + '_' + @branch_code + '_OPERATOR'
				INSERT INTO [user_group]
					(all_branch_access, can_create, can_delete, can_read, can_update, issuer_id,
						user_group_name, user_role_id, mask_report_pan, mask_screen_pan)
				VALUES 
					(0, 1, 1, 1, 1, @issuer_id, @group_name, 3, 1, 1)

				SET @new_group_id = SCOPE_IDENTITY();

				INSERT INTO [user_groups_branches]
					(branch_id, user_group_id)
				VALUES 
					(@new_branch_id, @new_group_id)

				--log the audit record
				DECLARE @audit_description varchar(500)
				DECLARE @branchstatus  varchar(50)

				SELECT @branchstatus = branch_statuses.[branch_status]
				FROM branch_statuses 
				WHERE branch_statuses.branch_status_id = @branch_status_id

				SELECT @audit_description = 'Create: ID ' + CAST(@new_branch_id AS varchar(max))	+ ', [' + CAST(@issuer_id as varchar(100)) + ';' + @issuer_code + '], [' +
											@branch_code + ';' + @branch_name + ', ' + @branchstatus + ']'

				EXEC usp_insert_audit @audit_user_id, 
									 0,--BranchAdmin
									 NULL,
									 @audit_workstation, 
									 @audit_description, 
									 @issuer_id, NULL, NULL, NULL

				SET @ResultCode = 0

				COMMIT TRANSACTION [INSERT_BRANCH_TRAN]			
		END TRY
	BEGIN CATCH		
		ROLLBACK TRANSACTION [INSERT_BRANCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
	END
END
GO
PRINT N'Altering [dbo].[usp_issue_card_cms_edit_fail]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_cms_edit_fail] 
	@card_id bigint,
	@error varchar(5000),	 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	BEGIN TRANSACTION [ISSUE_CARD_CMS_EDIT_FAIL_TRAN]
		BEGIN TRY 

			DECLARE @branch_card_code_id int,
					@current_card_status_id int,
					@branch_id int,
					@status_date datetime

			--try find the error in response mapping as to link to code.
			SELECT TOP 1 @branch_card_code_id = branch_card_code_id
			FROM [mod_response_mapping]
			WHERE @error LIKE '%' + response_contains + '%'

			--Check if a valid code was found for error, if not set as UNKNOWN Error
			IF @branch_card_code_id IS NULL
				SET @branch_card_code_id = 7

			SELECT @branch_id = branch_id
			FROM [cards]
			WHERE card_id = @card_id

			--Update the cards status.
			INSERT branch_card_status
					(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, 
					 branch_card_code_id, comments)
			VALUES (@card_id, @branch_id, 9, @status_date, @audit_user_id, @audit_user_id, @branch_card_code_id, @error) 


			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @cardnumber varchar(50),
					@branch_card_status_name varchar(50),
					@audit_msg varchar(max)

			SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
			FROM cards 
			WHERE cards.card_id = @card_id

			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM [branch_card_statuses]
			WHERE branch_card_statuses_id = 9

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

			SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
								', ' + dbo.MaskString(@cardnumber, 6, 4) +
								', ' + @error

			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

			

			COMMIT TRANSACTION [ISSUE_CARD_CMS_EDIT_FAIL_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_CMS_EDIT_FAIL_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_issue_card_cms_fail]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_cms_fail] 
	@card_id bigint,
	@error varchar(1000), 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	BEGIN TRANSACTION [ISSUE_CARD_CMS_FAIL_TRAN]
		BEGIN TRY 

			DECLARE @branch_card_code_id int,
					@current_card_status_id int,
					@branch_id int,
					@status_date datetime

			--try find the error in response mapping as to link to code.
			--SELECT TOP 1 @branch_card_code_id = branch_card_code_id
			--FROM [mod_response_mapping]
			--WHERE @error LIKE '%' + response_contains + '%'

			--Check if a valid code was found for error, if not set as UNKNOWN Error
			IF @branch_card_code_id IS NULL
				SET @branch_card_code_id = 7

			SET @status_date = GETDATE()

			--Check what status the card was last in
			--SELECT @current_card_status_id = branch_card_statuses_id
			--FROM branch_card_status_current
			--WHERE card_id = @card_id

			SELECT @branch_id = branch_id
			FROM [cards]
			WHERE card_id = @card_id

			--Update the cards status.
			INSERT branch_card_status
					(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, 
					 branch_card_code_id, comments)
			VALUES (@card_id, @branch_id, 9, @status_date, @audit_user_id, @audit_user_id, @branch_card_code_id, @error) 


			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @cardnumber varchar(50),
					@branch_card_status_name varchar(50),
					@audit_msg varchar(max)

			SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
			FROM cards 
			WHERE cards.card_id = @card_id

			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM [branch_card_statuses]
			WHERE branch_card_statuses_id = 9

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

			SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
							 ', ' + dbo.MaskString(@cardnumber, 6, 4) +
							 ', ' + @error
			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

		

			COMMIT TRANSACTION [ISSUE_CARD_CMS_FAIL_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_CMS_FAIL_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_issue_card_cms_relink_fail]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_cms_relink_fail] 
	@card_id bigint,	
	@error varchar(1000), 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	BEGIN TRANSACTION [ISSUE_CARD_CMS_RELINK_FAIL_TRAN]
		BEGIN TRY 

			DECLARE @branch_card_code_id int,
					@current_card_status_id int,
					@branch_id int,
					@status_date datetime

			--try find the error in response mapping as to link to code.
			SELECT TOP 1 @branch_card_code_id = branch_card_code_id
			FROM [mod_response_mapping]
			WHERE @error LIKE '%' + response_contains + '%'

			--Check if a valid code was found for error, if not set as UNKNOWN Error
			IF @branch_card_code_id IS NULL
				SET @branch_card_code_id = 7

			SELECT @branch_id = branch_id
			FROM [cards]
			WHERE card_id = @card_id

			--Update the cards status.
			INSERT branch_card_status
					(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, 
					 branch_card_code_id, comments)
			VALUES (@card_id, @branch_id, 9, @status_date, @audit_user_id, @audit_user_id, @branch_card_code_id, @error) 


			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @cardnumber varchar(50),
					@branch_card_status_name varchar(50),
					@audit_msg varchar(max)

			SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
			FROM cards 
			WHERE cards.card_id = @card_id

			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM [branch_card_statuses]
			WHERE branch_card_statuses_id = 9

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

			SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
							 ', ' + dbo.MaskString(@cardnumber, 6, 4)+
							 ', ' + @error
								
			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

			

			COMMIT TRANSACTION [ISSUE_CARD_CMS_RELINK_FAIL_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_CMS_RELINK_FAIL_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_issue_card_cms_retry]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_cms_retry] 
	@card_id bigint,
	@error varchar(1000), 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	BEGIN TRANSACTION [ISSUE_CARD_CMS_RETRY_TRAN]
		BEGIN TRY 

			DECLARE @branch_card_code_id int,
					@current_card_status_id int,
					@branch_id int,
					@status_date datetime

			--Check if a valid code was found for error, if not set as UNKNOWN Error
			IF @branch_card_code_id IS NULL
				SET @branch_card_code_id = 7

			SET @status_date = GETDATE()

			SELECT @branch_id = branch_id
			FROM [cards]
			WHERE card_id = @card_id

			--Update the cards status.
			INSERT branch_card_status
					(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, 
					 branch_card_code_id, comments)
			VALUES (@card_id, @branch_id, 15, @status_date, @audit_user_id, @audit_user_id, @branch_card_code_id, @error) 


			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @cardnumber varchar(50),
					@branch_card_status_name varchar(50),
					@audit_msg varchar(max)

			SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
			FROM cards 
			WHERE cards.card_id = @card_id

			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM [branch_card_statuses]
			WHERE branch_card_statuses_id = 15

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

			SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
							 ', ' + dbo.MaskString(@cardnumber, 6, 4) +
							 ', ' + @error
			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

		

			COMMIT TRANSACTION [ISSUE_CARD_CMS_RETRY_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_CMS_RETRY_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_issue_card_cms_success]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_cms_success] 
	-- Add the parameters for the stored procedure here
	@card_id bigint, 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    	BEGIN TRANSACTION [ISSUE_CARD_CMS_SUCCESS_TRAN]
		BEGIN TRY 

			DECLARE @status_date datetime,
					@branch_id int
			SET @status_date = GETDATE()

			SELECT @branch_id = branch_id
			FROM [cards]
			WHERE card_id = @card_id

			--Update the cards status.
			INSERT branch_card_status
					(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, 
					 branch_card_code_id)
			VALUES (@card_id, @branch_id, 6, @status_date, @audit_user_id, @audit_user_id, 4 ) 


			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @cardnumber varchar(50),
					@branch_card_status_name varchar(50),
					@audit_msg varchar(max)

			SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
			FROM cards 
			WHERE cards.card_id = @card_id

			SELECT @branch_card_status_name = branch_card_statuses_name
			FROM [branch_card_statuses]
			WHERE branch_card_statuses_id = 6

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

			SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
								', ' + dbo.MaskString(@cardnumber, 6, 4)
			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

			COMMIT TRANSACTION [ISSUE_CARD_CMS_SUCCESS_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_CMS_SUCCESS_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_issue_card_print_error]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_print_error] 
	@card_id bigint,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [ISSUE_CARD_PRINT_ERROR_TRAN]
		BEGIN TRY 
			
			DECLARE @maker_checker bit,
					@current_card_status_id int,
					@card_issue_method_id int,
					@branch_id int,
					@status_date datetime
					

			--get the current status for the card
			SELECT @current_card_status_id = branch_card_statuses_id,
					@card_issue_method_id = [cards].card_issue_method_id
			FROM branch_card_status_current INNER JOIN [cards]
				ON branch_card_status_current.card_id = [cards].card_id
			WHERE [cards].card_id = @card_id

			SELECT @maker_checker = [issuer].maker_checker_YN
			FROM [issuer] INNER JOIN [branch]
					ON [issuer].issuer_id = [branch].issuer_id
					INNER JOIN [cards]
					ON [branch].branch_id = [cards].branch_id
			WHERE [cards].card_id = @card_id
										  
			--Check that someone hasn't already updated the card			
			IF ( (@card_issue_method_id = 1 AND @current_card_status_id = 2 AND @maker_checker = 0) OR 
				 (@card_issue_method_id = 1 AND @current_card_status_id = 3 AND @maker_checker = 1) OR
				 (@card_issue_method_id = 0 AND @current_card_status_id = 0))
				BEGIN

					SET @status_date = GETDATE()

					SELECT @branch_id = branch_id
					FROM [cards]
					WHERE card_id = @card_id

					--Update the cards status.
					INSERT branch_card_status
							(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id)
					VALUES (@card_id, @branch_id, 8, @status_date, @audit_user_id, @audit_user_id) 


					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					DECLARE @cardnumber varchar(50),
							@branch_card_status_name varchar(50),
							@audit_msg varchar(max)

					SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
					FROM cards 
					WHERE cards.card_id = @card_id

					SELECT @branch_card_status_name = branch_card_statuses_name
					FROM [branch_card_statuses]
					WHERE branch_card_statuses_id = 8

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

					SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
									 ', ' + dbo.MaskString(@cardnumber, 6, 4)
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
										 3,
										 NULL, 
										 @audit_workstation, 
										 @audit_msg, 
										 NULL, NULL, NULL, NULL

					SET @ResultCode = 0					
				END
			ELSE
				BEGIN
					SET @ResultCode = 100
				END

				COMMIT TRANSACTION [ISSUE_CARD_PRINT_ERROR_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_PRINT_ERROR_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_issue_card_printed]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_printed] 
	@card_id bigint,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [ISSUE_CARD_PRINTED_TRAN]
		BEGIN TRY 
			
			DECLARE @maker_checker bit,
			        @current_card_status_id int,
					@card_issue_method_id int,
					@branch_id int,
					@status_date datetime
					

			--get the current status for the card
			SELECT @current_card_status_id = branch_card_statuses_id,
					@card_issue_method_id = [cards].card_issue_method_id
			FROM branch_card_status_current INNER JOIN [cards]
				ON branch_card_status_current.card_id = [cards].card_id
			WHERE [cards].card_id = @card_id

			SELECT @maker_checker = [issuer].maker_checker_YN
			FROM [issuer] INNER JOIN [branch]
					ON [issuer].issuer_id = [branch].issuer_id
					INNER JOIN [cards]
					ON [branch].branch_id = [cards].branch_id
			WHERE [cards].card_id = @card_id
										  
			--Check that someone hasn't already updated the card
							
			IF ( (@card_issue_method_id = 1 AND @current_card_status_id = 2 AND @maker_checker = 0) OR 
				 (@card_issue_method_id = 1 AND @current_card_status_id = 3 AND @maker_checker = 1) OR
				 (@card_issue_method_id = 0 AND @current_card_status_id = 0))
				BEGIN

					SET @status_date = GETDATE()

					SELECT @branch_id = branch_id
					FROM [cards]
					WHERE card_id = @card_id

					--Update the cards status.
					INSERT branch_card_status
							(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, branch_card_code_id)
					VALUES (@card_id, @branch_id, 4, @status_date, @audit_user_id, @audit_user_id, 0) 


					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					DECLARE @cardnumber varchar(50),
							@branch_card_status_name varchar(50),
							@audit_msg varchar(max)

					SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
					FROM cards 
					WHERE cards.card_id = @card_id

					SELECT @branch_card_status_name = branch_card_statuses_name
					FROM [branch_card_statuses]
					WHERE branch_card_statuses_id = 4

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

					SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
									 ', ' + dbo.MaskString(@cardnumber, 6, 4)
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
										 3,
										 NULL, 
										 @audit_workstation, 
										 @audit_msg, 
										 NULL, NULL, NULL, NULL

					SET @ResultCode = 0					
				END
			ELSE
				BEGIN
					SET @ResultCode = 100
				END

				COMMIT TRANSACTION [ISSUE_CARD_PRINTED_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_PRINTED_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_issue_card_spoil]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_spoil] 
	@card_id bigint,
	@branch_card_code_id int,
	@spoil_comments varchar(1000),
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [ISSUE_CARD_SPOIL_TRAN]
		BEGIN TRY 
			
			DECLARE @current_card_status_id int,
					@branch_id int,
					@status_date datetime
					

			--get the current status for the card
			SELECT @current_card_status_id = branch_card_statuses_id
			FROM branch_card_status_current
			WHERE card_id = @card_id
										  
			--Check that someone hasn't already updated the card
			--IF(@current_card_status_id = 8 OR @current_card_status_id = 9)
				BEGIN

					SET @status_date = GETDATE()

					SELECT @branch_id = branch_id
					FROM [cards]
					WHERE card_id = @card_id

					--Update the cards status.
					INSERT branch_card_status
							(card_id, branch_id, branch_card_statuses_id, status_date, [user_id],
							 branch_card_code_id, comments)
					VALUES (@card_id, @branch_id, 7, @status_date, @audit_user_id, @branch_card_code_id, @spoil_comments) 


					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					DECLARE @cardnumber varchar(50),
							@branch_card_status_name varchar(50),
							@audit_msg varchar(max)

					SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
					FROM cards 
					WHERE cards.card_id = @card_id

					SELECT @branch_card_status_name = branch_card_statuses_name
					FROM [branch_card_statuses]
					WHERE branch_card_statuses_id = 7

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

					SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
										', ' + dbo.MaskString(@cardnumber, 6, 4)
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
											3,
											NULL, 
											@audit_workstation, 
											@audit_msg, 
											NULL, NULL, NULL, NULL

					SET @ResultCode = 0					
				END
			--ELSE
			--	BEGIN
			--		SET @ResultCode = 100
			--	END
			

				COMMIT TRANSACTION [ISSUE_CARD_SPOIL_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_SPOIL_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_issue_card_to_customer]...';


GO
ALTER PROCEDURE [dbo].[usp_issue_card_to_customer]
	@card_id bigint,	
    @customer_account_number varchar(27),
	@domicile_branch_id int,
	@account_type_id int,
	@card_issue_reason_id int,
	@customer_first_name varchar(50),
	@customer_middle_name varchar(50),
	@customer_last_name varchar(50),
	@name_on_card varchar(30),
	@customer_title_id int,
	@cms_id varchar(50),
	@customer_id varchar(150),
	@contract_number varchar(50),
	@contact_number varchar(50),
	@id_number varchar(50),
	@currency_id int,
	@resident_id int,
	@customer_type_id int,
	@fee_detail_id int = NULL,
	@fee_waiver_YN bit = NULL,
	@fee_editable_YN bit = NULL,
	@fee_charged decimal(10,4) = NULL,
	@fee_overridden_YN bit = NULL,
	@product_fields as dbo.key_binary_value_array READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [ISSUE_CARD_TO_CUST_TRAN]
		BEGIN TRY 

			IF @customer_middle_name IS NULL
				SET @customer_middle_name = ''
			
			DECLARE @new_customer_account_id bigint,
					@branch_id int,
					@current_card_status_id int,
					@status_date datetime

			--get the current status for the card
			SELECT @current_card_status_id = branch_card_statuses_id
			FROM branch_card_status_current
			WHERE card_id = @card_id
										  
			--Check that someone hasn't already updated the card
			IF(@current_card_status_id = 1 OR @current_card_status_id = 3)				
				BEGIN
					--get the vat rate which is used for this customer
					DECLARE @vat decimal(7, 4)

					SELECT @vat = vat
					FROM [product_fee_charge]
					WHERE fee_detail_id = @fee_detail_id
						AND currency_id = @currency_id
						AND card_issue_reason_id = @card_issue_reason_id


					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					SET @status_date = GETDATE()

					SELECT @branch_id = branch_id
					FROM [cards]
					WHERE card_id = @card_id

					--Update the cards status.
					INSERT branch_card_status
							(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id)
					VALUES (@card_id, @branch_id, 2, @status_date, @audit_user_id, @audit_user_id) 

					--Save customer details
					INSERT customer_account
							([user_id], card_id, card_issue_reason_id, account_type_id, customer_account_number,
								customer_first_name, customer_middle_name, customer_last_name, name_on_card, contact_number,Id_number, customer_title_id, 
								date_issued, customer_type_id, currency_id, resident_id, cms_id, contract_number, domicile_branch_id, CustomerId)
					VALUES (@audit_user_id, @card_id, @card_issue_reason_id, @account_type_id, 
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@customer_account_number)),
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@customer_first_name)),
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@customer_middle_name)), 
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@customer_last_name)), 
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@name_on_card)),
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@contact_number)),
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@id_number)) ,
							@customer_title_id, @status_date, @customer_type_id, @currency_id, @resident_id, 
							@cms_id, @contract_number, @domicile_branch_id,
							ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar,@customer_id)) )	
							
					SET @new_customer_account_id = SCOPE_IDENTITY()				
					
				

					--Update fee's for card
					UPDATE [cards]
					SET fee_waiver_YN = @fee_waiver_YN,
						fee_editable_YN = @fee_editable_YN, 
						fee_charged = @fee_charged,
						vat = @vat,
						fee_overridden_YN = @fee_overridden_YN
					WHERE card_id = @card_id

					--Update Product Fields
					INSERT INTO customer_fields (customer_account_id, product_field_id, value)
						SELECT @new_customer_account_id, pf.[key], ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CAST(pf.[value] as varbinary(max)))
						FROM @product_fields pf INNER JOIN product_fields
							ON pf.[key] = product_fields.product_field_id
						WHERE product_fields.print_field_type_id = 0 
						--and product_fields.deleted=0

					--Update Product Image Fields
					INSERT INTO customer_image_fields (customer_account_id, product_field_id, value)
						SELECT @new_customer_account_id, pf.[key], pf.[value]
						FROM @product_fields pf INNER JOIN product_fields
							ON pf.[key] = product_fields.product_field_id
						WHERE product_fields.print_field_type_id = 1  
						--and product_fields.deleted=0
					
					--Log audit stuff
					DECLARE @branchcardstatus  varchar(max),
							@Scenario  varchar(max),
							@audit_msg varchar(max),
							@cardnumber varchar(16)

					SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number))
					FROM cards 
					WHERE cards.card_id = @card_id

					SELECT  @branchcardstatus =  branch_card_statuses.branch_card_statuses_name
					FROM    branch_card_statuses 
					WHERE	branch_card_statuses.branch_card_statuses_id = 2

					SELECT  @Scenario =  card_issue_reason.[card_issuer_reason_name]
					FROM	card_issue_reason 
					WHERE	card_issue_reason.[card_issue_reason_id] = @card_issue_reason_id

					SET @audit_msg =  COALESCE(@branchcardstatus, 'UNKNWON') +  
									  ', ' + dbo.MaskString(@cardnumber, 6, 4) + 
									  ', cust id:' + COALESCE(CAST(@cms_id as varchar(max)), 'n/a') +
									  ', a/c:' + dbo.MaskString(@customer_account_number, 3, 4) + 
									  ', ' + COALESCE(@Scenario, 'UNKNWON')

					--SET @audit_msg = 'Issued card ' + dbo.MaskString(@cardnumber, 6, 4) +
					--				 ' , acc:'+ dbo.MaskString(@customer_account_number, 3, 4) + 
					--				 ', typeid :'+CAST(@customer_account_type_id as nvarchar(50))

					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
										 3,---IssueCard
										 NULL, 
										 @audit_workstation, 
										 @audit_msg, 
										 NULL, NULL, NULL, NULL

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key
					SET @ResultCode = 0					
				END
			ELSE
				BEGIN
					SET @ResultCode = 100
				END
			
				
				COMMIT TRANSACTION [ISSUE_CARD_TO_CUST_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_TO_CUST_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH

END
GO
PRINT N'Altering [dbo].[usp_update_branch]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Persist changes to the branch to the DB
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_branch] 
	@branch_id int,
	@branch_status_id int,
	@issuer_id int,
	@branch_code varchar(10),
	@branch_name varchar(30),
	@card_centre_branch_YN bit,
	@location varchar(20),
	@contact_person varchar(30),
	@contact_email varchar(30),
	@card_centre varchar(10),	
	@emp_branch_code varchar(10), 
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;	

	BEGIN TRANSACTION [UPDATE_BRANCH_TRAN]
		BEGIN TRY 

			--Check for duplicate's
			IF (SELECT COUNT(*) FROM [branch] WHERE ([branch_code] = @branch_code AND [issuer_id] = @issuer_id) AND branch_id != @branch_id) > 0
				BEGIN
					SET @ResultCode = 211						
				END
			ELSE IF (SELECT COUNT(*) FROM [branch] WHERE ([branch_name] = @branch_name AND [issuer_id] = @issuer_id) AND branch_id != @branch_id) > 0
				BEGIN
					SET @ResultCode = 210
				END
			ELSE
			BEGIN

				UPDATE [branch]
				SET [branch_status_id] = @branch_status_id,
					[issuer_id] = @issuer_id,
					[branch_code] = @branch_code,
					[branch_name] = @branch_name,
					[location] = @location,
					[contact_person] = @contact_person,
					[contact_email] = @contact_email,
					[card_centre] = @card_centre,
					[card_centre_branch_YN] = @card_centre_branch_YN,
					[emp_branch_code]=@emp_branch_code
				WHERE branch_id = @branch_id

				--log the audit record
				DECLARE @audit_description varchar(500),
						@branchstatus  varchar(50),
				        @issuer_code varchar(10)

				SELECT @issuer_code = issuer_code
				FROM issuer
				WHERE issuer_id = @issuer_id

				SELECT @branchstatus = branch_statuses.[branch_status]
				FROM branch_statuses 
				WHERE branch_statuses.branch_status_id = @branch_status_id

				SELECT @audit_description = 'Update: ID ' + CAST(@branch_id AS varchar(max)) + '; [' + CAST(@issuer_id as varchar(100)) + ',' + @issuer_code + ']; [' +
											@branch_code + ',' + @branch_name + ',' + @branchstatus + ']'

				EXEC usp_insert_audit @audit_user_id, 
									 0,--BranchAdmin
									 NULL,
									 @audit_workstation, 
									 @audit_description, 
									 @issuer_id, NULL, NULL, NULL

				SET @ResultCode  = 0				
			END

			COMMIT TRANSACTION [UPDATE_BRANCH_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_BRANCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_update_customer_details]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_customer_details] 
	@card_id bigint,
	@customer_account_id bigint,
	@branch_id int,
	@delivery_branch_id int,
	@product_id int,
	@card_priority_id int,
    @customer_account_number varchar(27),
	@domicile_branch_id int,
	@account_type_id int,
	@card_issue_reason_id int,
	@customer_first_name varchar(50),
	@customer_middle_name varchar(50),
	@customer_last_name varchar(50),
	@name_on_card varchar(30),
	@customer_title_id int,	
	@currency_id int,
	@resident_id int,
	@customer_type_id int,
	@cms_id varchar(50),
	@contract_number varchar(50),
	@customer_idnumber varchar(50),
	@contact_number varchar(50),
	@audit_user_id bigint,
	@audit_workstation varchar(100),	
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [UPDATE_CUST_TRAN]
		BEGIN TRY 

			IF @customer_middle_name IS NULL
				SET @customer_middle_name = ''
			
			DECLARE @status_date datetime,
					@branch_card_statuses_id int

			SET @branch_card_statuses_id = 2

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			--The initial card status.
			INSERT branch_card_status
					(card_id, branch_card_statuses_id, status_date, [user_id], operator_user_id)
			VALUES (@card_id, @branch_card_statuses_id, GETDATE(), @audit_user_id, @audit_user_id)
			
			UPDATE [cards]
			SET branch_id = @branch_id,
				ordering_branch_id = @branch_id,
				origin_branch_id = @branch_id,
				delivery_branch_id = @delivery_branch_id,
				product_id = @product_id,
				card_priority_id = @card_priority_id
			WHERE card_id = @card_id

			--Save customer details
			UPDATE customer_account 
			SET card_issue_reason_id = @card_issue_reason_id, 
				account_type_id = @account_type_id, 
				customer_account_number= ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_account_number)),
				customer_first_name = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_first_name)), 
				customer_middle_name = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_middle_name)), 
				customer_last_name = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_last_name)), 
				name_on_card = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@name_on_card)), 
				customer_title_id = @customer_title_id, 
				customer_type_id = @customer_type_id, 
				currency_id = @currency_id, 
				resident_id = @resident_id, 
				cms_id = @cms_id, 
				contract_number = @contract_number, 
				Id_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_idnumber)),
				contact_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@contact_number)),
				domicile_branch_id = @domicile_branch_id
			WHERE customer_account_id = @customer_account_id

			--Log audit stuff
			DECLARE @branchcardstatus  varchar(max),
					@Scenario  varchar(max),
					@audit_msg varchar(max),
					@cardnumber varchar(16)

			SELECT  @branchcardstatus =  branch_card_statuses.branch_card_statuses_name
			FROM    branch_card_statuses 
			WHERE	branch_card_statuses.branch_card_statuses_id = @branch_card_statuses_id

			SELECT  @Scenario =  card_issue_reason.[card_issuer_reason_name]
			FROM	card_issue_reason 
			WHERE	card_issue_reason.[card_issue_reason_id] = @card_issue_reason_id

			SET @audit_msg =  'card request-' + 
								COALESCE(@branchcardstatus, 'UNKNWON') +  
								', cust id:' + COALESCE(CAST(@cms_id as varchar(max)), 'n/a') +
								', a/c:' + dbo.MaskString(@customer_account_number, 3, 4) + 
								', ' + COALESCE(@Scenario, 'UNKNWON')

			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,---IssueCard
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key			
				
			COMMIT TRANSACTION [UPDATE_CUST_TRAN]
			SET @ResultCode = 0

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_CUST_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH

END
GO
PRINT N'Altering [dbo].[usp_update_fee_charge]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_fee_charge] 
	-- Add the parameters for the stored procedure here
	@fee_detail_id int, 
	@card_issue_reason_id int,
	@fee_list  as dbo.[fee_charge_array] READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100),	
	@ResultCode int = null OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

       -- Insert statements for procedure here
	BEGIN TRANSACTION [UPDATE_PRODUCT_FEE_CHARGE_TRAN]
		BEGIN TRY 			

			DELETE FROM [product_fee_charge]
			WHERE fee_detail_id = @fee_detail_id
					AND card_issue_reason_id = @card_issue_reason_id

			INSERT INTO [product_fee_charge] (fee_detail_id, card_issue_reason_id, currency_id, fee_charge, vat, date_created)
			SELECT @fee_detail_id, @card_issue_reason_id, fl.[currency_id], fl.[fee_charge], fl.[vat], GETDATE()
			FROM @fee_list fl	


			--log the audit record
			DECLARE @audit_description varchar(max), @issuer_id int, @fees varchar(max) = ''

			SELECT  @fees = STUFF(
									(SELECT ', ' + [currency].currency_code + '=' +  CONVERT(varchar(max), fee_list.[fee_charge]) + '- vat=' +  CONVERT(varchar(max), fee_list.[vat])
									 FROM @fee_list fee_list
										INNER JOIN [currency]
											ON [currency].currency_id = fee_list.[currency_id]
									 FOR XML PATH(''))
								   , 1
								   , 1
								   , '')


			SELECT @issuer_id = issuer_id
			FROM [product_fee_detail] INNER JOIN [product_fee_scheme]
				ON [product_fee_scheme].fee_scheme_id = [product_fee_detail].fee_scheme_id
			WHERE [product_fee_detail].fee_detail_id = @fee_detail_id
					

			SET @audit_description = 'Fee Charge Update: Fee Detail Id ' + CAST(@fee_detail_id AS VARCHAR(max))	
										+', Issue Reason Id :'+  CAST(@card_issue_reason_id AS VARCHAR(max)) 
										+ ', Fees: ' + COALESCE(@fees, 'NONE')
										 	
			EXEC usp_insert_audit @audit_user_id, 
									4,
									NULL, 
									@audit_workstation, 
									@audit_description, 
									@issuer_id, NULL, NULL, NULL

			SET @ResultCode = 0	

			COMMIT TRANSACTION [UPDATE_PRODUCT_FEE_CHARGE_TRAN]
			SET @ResultCode = 0
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_PRODUCT_FEE_CHARGE_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	

END
GO
PRINT N'Altering [dbo].[usp_update_fee_scheme]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_fee_scheme] 
	-- Add the parameters for the stored procedure here
	@fee_scheme_id int,
	@issuer_id int,
	@fee_accounting_id int,
	@fee_scheme_name varchar(100),
	@fee_detail_list as dbo.fee_detail_array READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [UPDATE_PRODUCT_FEE_SCHEME_TRAN]
		BEGIN TRY 			

			IF (SELECT COUNT(*) FROM [product_fee_scheme] 
					WHERE fee_scheme_name = @fee_scheme_name AND issuer_id = @issuer_id AND fee_scheme_id != @fee_scheme_id) > 0
				BEGIN
					SET @ResultCode = 226						
				END		
			ELSE IF (SELECT COUNT(*) FROM
						(SELECT fee_detail_name FROM @fee_detail_list fdl GROUP BY fdl.fee_detail_name
						HAVING COUNT(*) > 1) AS tb1) > 0
				BEGIN
					SET @ResultCode = 227
				END
			ELSE
				BEGIN
					DECLARE @effective_from DATETIME = GETDATE()


					UPDATE [product_fee_scheme]
					SET fee_scheme_name = @fee_scheme_name
						, fee_accounting_id = @fee_accounting_id
					WHERE fee_scheme_id = @fee_scheme_id	
			
					--DELETE DELATAILS AND LINKED CHARGES FOR THOSE NO LONGER IN THE LIST
					DELETE FROM [product_fee_charge]
					WHERE fee_detail_id IN (
						SELECT fee_detail_id
						FROM [product_fee_detail]
						WHERE fee_scheme_id = @fee_scheme_id 
							AND fee_detail_id NOT IN (SELECT dl.fee_detail_id FROM @fee_detail_list dl WHERE dl.fee_detail_id > 0)
					)

					DELETE FROM [product_fee_detail]
					WHERE fee_scheme_id = @fee_scheme_id
							AND fee_detail_id NOT IN (SELECT dl.fee_detail_id FROM @fee_detail_list dl WHERE dl.fee_detail_id > 0)

					--UPDATE THOSE WITH VALID ID"S
					UPDATE [product_fee_detail]
					SET fee_detail_name = dl.fee_detail_name, 
						fee_editable_YN = dl.fee_editable_TN, 
						fee_waiver_YN = dl.fee_waiver_YN
					FROM [product_fee_detail]
							INNER JOIN @fee_detail_list dl
								ON [product_fee_detail].fee_detail_id = dl.fee_detail_id
					WHERE [product_fee_detail].fee_scheme_id = @fee_scheme_id
							AND dl.fee_detail_id > 0

					--INSERT ANY NEW DETAILS
					INSERT INTO [product_fee_detail] (fee_scheme_id, fee_detail_name, fee_editable_YN, fee_waiver_YN, 
														effective_from, effective_to, deleted_yn)
					SELECT @fee_scheme_id, dl.fee_detail_name, dl.fee_editable_TN, dl.fee_waiver_YN, 
							@effective_from, null, 0
					FROM @fee_detail_list dl
					WHERE dl.fee_detail_id < 0

					--log the audit record
					DECLARE @audit_description varchar(max), @fee_details varchar(max)

					SELECT  @fee_details = STUFF(
									(SELECT ' Fee Band Name: ' + dl.fee_detail_name + ', editable: ' +  CAST(dl.fee_editable_TN AS VARCHAR(MAX)) 
										+ ', waiver: ' +  CAST(dl.fee_waiver_YN AS VARCHAR(MAX)) + ';' 
									 FROM @fee_detail_list dl
									 FOR XML PATH(''))
								   , 1
								   , 1
								   , '')
					

					SET @audit_description = 'Fee Scheme Update: ' + @fee_scheme_name
												+' , Fee Scheme Id :'+  CAST(@fee_scheme_id AS VARCHAR(max)) 
												+' , Fee Bands : ' + COALESCE(@fee_details, 'NONE')
										 	
					EXEC usp_insert_audit @audit_user_id, 
											4,
											NULL, 
											@audit_workstation, 
											@audit_description, 
											@issuer_id, NULL, NULL, NULL
										
					SET @ResultCode = 0
			END

			COMMIT TRANSACTION [UPDATE_PRODUCT_FEE_SCHEME_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_PRODUCT_FEE_SCHEME_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_update_terminal]...';


GO
-- =============================================
-- Author:		LTladi
-- Create date: 20150130
-- Description:	Update the terminal information
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_terminal]
	@terminal_id int
	, @terminal_name varchar(250)
	, @terminal_model varchar(250)
	, @device_id varchar(max)
	, @branch_id int
	, @terminal_masterkey_id int
	,@password   varchar(max)
	,@IsMacUsed bit
	, @audit_user_id bigint
	, @audit_workstation varchar(100)
	, @ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
		OPEN Symmetric Key Indigo_Symmetric_Key
			DECRYPTION BY Certificate Indigo_Certificate;
	BEGIN TRANSACTION [UPDATE_TERMINAL_TRAN]
		BEGIN TRY 

			--Check for duplicate's
			IF (SELECT COUNT(*) FROM [terminals] WHERE ([terminals].[terminal_name] = @terminal_name AND [terminals].[terminal_id] != @terminal_id)) > 0
				BEGIN					
					SET @ResultCode = 604						
				END
			ELSE IF (SELECT COUNT(*) FROM [terminals] WHERE (CONVERT(VARCHAR(max),DECRYPTBYKEY([terminals].[device_id]))  = @device_id AND [terminals].[terminal_id] != @terminal_id)) > 0
				BEGIN
					SET @ResultCode = 605
				END
			ELSE			
			BEGIN
			
		

				UPDATE [dbo].[terminals]
				   SET [terminal_name] = @terminal_name
					  ,[terminal_model] = @terminal_model
					  ,[device_id] = CONVERT(varbinary(max),ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@device_id)))
					  ,[branch_id] = @branch_id
					  ,[terminal_masterkey_id] = @terminal_masterkey_id
					  ,[workstation] = @audit_workstation
					  ,[date_changed] = GETDATE()
					  ,[password]=CONVERT(varbinary(max),ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@password)))
						,IsMacUsed=@IsMacUsed
				 WHERE [terminal_id] = @terminal_id
				 SET @ResultCode = 0
			

				--log the audit record
				DECLARE @audit_description varchar(max), @issuer_id int, @audit_branch_name varchar(max), 
						@audit_branch_code varchar(max)

				SELECT @issuer_id = issuer_id, @audit_branch_name = branch_name,
						@audit_branch_code = branch_code
				FROM [branch]
				WHERE branch_id = @branch_id

				SET @audit_description = 'Terminal Updated: '+ COALESCE(@terminal_name, 'UNKNOWN') 
										  + ' , Terminal Id: ' + CAST(@terminal_id as varchar(max))
										  + ' , branch code: ' + @audit_branch_code
										  + ' , branch name: ' + @audit_branch_name		

				EXEC usp_insert_audit @audit_user_id, 
									 9,
									 NULL, 
									 @audit_workstation, 
									 @audit_description, 
									 @issuer_id, NULL, NULL, NULL
					
			END

			COMMIT TRANSACTION [UPDATE_TERMINAL_TRAN]
				
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_TERMINAL_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
	CLOSE Symmetric Key Indigo_Symmetric_Key;	
END
GO
PRINT N'Altering [dbo].[usp_update_user_group]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Updates user group
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_user_group] 
	@user_group_id int,
	@user_group_name varchar(50),
	@user_role_id int,
	@can_read bit,
	@can_create bit,
	@can_update bit,
	@mask_screen_pan bit = 1,
	@mask_report_pan bit = 1,
	@issuer_id int,
	@all_branch_access bit,
	@branch_list AS dbo.branch_id_array READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
AS
BEGIN

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	Declare @checkoutcards int
	select @checkoutcards=count(cards.card_id) from cards
						INNER JOIN [branch_card_status_current]
						ON [cards].card_id = [branch_card_status_current].card_id
						 where  [cards].branch_id  in (select [user_groups_branches].branch_id
													FROM [user_groups_branches] 
													where 	[user_groups_branches].user_group_id=@user_group_id)
							and  [branch_card_status_current].branch_card_statuses_id =1
							and   [cards].card_issue_method_id =1
	

			--Check for duplicate's
	if (@checkoutcards>0)
		BEGIN
			SET @ResultCode = 803						
		END
	IF (SELECT COUNT(*) FROM [user_group] WHERE ([user_group_name] = @user_group_name AND [issuer_id] = @issuer_id) AND user_group_id != @user_group_id) > 0
		BEGIN
			SET @ResultCode = 215						
		END
	ELSE
		BEGIN
			BEGIN TRANSACTION [UPDATE_USER_GROUP_TRAN]
			BEGIN TRY 

		DECLARE @RC int
		UPDATE [user_group]
        SET [user_role_id] = @user_role_id, 
			[issuer_id] = @issuer_id, 
			[can_create] = @can_create, 
			[can_read] = @can_read, 
			[can_update] = @can_update, 
			[mask_screen_pan] = @mask_screen_pan,
			[mask_report_pan] = @mask_report_pan,
			[can_delete] = 0,
            [all_branch_access] = @all_branch_access, 
			[user_group_name] = @user_group_name
		WHERE user_group_id = @user_group_id

		--Delete any linked branches so they may be inserted in the next step.
		DELETE FROM [user_groups_branches]
		WHERE user_group_id = @user_group_id

		--Link branches to user group
		EXECUTE @RC = [usp_insert_user_group_branches] @user_group_id, @branch_list, @audit_user_id, @audit_workstation
		

		--Insert audit
		DECLARE @branches varchar(max),
				@user_role_name varchar(50),
				@issuer_code varchar(10)

		IF (@all_branch_access = 0)
			BEGIN
				SELECT  @branches = STUFF(
									(SELECT ', ' +b.[branch_code] + ';' + cast(b.[branch_id] as varchar(max)) 
									 FROM user_groups_branches ug
										INNER JOIN [branch] b 
											ON ug.[branch_id] = b.[branch_id]
										WHERE ug.user_group_id = @user_group_id
										FOR XML PATH(''))
								   , 1
								   , 1
								   , '')
			END
		ELSE
			BEGIN
				SELECT  @branches = STUFF(
									(SELECT ', ' + [branch_code] + ';' + cast([branch_id] as varchar(max))
									 FROM [branch]
									 WHERE issuer_id = @issuer_id
									 FOR XML PATH(''))
								   , 1
								   , 1
								   , '')
			END

		SELECT @user_role_name = user_role
		FROM [user_roles]
		WHERE @user_role_id = @user_role_id

		SELECT @issuer_code = issuer_code
		FROM [issuer]
		WHERE issuer_id = @issuer_id

		DECLARE @audit_description varchar(max)
		SET @audit_description = 'Update: ' + COALESCE(@user_group_name, 'UNKNOWN') +
								 ', iss:' + COALESCE(@issuer_code, 'UNKNOWN') + ';' + COALESCE(CAST(@issuer_id as varchar(max)), 'UNKNOWN') + 
								 ', read: ' + COALESCE(CAST(@can_read as varchar(1)), 'UNKNOWN') + 
								 ', create: ' + COALESCE(CAST(@can_create as varchar(1)), 'UNKNOWN') +
								 ', update: ' + COALESCE(CAST(@can_update as varchar(1)), 'UNKNOWN') +
								 ', branches: ' + COALESCE(@branches, 'UNKNOWN')

		EXEC usp_insert_audit @audit_user_id, 
							 8,----UserGroupAdmin
							 NULL, 
							 @audit_workstation, 
							 @audit_description, 
							 @issuer_id, NULL, NULL, NULL

		SET @ResultCode = 0
		COMMIT TRANSACTION [UPDATE_USER_GROUP_TRAN]

	END TRY
		BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_USER_GROUP_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
	END
END
GO
PRINT N'Altering [dbo].[usp_get_issuedcardsreport]...';


GO
-- =============================================
-- Author:		sandhya konduru
-- Create date: 16/05/2014
-- Description:	for displaying issued card report
-- =============================================
----exec usp_get_issuedcardsreport 2,'6/14/2014 12:00:00 AM','6/27/2014 12:00:00 AM' ,25,null
ALTER PROCEDURE [dbo].[usp_get_issuedcardsreport]
	@isuerid int,
	@fromdate datetime,
	@todate datetime,
	@userid int = null,
	@branchid int=null,
	@language_id int = null
	,@audit_user_id bigint
	,@audit_workstation varchar(100)

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	if(@userid=0)
	set @userid=null

	if(@isuerid=0)
	set @isuerid=null

	SET @todate = DATEADD(d, 1, @todate)
 -- Insert statements for procedure here
	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

		DECLARE @APPROVER TABLE (username VARCHAR(100),
                           card_id int)
		INSERT  INTO @APPROVER (username, card_id)
		SELECT CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].username)) as 'username' , card_id
					FROM [branch_card_status]
						INNER JOIN [user] 
							ON [user].[user_id] = [branch_card_status].[user_id]
					WHERE
						[branch_card_status].[branch_card_statuses_id] = 3

   
		
	SELECT 
		branch.branch_code+'-'+ branch.branch_name as 'BranchCode'
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([operator].[username])) as 'IssuedBy'
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY(customer_account.customer_first_name))+' '+ CONVERT(VARCHAR(MAX),DECRYPTBYKEY(customer_account.customer_last_name)) as 'CustomerNames'
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY(customer_account.[customer_account_number])) as 'customeraccountNumber'
		, CASE 
			WHEN @mask_report = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
			ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
		  END AS 'card_number'
		, [operator].[user_id] as original_operator_user_id
		, [branch_card_status_current].[user_id]
		, cards.card_request_reference AS card_reference_number
		, [branch_card_statuses_name] as 'CardStatus'
		, [status_date] as'IssuedDate'
		, ap.username as 'APPROVER USER'
		, language_text as 'Scenario'
		, [Cards].fee_charged as 'fee_Charged'
	FROM 
		[branch_card_status_current]
			INNER JOIN [cards] 
				ON [branch_card_status_current].card_id = [cards].card_id
			INNER JOIN [branch] 
				ON [cards].branch_id = [branch].branch_id
			INNER JOIN [customer_account] ON 
				[cards].card_id = [customer_account].card_id
			INNER JOIN [user] as [operator]
				ON [operator].[user_id] = [customer_account].[user_id]
			INNER JOIN [branch_card_statuses] 
				ON [branch_card_statuses].branch_card_statuses_id = [branch_card_status_current].branch_card_statuses_id
			INNER JOIN [card_issue_reason_language] 
				ON [card_issue_reason_language].card_issue_reason_id = [customer_account].card_issue_reason_id
			INNER JOIN [issuer] 
				ON [issuer].issuer_id = branch.issuer_id
				left join  @APPROVER as ap
				ON ap.card_id = [cards].card_id		
	 WHERE
		[branch_card_status_current].branch_card_statuses_id = 6 	
		AND [branch].issuer_id = COALESCE(@isuerid, [branch].issuer_id)
		--Match on both the original operator or the final person to have issued the card
		AND ([operator].[user_id] = COALESCE(@userid, [operator].[user_id]) OR
			  [branch_card_status_current].[user_id] = COALESCE(@userid, [branch_card_status_current].[user_id]))
	    AND [cards].branch_id = COALESCE(@branchid, [cards].branch_id) 
		AND [card_issue_reason_language].language_id = @language_id 
		AND [branch_card_status_current].status_date >= @fromdate 
		AND [branch_card_status_current].status_date <= @todate
	 ORDER BY
		CardStatus

	 CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

END
GO
PRINT N'Altering [dbo].[usp_card_dispatch_report]...';


GO
--exec [usp_card_dispatch_report] 2,null,'8/4/2015','11/4/2015',-1,'TEST'
ALTER PROCEDURE [dbo].[usp_card_dispatch_report] 
	-- Add the parameters for the stored procedure here
	 @issuer_id int = NULL
	,@branch_id int = NULL
	,@date_from datetime
	,@date_to datetime
	,@audit_user_id bigint
	,@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	if(@issuer_id='' or @issuer_id=0)
	set @issuer_id=null

		if(@branch_id='' or @branch_id=0)
	set @branch_id=null

	SET @date_to = DATEADD(d, 1, @date_to)

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

    OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT 
		DISTINCT CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_first_name)) AS customer_first_name
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_middle_name)) AS customer_middle_name
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_last_name)) AS customer_last_name
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_account_number)) AS customer_account_number
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].name_on_card)) AS name_on_card
		, CASE 
			WHEN @mask_report = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
			ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
		  END AS 'card_number'	
		  --, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))	 
		, cards.card_request_reference AS card_reference_number
		, [dist_batch].dist_batch_reference, [dist_batch].date_created
		, [issuer].issuer_name
		, [issuer].issuer_code
		, [branch].branch_name
		, branch.branch_code
	FROM 
		[cards]
		INNER JOIN [branch]
			ON [cards].branch_id = [branch].branch_id
		INNER JOIN [issuer]
			ON [branch].issuer_id = [issuer].issuer_id
		INNER JOIN [customer_account]
			ON [cards].card_id = [customer_account].card_id
		INNER JOIN [dist_batch_cards]
			ON [cards].card_id = [dist_batch_cards].card_id
		INNER JOIN [dist_batch]
			ON [dist_batch_cards].dist_batch_id = [dist_batch].dist_batch_id
				AND [dist_batch].dist_batch_type_id = 1
		INNER JOIN [dist_batch_status_current]
			ON [dist_batch].dist_batch_id = [dist_batch_status_current].dist_batch_id
				AND( [dist_batch_status_current].dist_batch_statuses_id = 2	or 
					[dist_batch_status_current].dist_batch_statuses_id = 19)		
			
	WHERE 
	[cards].card_issue_method_id = 0	 
		 AND [issuer].issuer_id = COALESCE(@issuer_id, [issuer].issuer_id)
		AND [branch].branch_id = COALESCE(@branch_id, [branch].branch_id)
		AND [dist_batch].date_created >= @date_from
		AND [dist_batch].date_created <= @date_to
	ORDER BY
		issuer_name
		, issuer_code
		, branch_name
		, branch_code
		, date_created
		, customer_account_number
		, customer_first_name
		, customer_last_name

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_card_expiry_report]...';


GO
--exec [usp_card_expiry_report] 1,NULL,'2014/11/04',-1,'test'
ALTER PROCEDURE [dbo].[usp_card_expiry_report] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = NULL,
	@branch_id int = NULL,
	@date_from datetime,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	--SET @date_from = DATEADD(M, 1, @date_from)
	set @date_from = convert(datetime, @date_from, 126)

	

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

    OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

		SELECT 
			DISTINCT  
			CASE 
				WHEN @mask_report = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
				ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
			END AS 'card_number'
			, cards.card_request_reference AS card_reference_number
			, CONVERT(DATETIME, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_expiry_date))) AS card_expiry_date
			, [issuer].issuer_name
			, [issuer].issuer_code
			, [branch].branch_name
			, branch.branch_code
		FROM [cards]								
				INNER JOIN [branch]
					ON [cards].branch_id = [branch].branch_id
				INNER JOIN [issuer]
					ON [branch].issuer_id = [issuer].issuer_id	
		WHERE [cards].card_issue_method_id = 0
				AND [issuer].issuer_id = COALESCE(@issuer_id, [issuer].issuer_id)
				AND [branch].branch_id = COALESCE(@branch_id, [branch].branch_id)
				AND DATEPART(m, CONVERT(DATETIME, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_expiry_date)))) = DATEPART(m, @date_from)
				AND DATEPART(yy, CONVERT(DATETIME, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_expiry_date)))) = DATEPART(yy, @date_from)
		ORDER BY issuer_name, issuer_code, branch_name, branch_code, card_expiry_date

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_card_production_report]...';


GO
--exec [usp_card_production_report] null,
ALTER PROCEDURE [dbo].[usp_card_production_report] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = NULL,
	@branch_id int = NULL,
	@date_from datetime,
	@date_to datetime,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	if(@branch_id='')
	set @branch_id=null

	SET @date_to = DATEADD(d, 1, @date_to)

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

    OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

		SELECT DISTINCT
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_first_name)) AS customer_first_name
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_middle_name)) AS customer_middle_name
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_last_name)) AS customer_last_name
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_account_number)) AS customer_account_number
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].name_on_card)) AS name_on_card
			, CASE 
				WHEN @mask_report = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
				ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
			  END AS 'card_number'
			, cards.card_request_reference AS card_reference_number
			, [dist_batch].dist_batch_reference
			, [dist_batch].date_created
			, [issuer].issuer_name
			, [issuer].issuer_code
			, [branch].branch_name
			, branch.branch_code
		FROM [cards]
			INNER JOIN [customer_account]
				ON [cards].card_id = [customer_account].card_id
			INNER JOIN [dist_batch_cards]
				ON [cards].card_id = [dist_batch_cards].card_id
			INNER JOIN [dist_batch]
				ON [dist_batch_cards].dist_batch_id = [dist_batch].dist_batch_id
					AND [dist_batch].dist_batch_type_id = 0
			INNER JOIN [dist_batch_status]
				ON [dist_batch].dist_batch_id = [dist_batch_status].dist_batch_id
					AND [dist_batch_status].dist_batch_statuses_id = 13						
			INNER JOIN [branch]
				ON [cards].branch_id = [branch].branch_id
			INNER JOIN [issuer]
				ON [branch].issuer_id = [issuer].issuer_id	
		WHERE [cards].card_issue_method_id = 0
			AND [issuer].issuer_id = COALESCE(@issuer_id, [issuer].issuer_id)
			AND [branch].branch_id = COALESCE(@branch_id, [branch].branch_id)
			AND [dist_batch].date_created >= @date_from
			AND [dist_batch].date_created <= @date_to
		ORDER BY 
			issuer_name
			, issuer_code
			, branch_name
			, branch_code
			, date_created
			, customer_account_number
			, customer_first_name
			, customer_last_name

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_pinreissue_report]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_pinreissue_report]
	@isuerid int,
	@fromdate datetime,
	@todate datetime,
	@userid int = null,
	@branchid int=null,
	@language_id int = null,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	if(@userid=0)
	set @userid=null

	if(@isuerid=0)
	set @isuerid=null

	
	if(@branchid=0)
	set @branchid=null

	SET @todate = DATEADD(d, 1, @todate)

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

    -- Insert statements for procedure here
	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

		 SELECT branch.branch_code+'-'+branch.branch_name as 'branchcode', 
			issuer.issuer_code+'-'+	issuer.issuer_name as 'issuer_name', 
				pin_reissue.pan, 
				CONVERT(VARCHAR,DECRYPTBYKEY([user].username)) as 'IssuedBy',  
				CONVERT(VARCHAR,DECRYPTBYKEY(apporved.username)) as 'APPROVER_USER', 
				CASE 
					WHEN pin_reissue_status_current.pin_reissue_statuses_id = 2 
					THEN pin_reissue_status_current.status_date 
					ELSE pin_reissue.reissue_date 
				END AS 'approveddate',
				CASE 
					WHEN @mask_report = 1 
					THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY(pin_reissue.pan)),6,4) 
					ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY(pin_reissue.pan))
				END AS 'cardnumber', 
				'pin re-issue' as Reason,
				pin_reissue.reissue_date as 'ReIssuedDate'
			FROM pin_reissue 
					LEFT JOIN pin_reissue_status_current 
						ON pin_reissue.pin_reissue_id = pin_reissue_status_current.pin_reissue_id
                    INNER JOIN  branch 
						ON pin_reissue.branch_id = branch.branch_id 
					INNER JOIN issuer 
						ON pin_reissue.issuer_id = issuer.issuer_id 
					INNER JOIN [user] 
						ON pin_reissue.operator_user_id = [user].[user_id] 
					LEFT JOIN [user] as apporved 
						ON pin_reissue.authorise_user_id = apporved.[user_id] 
			WHERE 
				issuer.issuer_id=COALESCE(@isuerid, issuer.issuer_id)AND
				branch.branch_id = COALESCE(@branchid, branch.branch_id)
				AND pin_reissue.reissue_date >= @fromdate 
				AND pin_reissue.reissue_date <= @todate 
				AND pin_reissue_status_current.pin_reissue_statuses_id=1

   CLOSE SYMMETRIC KEY Indigo_Symmetric_Key


END
GO
PRINT N'Altering [dbo].[usp_search_pin_reissue]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_search_pin_reissue]
	-- Add the parameters for the stored procedure here
	@issuer_id int = null,
	@branch_id int = null,
	@user_role_id int = null,
	@pin_reissue_statuses_id int = null,
	@operator_user_id bigint = null,
	@operator_in_progress bit,
	@authorise_user_id bigint = null,
	@date_from DATETIME = NULL,
	@date_to DATETIME = NULL,
	@language_id int,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--Clean up any old requests that may have expired
	INSERT INTO [pin_reissue_status] (pin_reissue_statuses_id, pin_reissue_id, status_date, comments, [user_id], audit_workstation)
	SELECT 4, [pin_reissue].pin_reissue_id, GETDATE(), 'Expired', -2, 'SYSTEM'
	FROM [pin_reissue]
			INNER JOIN [pin_reissue_status_current]
		ON [pin_reissue_status_current].pin_reissue_id = [pin_reissue].pin_reissue_id
	WHERE [pin_reissue].request_expiry <= GETDATE()
		AND [pin_reissue_status_current].pin_reissue_statuses_id NOT IN ( 2, 3, 4)	


	--DECLARE @pin_reissue_statuses table(pin_reissue_statuses_id int); 

	----Check if we're doing operator cards
	--IF(@operator_in_progress = 1)
		
	--ELSE


	DECLARE @mask_screen bit = [dbo].MaskScreenPAN(@audit_user_id)

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

    DECLARE @StartRow INT, @EndRow INT;			

			SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
			SET @EndRow = @StartRow + @RowsPerPage - 1;

			--append#1
			WITH PAGE_ROWS
			AS
			(
			SELECT ROW_NUMBER() OVER(ORDER BY status_date DESC) AS ROW_NO
					, COUNT(*) OVER() AS TOTAL_ROWS
					, *
			FROM( 
				SELECT [pin_reissue].*,
						CASE 
							WHEN @mask_screen = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([pin_reissue].pan)),6,4) 
							ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([pin_reissue].pan))
						END AS 'card_number',
						[pin_reissue_status_current].pin_reissue_statuses_id,
						[pin_reissue_status_current].status_date,
						[pin_reissue_status_current].[user_id],
						[pin_reissue_status_current].comments,
						CONVERT(VARCHAR(max),DECRYPTBYKEY([user].username)) as operator_usename,
						CONVERT(VARCHAR(max),DECRYPTBYKEY([authoriser].username)) as authorise_username,
						[pin_reissue_statuses_language].language_text as pin_reissue_statuses_name,
						[user_branch_access].issuer_name,
						[user_branch_access].issuer_code,
						[user_branch_access].branch_name,
						[user_branch_access].branch_code,
						[user_branch_access].authorise_pin_reissue_YN,
						[issuer_product].product_code, [issuer_product].product_name
				FROM [pin_reissue]
					INNER JOIN [pin_reissue_status_current]
						ON [pin_reissue].pin_reissue_id = [pin_reissue_status_current].pin_reissue_id
					INNER JOIN [pin_reissue_statuses_language]
						ON [pin_reissue_status_current].pin_reissue_statuses_id = [pin_reissue_statuses_language].pin_reissue_statuses_id
							AND [pin_reissue_statuses_language].language_id = @language_id
					INNER JOIN [user]
						ON [user].[user_id] = [pin_reissue].operator_user_id
					INNER JOIN [issuer_product]
						ON [issuer_product].product_id = [pin_reissue].product_id
					--Filter out cards linked to branches the user doesnt have access to.
					INNER JOIN (SELECT DISTINCT [user_roles_branch].branch_id, [branch].branch_code, [branch].branch_name, [branch].issuer_id
												,[issuer].issuer_name, [issuer].issuer_code, authorise_pin_reissue_YN							
								FROM [user_roles_branch] 
									INNER JOIN [user_roles]
										ON [user_roles_branch].user_role_id = [user_roles].user_role_id											
									INNER JOIN [branch]
										ON [user_roles_branch].branch_id = [branch].branch_id	
											AND [branch].branch_status_id = 0
									INNER JOIN [issuer]
										ON [branch].issuer_id = [issuer].issuer_id
											AND [issuer].issuer_status_id = 0
											AND [issuer].enable_instant_pin_YN = 1
								WHERE [user_roles_branch].[user_id] = @audit_user_id		
										AND [user_roles_branch].issuer_id = COALESCE(@issuer_id, [user_roles_branch].issuer_id)								
										AND [user_roles_branch].branch_id = COALESCE(@branch_id, [user_roles_branch].branch_id)										
										AND [user_roles_branch].user_role_id = COALESCE(@user_role_id, [user_roles_branch].user_role_id)
										AND [user_roles].user_role_id IN (1,2,7)--Only want roles that allowed to search cards
								) as [user_branch_access]
						ON [pin_reissue].branch_id = [user_branch_access].branch_id
						LEFT OUTER JOIN [user] as [authoriser]
							ON [authoriser].[user_id] = [pin_reissue].authorise_user_id
				WHERE 
					((@operator_in_progress = 1 AND (([user_branch_access].authorise_pin_reissue_YN = 0 AND  [pin_reissue_status_current].pin_reissue_statuses_id = 0)
												OR ([user_branch_access].authorise_pin_reissue_YN = 1 AND  [pin_reissue_status_current].pin_reissue_statuses_id = 1))) OR
					 (@operator_in_progress = 0 AND [pin_reissue_status_current].pin_reissue_statuses_id = COALESCE(@pin_reissue_statuses_id, [pin_reissue_status_current].pin_reissue_statuses_id)))
					 
					AND [pin_reissue].operator_user_id = COALESCE(@operator_user_id, [pin_reissue].operator_user_id)
					--AND [pin_reissue].authorise_user_id = COALESCE(@authorise_user_id, [pin_reissue].authorise_user_id)
					AND [pin_reissue_status_current].status_date BETWEEN COALESCE(@date_from, [pin_reissue_status_current].status_date) AND COALESCE(@date_to, [pin_reissue_status_current].status_date)

			) AS Src )
			SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
				,*
			FROM PAGE_ROWS
			WHERE ROW_NO BETWEEN @StartRow AND @EndRow
			--ORDER BY status_date DESC

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_spoilcardsreport]...';


GO
-- =============================================
-- Author:		sandhya konduru
-- Create date: 16/05/2014
-- Description:	for displaying issued card report
-- =============================================
----exec usp_get_issuedcardsreport 2,'6/14/2014 12:00:00 AM','6/27/2014 12:00:00 AM' ,25,null
ALTER PROCEDURE [dbo].[usp_get_spoilcardsreport]
	@isuerid int = null,
	@language_id int,
	@userid int = null,
	@branchid int = null,
	@fromdate datetime,
	@todate datetime,
	@audit_user_id BIGINT,
	@audit_workstation VARCHAR(100)

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	if(@userid = 0)
		set @userid = null

	if(@isuerid = 0)
		set @isuerid=null

	if(@branchid = 0)
		set @branchid = null

		SET @todate = DATEADD(d, 1, @todate)

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

    -- Insert statements for procedure here
	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;
		
		SELECT 
			DISTINCT branch.branch_name+'-'+ branch_code  as 'BranchCode'
			, CONVERT(VARCHAR,DECRYPTBYKEY(u.[username])) as 'SpoliedBy'
			,'' as 'IssuedBy'
			, CONVERT(VARCHAR,DECRYPTBYKEY(customer_account.customer_first_name))+' '+ CONVERT(VARCHAR,DECRYPTBYKEY(customer_account.customer_last_name)) as 'CustomerNames'
			, CONVERT(VARCHAR,DECRYPTBYKEY(customer_account.[customer_account_number])) as 'customeraccountNumber'
			,CASE 
				WHEN @mask_report = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
				ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
			END AS 'cardnumber'
			, cards.card_request_reference AS cardreferencnumber
			, [branch_card_statuses_name] as 'CardStatus'
			, [status_date] as'IssuedDate'
			, bcl.[language_text] as 'Reason'
		FROM branch_card_status_current
				INNER JOIN cards  
					ON branch_card_status_current.[card_id] = cards.[card_id]
				INNER JOIN branch 
					ON cards.[branch_id] = branch.[branch_id]
				INNER JOIN issuer 
					ON issuer.issuer_id = branch.issuer_id
				LEFT JOIN customer_account 
					ON cards.card_id = customer_account.card_id 
				INNER JOIN [user] u 
					ON u.[user_id] = branch_card_status_current.[user_id]
				INNER JOIN branch_card_statuses bs 
					ON bs.[branch_card_statuses_id] = branch_card_status_current.[branch_card_statuses_id] 
				INNER JOIN [branch_card_codes_language] bcl 
					ON branch_card_status_current.[branch_card_code_id] = bcl.[branch_card_code_id]
		  --left join (SELECT CONVERT(VARCHAR,DECRYPTBYKEY([user].username))as 'username' , card_id
		  --FROM branch_card_status 
		  --inner join [user] on [user].user_id=branch_card_status.user_id
		  --where branch_card_status.[branch_card_statuses_id]  = 6) AS Issued
		  --ON [cards].card_id = Issued.card_id
				left JOIN 
				(SELECT [branch_card_status].operator_user_id, [branch_card_status].card_id
				 FROM [branch_card_status]
				 WHERE [branch_card_status].branch_card_statuses_id = 2) AS Operator
					ON Operator.card_id = cards.[card_id]

		WHERE branch.issuer_id = COALESCE(@isuerid, branch.issuer_id)
				AND Operator.operator_user_id = COALESCE(@userid, Operator.operator_user_id)
				AND branch.branch_id = COALESCE(@branchid, branch.branch_id)
				AND branch_card_status_current.branch_card_statuses_id = 7  
				AND bcl.[language_id]=@language_id
				AND branch_card_status_current.[status_date] >= @fromdate 
				AND branch_card_status_current.[status_date] <= @todate 
				AND is_exception = 1
			  --ISNULL(branch.issuer_id, null) = ISNULL(@isuerid, ISNULL(branch.issuer_id, null)) and
		  --branch_card_status_current.branch_card_statuses_id = 7  and   bcl.[language_id]=@language_id
		  --and ISNULL(u.[user_id],null)=ISNULL(@userid, ISNULL(u.[user_id], null))

		  --and ISNULL(branch.branch_id, null)=ISNULL(@branchid, ISNULL(branch.branch_id, null))

		 --and branch_card_status_current.[status_date] >=@fromdate and branch_card_status_current.[status_date]<=@todate 
		--						   and  is_exception = 1
		ORDER BY CardStatus
	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

END
GO
PRINT N'Altering [dbo].[usp_get_branchcardstock_report]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec [usp_get_branchcardstock_report] null,18,0,2,'veneka'

ALTER PROCEDURE [dbo].[usp_get_branchcardstock_report]
	@branch_id int = null,
	@issuer_id int = null,
	@language_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
	WITH RECOMPILE
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	if(@issuer_id = -1 or @issuer_id = 0)
	 set @issuer_id=null

	if(@branch_id  =0)
		set @branch_id = null

	DECLARE @mask_report bit = [dbo].MaskReportPAN(@audit_user_id)

    -- Insert statements for procedure here
	 OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT distinct 
		[branch].branch_id,branch.branch_code
		,CASE 
			WHEN @mask_report = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
			ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
		  END AS 'card_number'
		  ,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
		, [cards].card_request_reference as 'card_request_reference'
		--, Convert(datetime, CONVERT(varchar(max),DECRYPTBYKEY([cards].card_expiry_date))) as 'card_expiry_date'
		,CONVERT(varchar(max),DECRYPTBYKEY([cards].card_expiry_date)) as 'card_expiry_date'
		, Convert(datetime, [dist_batch].date_created,103) as'card_production_date'
	FROM 
		branch_card_status_current
		INNER JOIN [cards] 
			ON branch_card_status_current.card_id = [cards].card_id
		INNER JOIN [dist_batch_cards]
			ON [cards].card_id = [dist_batch_cards].card_id
		INNER JOIN [dist_batch]
			ON [dist_batch_cards].dist_batch_id = [dist_batch].dist_batch_id
					AND [dist_batch].dist_batch_type_id = 0
		INNER JOIN [branch] 
			ON [cards].branch_id = [branch].branch_id
				AND [branch].card_centre_branch_YN = 0
		INNER JOIN [issuer] 
			ON issuer.issuer_id = branch.issuer_id
	WHERE
		(branch_card_status_current.branch_card_statuses_id = 1 
			OR branch_card_status_current.branch_card_statuses_id = 0)
		AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
		AND [branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)	
	ORDER BY
		[branch].branch_id
		
			
	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_card]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Get card info
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_card] 
	@card_id BIGINT,
	@check_masking BIT,
	@language_id INT,
	@audit_user_id BIGINT,
	@audit_workstation VARCHAR(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [GET_CARD_DETAILS_TRAN]
		BEGIN TRY 

			DECLARE @mask_screen bit = [dbo].MaskScreenPAN(@audit_user_id)

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

			--@check_masking = This proc is used by some backend process that require a clear mask and therefore 
			-- overrides the @mask_screen checking.

				SELECT distinct 
						[cards].card_id
					   , CASE @check_masking
							WHEN 1 THEN 
								CASE 
									WHEN @mask_screen = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
									ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
								END
							ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
						 END AS 'card_number'
					   , CASE @check_masking
							WHEN 1 THEN CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].pvv)) ELSE ''
							END as pvv							
					   , [cards].card_request_reference
					   , [cards].card_priority_id
					   , [card_priority_language].language_text AS 'card_priority_name'
					   , [cards].card_issue_method_id
					   , [card_issue_method_language].language_text AS 'card_issue_method_name'
					   , [cards].fee_charged
					   , [cards].vat
					   , [cards].vat_charged
					   , [cards].total_charged
					   , [cards].fee_waiver_YN
					   , [cards].fee_editable_YN
					   , [cards].fee_overridden_YN
					   , [cards].fee_reference_number
					   , [cards].fee_reversal_ref_number
					   , CAST(0 as bit) AS pin_selected

					   , [cards].product_id
					   , [issuer].issuer_name, [issuer].issuer_code, [issuer].issuer_id
					   , [issuer].instant_card_issue_YN 
					   , [issuer].maker_checker_YN, [issuer].enable_instant_pin_YN as enable_instant_pin_YN_issuer
					   , [issuer].back_office_pin_auth_YN, [issuer].authorise_pin_issue_YN
					   , [issuer].card_ref_preference
					   , [issuer].language_id
					   , [country].country_id
					   , [country].country_code
					   , [country].country_name
					   , [country].country_capital_city
					   , [branch].branch_name, [branch].branch_code, [branch].branch_id
					   , [load_card_statuses].load_card_status			   					   
					   , [load_batch].load_batch_reference

					   , [issuer_product].product_name
					   , [issuer_product].product_code
					   , [issuer_product].product_bin_code
					   , [issuer_product].sub_product_code
					   , [issuer_product].Name_on_card_font_size
					   , [issuer_product].name_on_card_left
					   , [issuer_product].name_on_card_top
					   , [Issuer_product_font].font_name
					   , [issuer_product].enable_instant_pin_YN
					   , [issuer_product].pin_mailer_printing_YN
					   , [issuer_product].pin_mailer_reprint_YN
					   , [issuer_product].charge_fee_to_issuing_branch_YN
					   , [issuer_product].print_issue_card_YN	
					   , [issuer_product].allow_manual_uploaded_YN
					   , [issuer_product].allow_reupload_YN				

					   , [dist_card_statuses].dist_card_status_name
					   , [dist_batch].dist_batch_reference 

					   , [branch_card_status_current].branch_card_statuses_id
					   , [branch_card_status_current].status_date
					   , [branch_card_statuses_language].language_text AS 'branch_card_statuses_name'
					   , [branch_card_status_current].branch_card_code_type_id
					   , [branch_card_status_current].branch_card_code_name			   
					   , [branch_card_status_current].spoil_only
					   , [branch_card_status_current].comments
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY(operator.username)) as operator
					   , [customer_account].domicile_branch_id
					   , [domicile_branch].branch_code as domicile_branch_code
					   , [domicile_branch].branch_name as domicile_branch_name
					   , [delivery_branch].branch_code as delivery_branch_code
					   , [delivery_branch].branch_name as delivery_branch_name
					   , [customer_account].customer_account_id
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_account_number)) as 'customer_account_number'
					   , [customer_account].card_issue_reason_id
					   , [card_issue_reason_language].language_text AS 'card_issuer_reason_name'
					   , [customer_account].account_type_id
					   , [customer_account_type_language].language_text AS 'customer_account_type_name'
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_first_name)) as 'customer_first_name'
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_middle_name)) as 'customer_middle_name'
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_last_name)) as 'customer_last_name'
					   , [customer_account].customer_title_id
					   , [customer_title_language].language_text AS 'customer_title_name'
					   , --[customer_account].date_issued
							CASE
								WHEN [branch_card_status_current].branch_card_statuses_id = 6 THEN [branch_card_status_current].status_date
								ELSE null
							END as date_issued
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].name_on_card)) as 'name_on_card'
					   , [customer_account].[user_id]
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].first_name)) as 'user_first_name'
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].last_name)) as 'user_last_name'
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].username)) as 'username'
					   , [customer_account].cms_id
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].CustomerId)) as 'CustomerId'
					   , [customer_account].currency_id

					   , [currency].currency_code
					   , [currency].iso_4217_numeric_code
					   , [product_currency].is_base as is_base_currency
					   , [product_currency].usr_field_name_1
					   , [product_currency].usr_field_val_1
					   , [product_currency].usr_field_name_2
					   , [product_currency].usr_field_val_2

					   , [customer_account].resident_id
					   , [customer_residency_language].language_text AS 'customer_residency_name'
					   , [customer_account].customer_type_id
					   , [customer_type_language].language_text AS 'customer_type_name'
					   , [customer_account].contract_number
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].Id_number)) as 'id_number'
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].contact_number)) as 'contact_number'
					   , [pin_mailer_reprint_statuses_language].pin_mailer_reprint_status_id
					   , [pin_mailer_reprint_statuses_language].language_text as 'pin_mailer_reprint_status_name'

					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([product_fee_accounting].[fee_revenue_account_no])) as [fee_revenue_account_no]
					   , [product_fee_accounting].[fee_revenue_account_type_id]
					   , [product_fee_accounting].[fee_revenue_branch_code]
					   , [product_fee_accounting].[fee_revenue_narration_en]
				       , [product_fee_accounting].[fee_revenue_narration_fr]
					   , [product_fee_accounting].[fee_revenue_narration_pt]
					   , [product_fee_accounting].[fee_revenue_narration_es]
					   , CONVERT(VARCHAR(MAX),DECRYPTBYKEY([product_fee_accounting].[vat_account_no])) as [vat_account_no]
					   , [product_fee_accounting].[vat_account_type_id]
					   , [product_fee_accounting].[vat_account_branch_code]
					   , [product_fee_accounting].[vat_narration_en]
					   , [product_fee_accounting].[vat_narration_fr]
					   , [product_fee_accounting].[vat_narration_pt]
					   , [product_fee_accounting].[vat_narration_es]

				FROM [cards]
					INNER JOIN [branch]
						ON [branch].branch_id = [cards].branch_id
					INNER JOIN [branch] as [delivery_branch]
						ON [delivery_branch].branch_id = [cards].delivery_branch_id
					INNER JOIN [issuer]
						ON [issuer].issuer_id = [branch].issuer_id
					INNER JOIN [country]
						ON [country].country_id = [issuer].country_id						
					INNER JOIN [card_issue_method_language]
						ON [cards].card_issue_method_id = [card_issue_method_language].card_issue_method_id
							AND [card_issue_method_language].language_id = @language_id
					INNER JOIN [card_priority_language]
						ON [cards].card_priority_id = [card_priority_language].card_priority_id
							AND [card_priority_language].language_id = @language_id					
					LEFT OUTER JOIN [load_batch_cards]
						ON [load_batch_cards].card_id = [cards].[card_id]
					LEFT OUTER JOIN [load_batch]
						ON [load_batch].load_batch_id = [load_batch_cards].load_batch_id
					LEFT OUTER JOIN [load_card_statuses]
						ON [load_card_statuses].load_card_status_id = [load_batch_cards].load_card_status_id
					INNER JOIN [issuer_product]
						ON [issuer_product].product_id = [cards].product_id
					INNER JOIN [Issuer_product_font]
						ON [issuer_product].font_id = [Issuer_product_font].font_id
					LEFT OUTER JOIN [product_fee_scheme]
						ON [issuer_product].fee_scheme_id = [product_fee_scheme].fee_scheme_id
					LEFT OUTER JOIN [product_fee_accounting]
						ON [product_fee_scheme].fee_accounting_id = [product_fee_accounting].fee_accounting_id

					LEFT OUTER JOIN [dist_batch_cards]
						ON [cards].card_id = [dist_batch_cards].card_id
					LEFT OUTER  JOIN [dist_batch]
						ON [dist_batch].dist_batch_id = [dist_batch_cards].dist_batch_id
					LEFT OUTER  JOIN [dist_card_statuses]
						ON [dist_card_statuses].dist_card_status_id = [dist_batch_cards].dist_card_status_id

					LEFT OUTER JOIN [branch_card_status_current]
						ON [branch_card_status_current].card_id = [cards].card_id
					LEFT OUTER JOIN [user] operator
						ON [branch_card_status_current].operator_user_id = operator.[user_id]
					LEFT OUTER JOIN [branch_card_statuses_language]
						ON [branch_card_statuses_language].branch_card_statuses_id = [branch_card_status_current].branch_card_statuses_id
							AND [branch_card_statuses_language].language_id = @language_id

					LEFT OUTER JOIN [customer_account]
						ON [cards].card_id = [customer_account].card_id
					LEFT OUTER JOIN [branch] as [domicile_branch]
						ON [domicile_branch].branch_id = [customer_account].domicile_branch_id
					LEFT OUTER JOIN [customer_type_language]
						ON [customer_type_language].customer_type_id = [customer_account].customer_type_id
							AND [customer_type_language].language_id = @language_id
					LEFT OUTER JOIN [customer_account_type_language]
						ON [customer_account_type_language].account_type_id = [customer_account].account_type_id
							AND [customer_account_type_language].language_id = @language_id
					LEFT OUTER JOIN [customer_residency_language]
						ON [customer_residency_language].resident_id = [customer_account].resident_id
							AND [customer_residency_language].language_id = @language_id
					LEFT OUTER JOIN [customer_title_language]
						ON [customer_title_language].customer_title_id = [customer_account].customer_title_id
							AND [customer_title_language].language_id = @language_id
					LEFT OUTER JOIN [card_issue_reason_language]
						ON [card_issue_reason_language].card_issue_reason_id = [customer_account].card_issue_reason_id
							AND [card_issue_reason_language].language_id = @language_id
					LEFT OUTER JOIN [currency]
						ON [currency].currency_id = [customer_account].currency_id
					LEFT OUTER JOIN [product_currency]
						ON [product_currency].currency_id = [customer_account].currency_id
							AND [product_currency].product_id = [issuer_product].product_id
					LEFT OUTER JOIN [user]
						ON [customer_account].[user_id] = [user].[user_id]

					LEFT OUTER JOIN [pin_mailer_reprint_status_current]
						ON [pin_mailer_reprint_status_current].card_id = [cards].card_id
					LEFT OUTER JOIN [pin_mailer_reprint_statuses_language]
						ON [pin_mailer_reprint_statuses_language].pin_mailer_reprint_status_id = [pin_mailer_reprint_status_current].pin_mailer_reprint_status_id
							AND [pin_mailer_reprint_statuses_language].language_id = @language_id
				WHERE [cards].card_id = @card_id
				

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key


			COMMIT TRANSACTION [GET_CARD_DETAILS_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [GET_CARD_DETAILS_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Altering [dbo].[usp_get_customercardsearch_list]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_customercardsearch_list]
	@issuer_id int =null,
	@branch_id int =null,
	@cardrefno nvarchar(50),
	@customeraccountno nvarchar(50),
	@product_id int =null,
	@card_Priority int=null,
	@card_issuemethod int =null,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	IF @customeraccountno = '' OR @customeraccountno IS NULL
		SET @customeraccountno = NULL
	ELSE
		SET @customeraccountno = '%' + @customeraccountno + '%'
			
	IF @cardrefno = '' OR @cardrefno IS NULL
		SET @cardrefno = NULL
	ELSE
		SET @cardrefno = '%' + @cardrefno + '%'

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	DECLARE @mask_screen bit = [dbo].MaskScreenPAN(@audit_user_id)

	DECLARE @StartRow INT, @EndRow INT;			

	SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
	SET @EndRow = @StartRow + @RowsPerPage - 1;

	WITH PAGE_ROWS
	AS
	(
	SELECT ROW_NUMBER() OVER(ORDER BY product_name ASC) AS ROW_NO
			, COUNT(*) OVER() AS TOTAL_ROWS
			, *
	FROM(
	
    -- Insert statements for procedure here
	SELECT
		ip.product_name 
		, CASE 
			WHEN @mask_screen = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY(c.card_number)),6,4) 
			ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY(c.card_number))
		  END AS 'card_number'
		, c.card_request_reference AS card_reference_number
		, ca.card_id
		, CONVERT(VARCHAR(max),DECRYPTBYKEY(ca.customer_first_name)) as 'first_name'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY(ca.customer_last_name)) as 'last_name'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY(ca.customer_account_number)) AS account_number
	FROM
		customer_account ca 
		INNER JOIN cards as c ON ca.card_id = c.card_id 
		INNER JOIN [branch_card_status_current] ON [branch_card_status_current].card_id = c.card_id	
		INNER JOIN issuer_product as ip ON c.product_id = ip.product_id
		INNER JOIN [branch] ON [branch].branch_id = c.branch_id
		INNER JOIN [issuer] ON [issuer].[issuer_id] = [branch].issuer_id
	WHERE
		ip.issuer_id =COALESCE(@issuer_id, ip.issuer_id)
		AND branch.branch_id=COALESCE(@branch_id,branch.branch_id) 
		AND (@customeraccountno IS NULL OR CONVERT(VARCHAR(max),DECRYPTBYKEY(ca.customer_account_number)) LIKE @customeraccountno) 
		AND (@cardrefno IS NULL OR c.card_request_reference LIKE @cardrefno)
		AND CONVERT(VARCHAR(max),DECRYPTBYKEY(c.card_number)) <>''
		AND [branch_card_status_current].branch_card_statuses_id = 0 
		AND c.card_issue_method_id=COALESCE(@card_issuemethod, c.card_issue_method_id) 
		AND c.card_priority_id =COALESCE(@card_Priority, c.card_priority_id)
		AND c.product_id =COALESCE(@product_id, c.product_id)
		)
						  AS Src )
	SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
		,*
	FROM PAGE_ROWS
	WHERE ROW_NO BETWEEN @StartRow AND @EndRow
	ORDER BY product_name ASC

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_dist_batch_card_details_paged]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Fetch all cards linked to distribution batch with their details
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_dist_batch_card_details_paged] 
	@dist_batch_id bigint,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN

	SET NOCOUNT ON;

	DECLARE @StartRow INT, @EndRow INT;	
	SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
	SET @EndRow = @StartRow + @RowsPerPage - 1;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;


	WITH PAGE_ROWS
	AS
	(
	SELECT ROW_NUMBER() OVER(ORDER BY card_id ASC) AS ROW_NO
			, COUNT(*) OVER() AS TOTAL_ROWS
			, *
	FROM( 

		SELECT
			[dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) AS 'card_number'
			, cards.card_request_reference AS card_reference_number
			, [cards].branch_id
			, [cards].card_id
			, [cards].card_issue_method_id
			, [cards].card_priority_id
			, [cards].card_request_reference
			, [cards].card_sequence
			, [cards].product_id
			, CONVERT(DATETIME,CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].card_activation_date)), 109) as 'card_activation_date' 
			, CONVERT(DATETIME,CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].card_expiry_date)), 109) as 'card_expiry_date'
			, CONVERT(DATETIME,CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].card_production_date)), 109) as 'card_production_date'						
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].pvv)) as 'pvv'
			, [dist_batch_cards].dist_batch_id
			, [dist_batch_cards].dist_card_status_id
			, [dist_card_statuses].dist_card_status_name
			, [customer_account].account_type_id
			, [customer_account].cms_id
			, [customer_account].contract_number
			, [customer_account].currency_id, [customer_account].customer_account_id
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_account_number)) as 'customer_account_number'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_first_name)) as 'customer_first_name'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_last_name)) as 'customer_last_name'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_middle_name)) as 'customer_middle_name'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].name_on_card)) as 'name_on_card'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].Id_number)) as 'Id_number'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].contact_number)) as 'contact_number'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].CustomerId)) as 'CustomerId'
			, [customer_account].customer_title_id
			, [customer_account].customer_type_id
			, [customer_account].date_issued
			, [customer_account].resident_id
			, [customer_account].[user_id]
			, [issuer].issuer_id
			, [issuer].issuer_code
			, [issuer].issuer_name
			, [branch].branch_code
			, [branch].branch_name
			, [issuer_product].[product_code]
			, [issuer_product].[product_name]
			, [issuer_product].[product_bin_code]
			, [issuer_product].[sub_product_code]
			, [issuer_product].[pan_length]
			, [issuer_product].[src1_id]
			, [issuer_product].[src2_id]
			, [issuer_product].[src3_id]
			, CONVERT(INT, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[PVKI]))) as 'PVKI'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[PVK])) as 'PVK'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[CVKA])) as 'CVKA'
			, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[CVKB])) as 'CVKB'
			, [issuer_product].[expiry_months]
		FROM [cards]
			INNER JOIN [dist_batch_cards] 
				ON [dist_batch_cards].card_id = [cards].card_id	
			INNER JOIN [dist_card_statuses]
				ON 	[dist_batch_cards].dist_card_status_id = [dist_card_statuses].dist_card_status_id
			INNER JOIN [branch]
				ON [cards].branch_id = [branch].branch_id
			INNER JOIN [issuer]
				ON [branch].issuer_id = [issuer].issuer_id
			INNER JOIN [issuer_product]
				ON [cards].product_id = [issuer_product].product_id
			LEFT OUTER JOIN [customer_account]
				ON [cards].card_id = [customer_account].card_id
		WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id

	) AS Src )
	SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
		,*
	FROM PAGE_ROWS
	WHERE ROW_NO BETWEEN @StartRow AND @EndRow
	ORDER BY card_id ASC
														   
	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;		

END
GO
PRINT N'Altering [dbo].[usp_get_dist_batch_cards]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Fetch all cards linked to distribution batch
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_dist_batch_cards] 
	@dist_batch_id bigint,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN

	SET NOCOUNT ON;

	BEGIN TRANSACTION [GET_DIST_BATCH_CARDS]
		BEGIN TRY 
			DECLARE @mask_screen bit = [dbo].MaskScreenPAN(@audit_user_id)

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

				SELECT 
					CASE 
						WHEN @mask_screen = 1 THEN [dbo].[MaskString](CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)),6,4) 
						ELSE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number))
					END AS 'card_number'
					, cards.card_request_reference AS card_reference_number
					, [dist_card_statuses].dist_card_status_name					   
				FROM [cards]
					INNER JOIN [dist_batch_cards] ON [dist_batch_cards].card_id = [cards].card_id	
					INNER JOIN [dist_card_statuses] ON 	[dist_batch_cards].dist_card_status_id = [dist_card_statuses].dist_card_status_id
					INNER JOIN [branch] ON [branch].branch_id = cards.branch_id
					INNER JOIN [issuer] ON branch.issuer_id = issuer.issuer_id
				WHERE 
					[dist_batch_cards].dist_batch_id = @dist_batch_id
				ORDER BY 'card_number'
					
														   
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;		

			--DECLARE @audit_msg varchar
			--SET @audit_msg = 'Getting cards for distribution batch with id: ' + CAST(@dist_batch_id AS varchar(max))
			----log the audit record		
			--EXEC usp_insert_audit @audit_user_id, 
			--					 1,
			--					 NULL, 
			--					 @audit_workstation, 
			--					 @audit_msg, 
			--					 NULL, NULL, NULL, NULL

			COMMIT TRANSACTION [GET_DIST_BATCH_CARDS]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [GET_DIST_BATCH_CARDS]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_branch_order_report]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	to get cards which are distributed at the branch
-- =============================================
ALTER PROCEDURE [dbo].[usp_branch_order_report] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = NULL,
	@branch_id int = NULL,
	@date_from datetime,
	@date_to datetime
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SET @date_to = DATEADD(d, 1, @date_to)

    OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT 
		DISTINCT CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_first_name)) AS customer_first_name
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_middle_name)) AS customer_middle_name
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_last_name)) AS customer_last_name
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_account_number)) AS customer_account_number
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].name_on_card)) AS name_on_card
		, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].contact_number)) AS contact_number
		, [dist_batch].dist_batch_reference
		, [dist_batch].date_created
		, [issuer].issuer_name
		, [issuer].issuer_code
		, [branch].branch_name
		, branch.branch_code
	FROM 
		[cards]
		INNER JOIN [customer_account]
			ON [cards].card_id = [customer_account].card_id
		INNER JOIN [dist_batch_cards]
			ON [cards].card_id = [dist_batch_cards].card_id
		INNER JOIN [dist_batch]
			ON [dist_batch_cards].dist_batch_id = [dist_batch].dist_batch_id
				AND [dist_batch].dist_batch_type_id = 0
				AND [dist_batch].date_created = ( SELECT MAX(db.date_created) --- to check cards are distributed or not 
												  FROM [dist_batch] db
														INNER JOIN [dist_batch_cards] dbc
															ON db.dist_batch_id = dbc.dist_batch_id
												  WHERE dbc.card_id = [cards].card_id)
		INNER JOIN [branch]
			ON [cards].branch_id = [branch].branch_id
		INNER JOIN [issuer]
			ON [branch].issuer_id = [issuer].issuer_id	
	WHERE 
		[cards].card_issue_method_id = 0
		AND [issuer].issuer_id = COALESCE(@issuer_id, [issuer].issuer_id)
		AND [branch].branch_id = COALESCE(@branch_id, [branch].branch_id)
		AND [dist_batch].date_created >= @date_from
		AND [dist_batch].date_created <= @date_to
	ORDER BY 
		issuer_name
		, issuer_code
		, branch_name
		, branch_code
		, date_created
		, customer_account_number
		, customer_first_name
		, customer_last_name

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_branch]...';


GO
ALTER PROC [dbo].[usp_get_branch]
			@branchName varchar(30),
			@branchCode varchar(10),
			@issuerID int,
			@is_card_centre bit = null
			
	AS 
	BEGIN 
	IF (@branchName='') OR (@branchName=null)
	BEGIN
		SET @branchName=NULL
	END
	
	IF (@branchCode='') OR (@branchCode=null)
	BEGIN
		SET @branchCode=NULL
	END
	
	
   SELECT * FROM branch 
   WHERE branch_name = COALESCE(@branchName,branch_name)
    AND branch_code =COALESCE(@branchCode,branch_code)
    AND issuer_id =@issuerID
	AND ((@is_card_centre is null) OR (card_centre_branch_YN = @is_card_centre))

                           
                           
    END
GO
PRINT N'Altering [dbo].[usp_get_burnrate_report]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec [usp_get_burnrate_report] null,18,0,null,1,'test'
ALTER PROCEDURE [dbo].[usp_get_burnrate_report]
	@branch_id int = null,
	@issuer_id int = null,
	@language_id int,
	--@REPORT_DATE datetime=null,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	if(@issuer_id = -1 or @issuer_id = 0)
	 set @issuer_id=null

	if(@branch_id  =0)
		set @branch_id = null

		DECLARE  @WEEK_BEGINING VARCHAR(10)
		Declare @REPORT_DATE datetime
--SELECT @REPORT_DATE = '2004-09-21T00:00:00'
set @REPORT_DATE=GETDATE()
SELECT @WEEK_BEGINING = 'MONDAY'
if(@REPORT_DATE is null or @REPORT_DATE='')
set @REPORT_DATE = convert(datetime, getdate(), 126)
else
set @REPORT_DATE = convert(datetime, @REPORT_DATE, 126)

IF @WEEK_BEGINING = 'MONDAY' 
    SET DATEFIRST 1 
ELSE IF @WEEK_BEGINING = 'TUESDAY' 
    SET  DATEFIRST 2 
ELSE IF @WEEK_BEGINING = 'WEDNESDAY'
    SET  DATEFIRST 3 
ELSE IF @WEEK_BEGINING =  'THURSDAY'
    SET  DATEFIRST 4 
ELSE IF @WEEK_BEGINING =  'FRIDAY'
    SET  DATEFIRST 5 
ELSE IF @WEEK_BEGINING =  'SATURDAY'
    SET  DATEFIRST 6 
ELSE IF @WEEK_BEGINING =  'SUNDAY'
    SET  DATEFIRST 7 


DECLARE @WEEK_START_DATE DATETIME, @WEEK_END_DATE DATETIME
--GET THE WEEK START DATE
set  @WEEK_START_DATE = @REPORT_DATE - (DATEPART(DW,  @REPORT_DATE) - 1) 

--GET THE WEEK END DATE
set  @WEEK_END_DATE = @REPORT_DATE + (7 - DATEPART(DW,  @REPORT_DATE))

select interx.branch_id, interx.branch_code , sum(interx.oneeighty_d) as '180 d' ,sum(interx.oneeighty_d) as '90 d',sum(interx.Week_one) as 'Week 1', sum(interx.Week_two) as 'Week 2',sum(interx.Week_three) as 'Week 3',sum(interx.Week_four) as 'Week 4',sum(interx.Current_Card_Stock) as 'Current Card Stock',sum(interx.Weeks_remaining) as 'Weeks remaining'

from (
SELECT distinct [branch].branch_id,branch.branch_name+'-'+ branch.branch_code as 'branch_code' ,count(branch_card_status.card_id) as 'oneeighty_d',0 as 'ninty_d',0 as 'Week_one', 0 as 'Week_two',0  as 'Week_three',0  as 'Week_four',0 as 'Current_Card_Stock',0 as 'Weeks_remaining'
		FROM [cards]
		INNER JOIN 	  dbo.branch_card_status  	ON  dbo.branch_card_status .card_id = [cards].card_id
		INNER JOIN [customer_account] 	ON [customer_account].card_id = branch_card_status.card_id
		INNER JOIN [branch] ON [cards].branch_id = [branch].branch_id
			WHERE branch_card_status.branch_card_statuses_id = 6 and 
			[branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)	
			AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  AND branch_card_status.[status_date] <=  @REPORT_DATE
				  AND branch_card_status.[status_date] >= DATEADD(d, -180,@REPORT_DATE)
				  group by [branch].branch_id, branch.branch_code ,branch.branch_name

union

SELECT distinct [branch].branch_id, branch.branch_name+'-'+ branch.branch_code as 'branch_code', 0 as 'oneeighty_d',count(branch_card_status.card_id) as 'ninty_d',0 as 'Week_one', 0 as 'Week_two',0  as 'Week_three',0  as 'Week_four',0 as 'Current_Card_Stock',0 as 'Weeks_remaining'
			FROM [cards]
			INNER JOIN 	  dbo.branch_card_status  	ON  dbo.branch_card_status .card_id = [cards].card_id
			INNER JOIN [customer_account] 	ON [customer_account].card_id = branch_card_status.card_id
			INNER JOIN [branch] 	ON [cards].branch_id = [branch].branch_id
			WHERE branch_card_status.branch_card_statuses_id = 6 and
			[branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)		
			 AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  AND branch_card_status.[status_date] <=  @REPORT_DATE
				  AND branch_card_status.[status_date] >= DATEADD(d, -90,@REPORT_DATE)
				  group by [branch].branch_id, branch.branch_code ,branch.branch_name

union 
SELECT distinct [branch].branch_id,branch.branch_name+'-'+ branch.branch_code as 'branch_code' , 0 as 'oneeighty_d',0 as 'ninty_d', count(branch_card_status.card_id) as 'Week_one', 0 as 'Week_two',0  as 'Week_three',0  as 'Week_four',0 as 'Current_Card_Stock',0 as 'Weeks_remaining'
			FROM [cards]
			INNER JOIN 	  dbo.branch_card_status  	ON  dbo.branch_card_status .card_id = [cards].card_id
			INNER JOIN [customer_account] 	ON [customer_account].card_id = branch_card_status.card_id
			INNER JOIN [branch]		ON [cards].branch_id = [branch].branch_id
			WHERE branch_card_status.branch_card_statuses_id = 6 and 
			[branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)		
			 AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  AND branch_card_status.[status_date] >=  @WEEK_START_DATE
				  AND branch_card_status.[status_date] <=  @WEEK_END_DATE
				  group by [branch].branch_id, branch.branch_code ,branch.branch_name

union 
SELECT distinct [branch].branch_id, branch.branch_name+'-'+ branch.branch_code as 'branch_code' , 0 as 'oneeighty_d',0 as 'ninty_d', 0  as 'Week_one', count(branch_card_status.card_id)   as 'Week_two',0  as 'Week_three',0  as 'Week_four',0 as 'Current_Card_Stock',0 as 'Weeks_remaining'
			FROM [cards]
		INNER JOIN 	  dbo.branch_card_status  	ON  dbo.branch_card_status .card_id = [cards].card_id
		INNER JOIN [customer_account] 	ON [customer_account].card_id = branch_card_status.card_id
        INNER JOIN [branch] ON [cards].branch_id = [branch].branch_id
			WHERE branch_card_status.branch_card_statuses_id = 6  
			and [branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)		
			AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  AND branch_card_status.[status_date] >= DATEADD(d, -7,@WEEK_START_DATE)
				  AND branch_card_status.[status_date] <= DATEADD(d, -1,@WEEK_START_DATE)
				  group by [branch].branch_id, branch.branch_code ,branch.branch_name

union 
SELECT distinct [branch].branch_id, branch.branch_name+'-'+ branch.branch_code as 'branch_code' , 0 as 'oneeighty_d',0 as 'ninty_d', 0  as 'Week_one',0 as  'Week_two',count(branch_card_status.card_id)  as 'Week_three',0  as 'Week_four',0 as 'Current_Card_Stock',0 as 'Weeks_remaining'
			FROM [cards]
		INNER JOIN 	  dbo.branch_card_status  	ON  dbo.branch_card_status .card_id = [cards].card_id
		INNER JOIN [customer_account]		ON [customer_account].card_id = branch_card_status.card_id
		INNER JOIN [branch]	ON [cards].branch_id = [branch].branch_id
			WHERE branch_card_status.branch_card_statuses_id = 6   
			and[branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)	
			AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  AND branch_card_status.[status_date] >= DATEADD(d, -14,@WEEK_START_DATE)
				  AND branch_card_status.[status_date] <= DATEADD(d, -8,@WEEK_START_DATE)
				  group by [branch].branch_id, branch.branch_code ,branch.branch_name
union 
SELECT  distinct [branch].branch_id, branch.branch_name+'-'+ branch.branch_code as 'branch_code' , 0 as 'oneeighty_d',0 as 'ninty_d', 0  as 'Week_one',0 as  'Week_two', 0 as 'Week_three',count(branch_card_status.card_id) as 'Week_four',0 as 'Current_Card_Stock',0 as 'Weeks_remaining'
			FROM [cards]
		INNER JOIN 	  dbo.branch_card_status  	ON  dbo.branch_card_status .card_id = [cards].card_id
		INNER JOIN [customer_account] 	ON [customer_account].card_id = branch_card_status.card_id
		INNER JOIN [branch] ON [cards].branch_id = [branch].branch_id
			WHERE branch_card_status.branch_card_statuses_id = 6 	
			and[branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)	
			AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  AND branch_card_status.[status_date] >= DATEADD(d, -21,@WEEK_START_DATE)
				  AND branch_card_status.[status_date] <= DATEADD(d, -15,@WEEK_START_DATE)
				  group by [branch].branch_id, branch.branch_code,branch.branch_name 
union 
SELECT distinct [branch].branch_id, branch.branch_name+'-'+ branch.branch_code as 'branch_code' , 0 as 'oneeighty_d',0 as 'ninty_d', 0  as 'Week_one',0 as  'Week_two', 0 as 'Week_three',0 as 'Week_four',count([branch_card_status_current].card_id)  as 'Current_Card_Stock',0 as 'Weeks_remaining'
			FROM [branch_card_status_current] 
					INNER JOIN [cards]
						ON [branch_card_status_current].card_id = [cards].card_id
					INNER JOIN [branch]
						ON [cards].branch_id = [branch].branch_id
			WHERE ([branch_card_status_current].branch_card_statuses_id = 1	or [branch_card_status_current].branch_card_statuses_id = 0)
			and[branch].branch_id = COALESCE(@branch_id,  [branch].branch_id)		
			 AND [branch].issuer_id = COALESCE(@issuer_id, [branch].issuer_id)
				  group by [branch].branch_id, branch.branch_code ,branch.branch_name
				 
) AS interx
group by interx.branch_id, interx.branch_code
END
GO
PRINT N'Altering [dbo].[usp_get_cardinventorysummaryreport]...';


GO
-- =============================================
-- Author:		sandhya konduru
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec [usp_get_cardinventorysummaryreport] null,3,0,1,''
ALTER PROCEDURE [dbo].[usp_get_cardinventorysummaryreport]
	@branch_id int = null,
	@issuer_id int = null,
	@language_id int =null,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
	AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	if(@issuer_id=-1 or @issuer_id=0)
	set @issuer_id=null

	if(@branch_id =0)
	set @branch_id=null

	SELECT INTERX.issuer_id,
		   branch_code,
		   INTERX.branch_id,
		   INTERX.statuses_name,
		   INTERX.statuses_id,
		   COUNT(INTER.card_id)	AS CardCount,
		   issuer.issuer_name as 'issuer_name'

	FROM 	 
		  (SELECT [branch].branch_id, dist_batch_status_current.dist_batch_statuses_id as 'statuses_id', [dist_batch_cards].card_id
			FROM dist_batch_status_current
			INNER JOIN [dist_batch_cards]
				ON dist_batch_status_current.dist_batch_id = [dist_batch_cards].dist_batch_id
			INNER JOIN [cards]
				ON [dist_batch_cards].card_id = [cards].card_id
			INNER JOIN [branch]
				ON [cards].branch_id = [branch].branch_id
					AND [branch].card_centre_branch_YN = 1					
	WHERE [branch].branch_status_id = 0 
			) AS INTER
				RIGHT OUTER JOIN 			
			(SELECT issuer_id, branch_id,branch.branch_name+'-'+ branch_code as branch_code, [dist_batch_statuses].dist_batch_statuses_id as 'statuses_id', bcl.language_text as 'statuses_name',bcl.language_id
			 FROM	[branch], [dist_batch_statuses]
			 inner join [dist_batch_statuses_language] bcl on [dist_batch_statuses].dist_batch_statuses_id=bcl.dist_batch_statuses_id
			 where branch.branch_status_id=0 and branch.card_centre_branch_YN = 1
		 		) INTERX

			ON INTER.branch_id = INTERX.branch_id
				AND INTER.statuses_id = INTERX.statuses_id 				
	inner join issuer on issuer.issuer_id=INTERX.issuer_id

	WHERE INTERX.issuer_id = COALESCE(@issuer_id, INTERX.issuer_id)
		  AND INTERX.branch_id = COALESCE(@branch_id, INTERX.branch_id) and INTERX.language_id=@language_id
		  AND INTERX.statuses_id not in (17,18,19)
		  AND INTERX.branch_code <> ''  
	GROUP BY INTERX.issuer_id, INTERX.branch_id, branch_code, statuses_name, INTERX.statuses_id,issuer_name
	ORDER BY issuer_name, INTERX.branch_code, INTERX.statuses_id

END
GO
PRINT N'Altering [dbo].[usp_get_dist_batch]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Retreive a distribution batch
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_dist_batch] 
	@dist_batch_id bigint,
	@language_id INT,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [GET_DIST_BATCH]
		BEGIN TRY 

		--DECLARE @flow_id int

		--if(NOT EXISTS(SELECT * FROM [dist_batch_statuses_flow] INNER JOIN [dist_batch]
		--			ON [dist_batch_statuses_flow].issuer_id = [dist_batch].issuer_id
		--				AND [dist_batch_statuses_flow].card_issue_method_id = [dist_batch].card_issue_method_id
		--				AND [dist_batch_statuses_flow].dist_batch_type_id = [dist_batch].dist_batch_type_id
		--			WHERE [dist_batch].dist_batch_id = @dist_batch_id))
		--	BEGIN
		--		SET @flow_id = -1
		--	END

		OPEN SYMMETRIC KEY Indigo_Symmetric_Key
		DECRYPTION BY CERTIFICATE Indigo_Certificate;
			SELECT 
				distinct CAST(1 as BIGINT) as ROW_NO, 1 AS TOTAL_ROWS, 1 as TOTAL_PAGES
				, [dist_batch].dist_batch_id
				, [dist_batch].date_created
				, [dist_batch].dist_batch_reference
				, [dist_batch].no_cards
				, [dist_batch_status_current].dist_batch_statuses_id
				, [dist_batch_status_current].status_notes
				, [dist_batch_statuses_language].language_text AS 'dist_batch_status_name'
				, [issuer].issuer_id
				, [issuer].issuer_name
				, [issuer].issuer_code
				--, [issuer].auto_create_dist_batch
				, [card_issue_method_language].language_text AS 'card_issue_method_name'
				, [dist_batch].card_issue_method_id
				, [dist_batch].dist_batch_type_id
				, [product_flow].dist_batch_status_flow_id
				, [product_flow].flow_dist_batch_statuses_id
				, [product_flow].flow_dist_batch_type_id
				, [product_flow].user_role_id
				, [product_flow].reject_dist_batch_statuses_id
				, ISNULL([branch].branch_name, '-') as branch_name
				, ISNULL([branch].branch_code,'') as branch_code
				, [issuer_product].product_name as 'product_name'
				, CONVERT(VARCHAR(max),DECRYPTBYKEY(CREATOR.username)) as [username]
				
			FROM [dist_batch] 
				INNER JOIN [dist_batch_status_current]
					ON [dist_batch].dist_batch_id = [dist_batch_status_current].dist_batch_id
				INNER JOIN [dist_batch_statuses_language]
					ON [dist_batch_status_current].dist_batch_statuses_id = [dist_batch_statuses_language].dist_batch_statuses_id
				INNER JOIN [issuer]
					ON [issuer].issuer_id = [dist_batch].issuer_id
				INNER JOIN [card_issue_method_language]
					ON [dist_batch].card_issue_method_id = [card_issue_method_language].card_issue_method_id
						AND [card_issue_method_language].language_id = @language_id	
				LEFT OUTER JOIN (SELECT [username], dist_batch_id
							FROM [user]
								INNER JOIN [dist_batch_status]
									ON [dist_batch_status].[user_id] = [user].[user_id]
										AND [dist_batch_status].dist_batch_statuses_id = 0
										AND [dist_batch_status].dist_batch_id = @dist_batch_id) AS CREATOR
					ON CREATOR.dist_batch_id = [dist_batch].dist_batch_id

				LEFT OUTER JOIN [branch]
					ON [branch].branch_id = [dist_batch].branch_id	

				--LEFT OUTER JOIN [dist_batch_statuses_flow] as [issuer_flow]
				--	ON [dist_batch_status_current].dist_batch_statuses_id = [issuer_flow].dist_batch_statuses_id
				--		AND [dist_batch].card_issue_method_id = [issuer_flow].card_issue_method_id
				--		AND [issuer_flow].dist_batch_type_id = [dist_batch].dist_batch_type_id
				--		AND [issuer_flow].issuer_id = COALESCE(@flow_id, [dist_batch].issuer_id)
				INNER JOIN [dist_batch_cards]
					ON [dist_batch].dist_batch_id=[dist_batch_cards].dist_batch_id
				INNER JOIN cards  
					ON [dist_batch_cards].card_id=cards.card_id
				INNER JOIN [issuer_product]
					ON cards.product_id = [issuer_product].product_id
				LEFT OUTER JOIN [dist_batch_statuses_flow] AS [product_flow]
					ON (([dist_batch].dist_batch_type_id = 0 AND 
							[product_flow].dist_batch_status_flow_id = [issuer_product].production_dist_batch_status_flow)
						OR ([dist_batch].dist_batch_type_id = 1 AND 
							[product_flow].dist_batch_status_flow_id = [issuer_product].distribution_dist_batch_status_flow))
						AND [product_flow].dist_batch_statuses_id = [dist_batch_status_current].dist_batch_statuses_id

			WHERE [dist_batch].dist_batch_id = @dist_batch_id
					AND [dist_batch_statuses_language].language_id = @language_id	
					
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;	

			--DECLARE @audit_msg varchar
			--SET @audit_msg = 'Getting dist batch with id: ' + CAST(@dist_batch_id AS varchar(max))
			----log the audit record		
			--EXEC usp_insert_audit @audit_user_id, 
			--					 1,
			--					 NULL, 
			--					 @audit_workstation, 
			--					 @audit_msg, 
			--					 NULL, NULL, NULL, NULL

			COMMIT TRANSACTION [GET_DIST_BATCH]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [GET_DIST_BATCH]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_get_dist_batches_for_user]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 26 March 2014
-- Description:	Gets a list of distribution batches for a user
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_dist_batches_for_user] 
	-- Add the parameters for the stored procedure here
	@user_id bigint,
	@issuerId int =null,
	@dist_batch_reference VARCHAR(25) = NULL,
	@dist_batch_statuses_id int = NULL,
	@branch_id INT = NULL,
	@card_issue_method_id int = NULL,
	@distBatchTypeId int = null,
	@date_start DateTime = NULL,
	@date_end DateTime = NULL,
	@language_id INT,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [GET_DIST_BATCH_FOR_USER_TRAN]
		BEGIN TRY 
			IF(@dist_batch_reference = '' or @dist_batch_reference IS NULL)
				SET @dist_batch_reference = ''

			IF @date_end IS NOT NULL
				SET @date_end = DATEADD(DAY, 1, @date_end)

			DECLARE @StartRow INT, @EndRow INT;			

			SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
			SET @EndRow = @StartRow + @RowsPerPage - 1;

			--append#1
			WITH PAGE_ROWS
			AS
			(
			SELECT ROW_NUMBER() OVER(ORDER BY date_created DESC, dist_batch_reference ASC) AS ROW_NO
					, COUNT(*) OVER() AS TOTAL_ROWS
					, *
			FROM( 
				SELECT Distinct [dist_batch].dist_batch_id, [dist_batch].date_created, [dist_batch].dist_batch_reference, 
					   [dist_batch].no_cards, [dist_batch_status_current].status_notes,
					   [dist_batch_status_current].dist_batch_statuses_id, [dist_batch_statuses_language].language_text AS 'dist_batch_status_name', 
					   [issuer].[issuer_id], [issuer].issuer_name, [issuer].issuer_code, 
					   --[issuer].auto_create_dist_batch,
					   [card_issue_method_language].language_text AS 'card_issue_method_name',
					   [dist_batch].card_issue_method_id, [dist_batch].dist_batch_type_id,
					   [product_flow].dist_batch_status_flow_id,
					   [product_flow].flow_dist_batch_statuses_id,
					   [product_flow].flow_dist_batch_type_id,
					   [product_flow].user_role_id,
					   [product_flow].reject_dist_batch_statuses_id,
					   ISNULL([branch].branch_name, '-') as branch_name, 
					   ISNULL([branch].branch_code,'') as branch_code, issuer_product.product_name as 'product_name',
					   '' as [username]
				FROM [dist_batch] 
					INNER JOIN [dist_batch_status_current]
						ON [dist_batch_status_current].dist_batch_id = [dist_batch].dist_batch_id
					INNER JOIN [dist_batch_statuses_language]
						ON [dist_batch_status_current].dist_batch_statuses_id = [dist_batch_statuses_language].dist_batch_statuses_id
							AND [dist_batch_statuses_language].language_id = @language_id
					--INNER JOIN [user_roles_branch]
					--	ON [dist_batch].branch_id = [user_roles_branch].branch_id
					--		AND [user_roles_branch].user_role_id IN ( 2, 4, 5, 11, 12 )								
					INNER JOIN [issuer]
						ON [issuer].issuer_id = [dist_batch].issuer_id
					INNER JOIN [card_issue_method_language]
						ON [dist_batch].card_issue_method_id = [card_issue_method_language].card_issue_method_id
							AND [card_issue_method_language].language_id = @language_id		

					LEFT OUTER JOIN [branch]
						ON [branch].branch_id = [dist_batch].branch_id	
					--LEFT OUTER JOIN [dist_batch_statuses_flow]
					--	ON [dist_batch_status_current].dist_batch_statuses_id = [dist_batch_statuses_flow].dist_batch_statuses_id
					--		AND [dist_batch].card_issue_method_id = [dist_batch_statuses_flow].card_issue_method_id
					--		AND [dist_batch_statuses_flow].dist_batch_type_id = [dist_batch].dist_batch_type_id	
					--LEFT OUTER JOIN [dist_batch_statuses_flow] as [issuer_flow]
					--	ON [dist_batch_status_current].dist_batch_statuses_id = [issuer_flow].dist_batch_statuses_id
					--		AND [dist_batch].card_issue_method_id = [issuer_flow].card_issue_method_id
					--		AND [issuer_flow].dist_batch_type_id = [dist_batch].dist_batch_type_id
					--		AND [issuer_flow].issuer_id = COALESCE(-1, [dist_batch].issuer_id)
					INNER JOIN [dist_batch_cards]
						 on [dist_batch].dist_batch_id=[dist_batch_cards].dist_batch_id
					INNER JOIN [cards] 
						ON [dist_batch_cards].card_id=cards.card_id
					INNER JOIN issuer_product 
						 ON cards.product_id = issuer_product.product_id
					LEFT OUTER JOIN [dist_batch_statuses_flow] AS [product_flow]
						ON (([dist_batch].dist_batch_type_id = 0 AND 
								[product_flow].dist_batch_status_flow_id = [issuer_product].production_dist_batch_status_flow)
							OR ([dist_batch].dist_batch_type_id = 1 AND 
								[product_flow].dist_batch_status_flow_id = [issuer_product].distribution_dist_batch_status_flow))
							AND [product_flow].dist_batch_statuses_id = [dist_batch_status_current].dist_batch_statuses_id
				WHERE 
					(([dist_batch].branch_id IS NULL 
						AND [dist_batch].issuer_id IN (SELECT issuer_id FROM [user_roles_issuer] WHERE user_role_id IN (1, 2, 4, 5, 11, 12, 13) AND [user_id] = @user_id))
					OR 
					  ([dist_batch].branch_id IS NOT NULL 
						AND ([dist_batch].branch_id IN (SELECT branch_id FROM [user_roles_branch] WHERE user_role_id IN (1, 2, 4, 5, 11, 12, 13) AND [user_id] = @user_id)
								OR
								[cards].origin_branch_id IN(SELECT branch_id FROM [user_roles_branch] WHERE user_role_id IN (2) AND [user_id] = @user_id))))
					--[user_roles_branch].[user_id] = @user_id
					AND ([dist_batch].dist_batch_reference like '%'+@dist_batch_reference+'%')
					--AND [dist_batch].dist_batch_reference LIKE COALESCE(@dist_batch_reference, [dist_batch].dist_batch_reference)
					AND [dist_batch_status_current].dist_batch_statuses_id = COALESCE(@dist_batch_statuses_id, [dist_batch_status_current].dist_batch_statuses_id)
					AND [dist_batch].card_issue_method_id = COALESCE(@card_issue_method_id, [dist_batch].card_issue_method_id)
					AND [dist_batch].dist_batch_type_id = COALESCE(@distBatchTypeId, [dist_batch].dist_batch_type_id)
					AND [dist_batch].date_created >= COALESCE(@date_start, [dist_batch].date_created)
					AND [dist_batch].date_created <= COALESCE(@date_end, [dist_batch].date_created)
					--AND [branch].branch_id = COALESCE(@branch_id, [branch].branch_id)
					--AND [branch].branch_status_id = 0	 
					AND [issuer].issuer_status_id = 0
					AND [issuer].issuer_id = COALESCE(@issuerId,  [issuer].issuer_id)
			) AS Src )
			SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
				,*
			FROM PAGE_ROWS
			WHERE ROW_NO BETWEEN @StartRow AND @EndRow
			ORDER BY date_created DESC, dist_batch_reference ASC

			--log the audit record		
			--EXEC usp_insert_audit @audit_user_id, 
			--					 1,
			--					 NULL, 
			--					 @audit_workstation, 
			--					 'Getting Distribution batches for user.', 
			--					 NULL, NULL, NULL, NULL

			COMMIT TRANSACTION [GET_DIST_BATCH_FOR_USER_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [GET_DIST_BATCH_FOR_USER_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Altering [dbo].[usp_get_export_batch_card_details]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Fetch all cards linked to export batch with their details
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_export_batch_card_details] 
	@export_batch_id bigint,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN

	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([cards].card_number)) AS 'card_number'
		, cards.card_request_reference AS card_reference_number
		, [cards].branch_id
		, [cards].card_id
		, [cards].card_issue_method_id
		, [cards].card_priority_id
		, [cards].card_request_reference
		, [cards].card_sequence
		, [cards].product_id
		, CONVERT(DATETIME,CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].card_activation_date)), 109) as 'card_activation_date'
		, CONVERT(DATETIME2,CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].card_expiry_date))) as 'card_expiry_date'
		, CONVERT(DATETIME,CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].card_production_date)), 109) as 'card_production_date'						
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([cards].pvv)) as 'pvv'
		--, [dist_batch].dist_batch_reference
		--, [dist_batch_cards].dist_batch_id
		--, [dist_batch_cards].dist_card_status_id
		--, [dist_card_statuses].dist_card_status_name
		, [cards].export_batch_id as dist_batch_id
		, 0 as dist_card_status_id
		, [customer_account].account_type_id
		, [customer_account].cms_id
		, [customer_account].contract_number
		, [customer_account].currency_id
		, [customer_account].customer_account_id
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_account_number)) as 'customer_account_number'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_first_name)) as 'customer_first_name'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_last_name)) as 'customer_last_name'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].customer_middle_name)) as 'customer_middle_name'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].name_on_card)) as 'name_on_card'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].Id_number)) as 'Id_number'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].contact_number)) as 'contact_number'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([customer_account].CustomerId)) as 'CustomerId'
		, [customer_account].customer_title_id
		, [customer_account].customer_type_id
		, [customer_account].date_issued
		, [customer_account].resident_id
		, [customer_account].[user_id]
		, [issuer].issuer_id
		, [issuer].issuer_code
		, [issuer].issuer_name
		, [branch].branch_code
		, [branch].branch_name
		, [issuer_product].[product_code]
		, [issuer_product].[sub_product_code]
		, [issuer_product].[product_name]
		, [issuer_product].[product_bin_code]
		, [issuer_product].[src1_id]
		, [issuer_product].[src2_id]
		, [issuer_product].[src3_id]
		, [issuer_product].[pan_length]
		, CONVERT(INT, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[PVKI]))) as 'PVKI'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[PVK])) as 'PVK'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[CVKA])) as 'CVKA'
		, CONVERT(VARCHAR(max),DECRYPTBYKEY([issuer_product].[CVKB])) as 'CVKB'
		, [issuer_product].[expiry_months]

	FROM 
		[cards]							
		INNER JOIN [branch]
			ON [cards].branch_id = [branch].branch_id
		INNER JOIN [issuer]
			ON [branch].issuer_id = [issuer].issuer_id
		INNER JOIN [issuer_product]
			ON [cards].product_id = [issuer_product].product_id
		LEFT OUTER JOIN [customer_account]
			ON [cards].card_id = [customer_account].card_id
	WHERE 
		[cards].export_batch_id = @export_batch_id
					
														   
	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;	

END
GO
PRINT N'Altering [dbo].[usp_get_invetorysummaryreport]...';


GO
-- =============================================
-- Author:		sandhya konduru
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec [usp_get_invetorysummaryreport] null,1
ALTER PROCEDURE [dbo].[usp_get_invetorysummaryreport]
	@branch_id int = null,
	@issuer_id int = null,
	@language_id int =null
	,@audit_user_id bigint
	,@audit_workstation varchar(100)
	AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	if(@issuer_id=-1 or @issuer_id=0)
	set @issuer_id=null

	if(@branch_id =0)
	set @branch_id=null

	SELECT INTERX.issuer_id,
		   branch_code,
		   INTERX.branch_id,
		   INTERX.statuses_name,
		   INTERX.statuses_id,
		   COUNT(INTER.card_id)	AS CardCount, issuer.issuer_code+'-'+ issuer.issuer_name as 'issuer_name'

	FROM 	 
		  (SELECT [branch].branch_id, [branch_card_status_current].branch_card_statuses_id as 'statuses_id', [branch_card_status_current].card_id
			FROM [branch_card_status_current]
					INNER JOIN [cards]
						ON [branch_card_status_current].card_id = [cards].card_id
					INNER JOIN [branch]
						ON [cards].branch_id = [branch].branch_id
							AND [branch].card_centre_branch_YN = 0
					WHERE    [branch].branch_status_id = 0
			) AS INTER
				RIGHT OUTER JOIN 			
			(SELECT issuer_id, branch_id, branch.branch_name+'-'+ branch_code as branch_code , [branch_card_statuses].branch_card_statuses_id as 'statuses_id', bcl.language_text as 'statuses_name',bcl.language_id
			 FROM	[branch], [branch_card_statuses]
			 inner join branch_card_statuses_language bcl on [branch_card_statuses].branch_card_statuses_id=bcl.branch_card_statuses_id
			 where branch.branch_status_id=0 AND branch.card_centre_branch_YN = 0
		 		) INTERX

			ON INTER.branch_id = INTERX.branch_id
				AND INTER.statuses_id = INTERX.statuses_id 				
	inner join issuer on issuer.issuer_id=INTERX.issuer_id

	WHERE INTERX.issuer_id = COALESCE(@issuer_id, INTERX.issuer_id)
		  AND INTERX.branch_id = COALESCE(@branch_id, INTERX.branch_id) and INTERX.language_id=@language_id
		  AND INTERX.statuses_id!=6 and INTERX.statuses_id!=7
		  AND INTERX.branch_code <> ''  
	GROUP BY INTERX.issuer_id, INTERX.branch_id, branch_code, statuses_name, INTERX.statuses_id,issuer_name,issuer_code
	ORDER BY issuer_name,issuer_code, INTERX.branch_code, INTERX.statuses_id

END
GO
PRINT N'Altering [dbo].[usp_get_issuecardsummaryreport]...';


GO
-- =============================================
-- Author:		sandhya konduru
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec [usp_get_invetorysummaryreport] null,1
ALTER PROCEDURE [dbo].[usp_get_issuecardsummaryreport]
	@branch_id int = null,
	@issuer_id int = null,
	@language_id int,
	@fromdate datetime,
	@todate datetime
	AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	if(@issuer_id = -1 or @issuer_id = 0)
	 set @issuer_id=null

	if(@branch_id  =0)
		set @branch_id = null

	SELECT INTERX.issuer_id,
		   branch_code,
		   INTERX.branch_id,
		   INTERX.card_issue_reason_id,
		   INTERX.card_issuer_reason_name,
		   COUNT(INTER.card_id)	AS CardCount,issuer.issuer_name as 'issuer_name'
	FROM 
		-- this sub select fetches all cards belonging to a branch and currently in issued status
		(SELECT [branch].branch_id, [branch_card_status_current].card_id, [customer_account].card_issue_reason_id
			FROM [branch_card_status_current] 
					INNER JOIN [customer_account]
						ON [customer_account].card_id = [branch_card_status_current].card_id 
					INNER JOIN [cards]
						ON [branch_card_status_current].card_id = [cards].card_id
					INNER JOIN [branch]
						ON [cards].branch_id = [branch].branch_id
			WHERE [branch_card_status_current].branch_card_statuses_id = 6
				  AND [branch_card_status_current].[status_date] >= @fromdate 
				  AND [branch_card_status_current].[status_date] <= @todate
		) AS INTER						
		RIGHT OUTER JOIN 		
		--This Sub Select creates a cartesian product of branch and card issue reason	
		(SELECT issuer_id, [branch].branch_id, branch.branch_name+'-'+ branch_code as branch_code, [card_issue_reason].[card_issue_reason_id],
				 language_text as 'card_issuer_reason_name'
			FROM [branch],[card_issue_reason]
					INNER JOIN [card_issue_reason_language]  
						ON [card_issue_reason].[card_issue_reason_id] = [card_issue_reason_language].[card_issue_reason_id]
						   AND [card_issue_reason_language].language_id = @language_id
						   Where    [branch].branch_status_id = 0
		 	)  INTERX
		ON INTER.branch_id = INTERX.branch_id
			AND INTER.[card_issue_reason_id] = INTERX.[card_issue_reason_id] 
			inner join issuer on issuer.issuer_id=INTERX.issuer_id
	WHERE INTERX.issuer_id = COALESCE(@issuer_id, INTERX.issuer_id)
		AND INTERX.branch_id = COALESCE(@branch_id,  INTERX.branch_id)	
		AND INTERX.branch_code <> '' 
	GROUP BY INTERX.issuer_id,  INTERX.branch_id,INTERX.branch_code,  INTERX.[card_issue_reason_id],INTERX.[card_issuer_reason_name],issuer_name
	ORDER BY issuer_name, INTERX.branch_code, INTERX.[card_issue_reason_id]
END
GO
PRINT N'Altering [dbo].[usp_get_load_batches]...';


GO
ALTER PROCEDURE [dbo].[usp_get_load_batches]
	@user_id bigint,
	@load_batch_reference VARCHAR(50) = NULL,
	@issuerId int,
	@load_batch_statuses_id int = NULL,
	@date_start DateTime = NULL,
	@date_end DateTime = NULL,
	@language_id INT,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	if(@issuerId=0)
	set @issuerId=null

	if(@load_batch_reference <>'' or @load_batch_reference<> null)
	set @load_batch_reference ='%'+@load_batch_reference+'%'

	BEGIN TRANSACTION [GET_LOAD_BATCHES]
		BEGIN TRY 
			
			IF @date_end IS NOT NULL
				SET @date_end = DATEADD(day, 1, @date_end)
			
			DECLARE @StartRow INT, @EndRow INT;			

			SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
			SET @EndRow = @StartRow + @RowsPerPage - 1;

			--append#1
			WITH cte AS (
				SELECT DISTINCT [load_batch].load_batch_id, [load_batch].load_date, [load_batch].load_batch_reference, 
									   [load_batch].no_cards, [load_batch_status_current].load_batch_statuses_id, 
									   [load_batch_status_current].status_notes, [load_batch_statuses_language].language_text AS 'load_batch_status_name',
									   [branch].[branch_code]+' '+ [branch].branch_name as 'BranchName'
								FROM [load_batch] 
									INNER JOIN [load_batch_status_current]
										ON [load_batch_status_current].load_batch_id = [load_batch].load_batch_id
									INNER JOIN [load_batch_statuses_language]
										ON [load_batch_status_current].load_batch_statuses_id = [load_batch_statuses_language].load_batch_statuses_id
										  AND  [load_batch_statuses_language].language_id = 0
									INNER JOIN [load_batch_cards]
										ON [load_batch_cards].load_batch_id = [load_batch].load_batch_id
									INNER JOIN [cards]
										ON [cards].card_id = [load_batch_cards].card_id
									INNER JOIN [branch]
										ON [cards].branch_id = [branch].branch_id
				WHERE 
					[load_batch].load_batch_reference LIKE (COALESCE(@load_batch_reference, REPLACE([load_batch].load_batch_reference, '[', '[['))) ESCAPE '['
					AND [branch].issuer_id = COALESCE(@issuerId,[branch].issuer_id)
					AND [load_batch_status_current].load_batch_statuses_id = COALESCE(@load_batch_statuses_id, [load_batch_status_current].load_batch_statuses_id)
					AND [load_batch].load_date BETWEEN COALESCE(@date_start, [load_batch].load_date)
													AND COALESCE(@date_end, [load_batch].load_date)
			),
			PAGE_ROWS	AS	(
				SELECT ROW_NUMBER() OVER(ORDER BY load_date ASC, load_batch_reference ASC) AS ROW_NO
						, COUNT(*) OVER() AS TOTAL_ROWS
						, *
				FROM( SELECT DISTINCT cte.load_batch_id, cte.load_date, cte.load_batch_reference, 
								cte.no_cards, cte.load_batch_statuses_id, 
								cte.status_notes
								,CASE WHEN cte_grp.grpcnt > 1 THEN '-' ELSE cte.BranchName END as BranchName
						FROM 
							(SELECT load_batch_id, count(*) as grpcnt 
							FROM cte GROUP BY load_batch_id ) as cte_grp
							INNER JOIN cte ON cte.load_batch_id = cte_grp.load_batch_id
					) AS Src )
			SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES,*
			FROM PAGE_ROWS
			WHERE ROW_NO BETWEEN @StartRow AND @EndRow
			ORDER BY load_date ASC, load_batch_reference ASC

			--log the audit record		
			--EXEC usp_insert_audit @audit_user_id, 
			--					 1,
			--					 NULL, 
			--					 @audit_workstation, 
			--					 'Getting Load batches.', 
			--					 NULL, NULL, NULL, NULL

			COMMIT TRANSACTION [GET_LOAD_BATCHES]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [GET_LOAD_BATCHES]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 		
END
GO
PRINT N'Altering [dbo].[usp_get_Spoilcardsummaryreport]...';


GO
-- =============================================
-- Author:		sandhya konduru
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================

ALTER PROCEDURE [dbo].[usp_get_Spoilcardsummaryreport]
	@branch_id int = null,
	@issuer_id int = null,
	@language_id int,
	@fromdate datetime,
	@todate datetime

	AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	if(@issuer_id = -1 or @issuer_id = 0)
	 set @issuer_id=null

	if(@branch_id  =0)
		set @branch_id = null

	SELECT INTERX.issuer_id,
		   INTERX.branch_code,
		   INTERX.branch_id,
		   INTERX.branch_card_code_id,
		   INTERX.Spoil_reason_name,
		   COUNT(INTER.card_id)	AS CardCount,issuer.issuer_name as 'issuer_name'
	FROM 
		-- this sub select fetches all cards belonging to a branch and currently in issued status
		(SELECT [branch].branch_id, [branch_card_status_current].card_id, [branch_card_status_current].branch_card_code_id
			FROM [branch_card_status_current] 
					INNER JOIN [customer_account]
						ON [customer_account].card_id = [branch_card_status_current].card_id 
					INNER JOIN [cards]
						ON [branch_card_status_current].card_id = [cards].card_id
					INNER JOIN [branch]
						ON [cards].branch_id = [branch].branch_id
			WHERE [branch_card_status_current].branch_card_statuses_id = 7
				  AND [branch_card_status_current].[status_date] >= @fromdate 
				  AND [branch_card_status_current].[status_date] <= @todate
		) AS INTER						
		RIGHT OUTER JOIN 		
		--This Sub Select creates a cartesian product of branch and card issue reason	
		(SELECT issuer_id, [branch].branch_id, branch.branch_name+'-'+ branch_code as branch_code, branch_card_codes.branch_card_code_id,
				 language_text as 'Spoil_reason_name'
			FROM [branch], branch_card_codes
					INNER JOIN branch_card_codes_language 
						ON branch_card_codes.branch_card_code_id = branch_card_codes_language.branch_card_code_id
						   AND branch_card_codes_language.language_id = @language_id 						  
						   and  branch_card_codes.is_exception = 1
						   Where    [branch].branch_status_id = 0
		 	)  INTERX
		ON INTER.branch_id = INTERX.branch_id
			AND INTER.branch_card_code_id = INTERX.branch_card_code_id 
			inner join issuer on issuer.issuer_id=INTERX.issuer_id
	WHERE INTERX.issuer_id = COALESCE(@issuer_id, INTERX.issuer_id)
		AND INTERX.branch_id = COALESCE(@branch_id,  INTERX.branch_id)	
		AND INTERX.branch_code <> '' 
	GROUP BY INTERX.issuer_id,  INTERX.branch_id,INTERX.branch_code,  INTERX.branch_card_code_id,INTERX.Spoil_reason_name,issuer_name
	ORDER BY issuer_name,  INTERX.branch_code, INTERX.branch_card_code_id
END
GO
PRINT N'Altering [dbo].[usp_get_terminal]...';


GO
-- =============================================
-- Author:		LTladi
-- Create date: 20150210
-- Description:	Search for terminal by branch or masterkey
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_terminal]
	@terminal_id INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN
		OPEN SYMMETRIC KEY Indigo_Symmetric_Key
		DECRYPTION BY CERTIFICATE Indigo_Certificate; 

    SELECT 
		[terminal_name]
		, [terminal_model]
		, CONVERT(varchar(max),DECRYPTBYKEY(terminals.device_id)) AS 'device_Id'
		, b.[branch_id]
		, CONVERT(varchar(max),DECRYPTBYKEY(m.masterkey)) AS 'masterkey'
		, i.issuer_id,m.masterkey_id
		, CONVERT(varchar(max),DECRYPTBYKEY(terminals.password)) AS 'password'
		,IsMacUsed
	FROM
		[terminals]
		INNER JOIN [masterkeys] m ON m.masterkey_id = terminal_masterkey_id
		INNER JOIN [branch] b ON b.[branch_id] = terminals.branch_id
		INNER JOIN [issuer] i ON i.issuer_id = b.issuer_id
	WHERE
		[terminal_id] = @terminal_id

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

	END

END
GO
PRINT N'Altering [dbo].[usp_pin_mailer_reprint_report]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_pin_mailer_reprint_report] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = NULL,
	@branch_id int = NULL,
	@date_from datetime,
	@date_to datetime,
	@audit_userid int=null,
	@audit_workstation nvarchar(50) =null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SET @date_to = DATEADD(d, 1, @date_to)

    OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

				SELECT DISTINCT
				CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_account_number)) AS customer_account_number,				
				[pin_batch].pin_batch_reference, [pin_batch].date_created,
				[issuer].issuer_name, [issuer].issuer_code, [branch].branch_name, branch.branch_code,
				CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_first_name))+''+CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_last_name)) as 'customer_name'
		FROM [cards]
				INNER JOIN [customer_account]
					ON [cards].card_id = [customer_account].card_id
				INNER JOIN [pin_batch_cards]
					ON [cards].card_id = [pin_batch_cards].card_id
				INNER JOIN [pin_batch]
					ON [pin_batch_cards].pin_batch_id = [pin_batch].pin_batch_id
					INNER JOIN [pin_mailer_reprint]	ON 	[pin_mailer_reprint].card_id=[pin_batch_cards].card_id		
				INNER JOIN [branch]
					ON [cards].branch_id = [branch].branch_id
				INNER JOIN [issuer]
					ON [branch].issuer_id = [issuer].issuer_id	
		WHERE [cards].card_issue_method_id = 0
				AND [issuer].issuer_id = COALESCE(@issuer_id, [issuer].issuer_id)
				AND [branch].branch_id = COALESCE(@branch_id, [branch].branch_id)
				AND [pin_batch].date_created >= @date_from
				AND [pin_batch].date_created <= @date_to
				AND [pin_batch].pin_batch_type_id=2 AND pin_mailer_reprint_status_id=1
		ORDER BY issuer_name, issuer_code, branch_name, branch_code, date_created,
				pin_batch_reference, customer_account_number

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_dist_batch_to_vault]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_dist_batch_to_vault] 
	-- Add the parameters for the stored procedure here
	@dist_batch_id bigint, 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @branch_card_status_id int = 0

	--Update the cards linked to the dist batch with the new status.
	UPDATE dist_batch_cards
	SET dist_card_status_id = 2
	WHERE dist_batch_id = @dist_batch_id

	--Insert cards into branch status as checked in.
	INSERT branch_card_status(branch_id, card_id, branch_card_statuses_id, status_date, [user_id])
	SELECT [cards].branch_id, [dist_batch_cards].card_id, @branch_card_status_id, GETDATE(), @audit_user_id
	FROM [dist_batch_cards] INNER JOIN [cards]
		ON [cards].card_id = [dist_batch_cards].card_id
	WHERE dist_batch_id = @dist_batch_id

	--Insert notifcations for cards at branch
	INSERT INTO [notification_branch_outbox] (branch_message_id, added_time, channel_id, card_id, branch_card_statuses_id, card_issue_method_id, issuer_id, language_id)
	SELECT NEWID(), GETDATE(), [notification_branch_messages].channel_id, [cards].card_id, @branch_card_status_id, [cards].card_issue_method_id, [branch].issuer_id, 0
	FROM [notification_branch_messages] INNER JOIN [branch]
			ON [notification_branch_messages].issuer_id = [branch].issuer_id
				AND [notification_branch_messages].branch_card_statuses_id = @branch_card_status_id		
		INNER JOIN [cards]
			ON [branch].branch_id = [cards].branch_id
				AND [notification_branch_messages].card_issue_method_id = [cards].card_issue_method_id
		INNER JOIN [dist_batch_cards]
			ON [cards].card_id = [dist_batch_cards].card_id
	WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id
		

	--Update the originating branch to the current branch.
	UPDATE [cards]
	SET origin_branch_id = [cards].branch_id
	FROM [cards]
		INNER JOIN [dist_batch_cards]
			ON [cards].card_id = [dist_batch_cards].card_id
	WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id 

END
GO
PRINT N'Altering [dbo].[usp_create_load_batch_bulk_card_request]...';


GO



-- =============================================
-- Author:		LTladi
-- Create date: 6 March 2014
-- Description:	Create's the load batch, load batch cards, load batch status and file history within a transaction.
-- =============================================
ALTER PROCEDURE [dbo].[usp_create_load_batch_bulk_card_request] 
	@load_batch_reference varchar(50),
	@batch_status_id int,
	@user_id bigint,	
	@load_card_status_id int,
	@load_batch_type_id int,
	@card_list AS [dbo].[load_bulk_card_request] READONLY,
	@product_fields as [dbo].[bi_key_binary_value_array] READONLY,
	@issuer_id int,
	@file_load_id INT,
	@name_of_file varchar(60),
	@file_created_date datetime,
	@file_size int,
	@load_date datetime,
	@file_status_id int,
	@file_directory varchar(110),
	@number_successful_records int,
	@number_failed_records int,
	@file_load_comments varchar(max),
	@file_type_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	--SET NOCOUNT ON;
	SET QUERY_GOVERNOR_COST_LIMIT 0;

	BEGIN TRANSACTION [CREATE_LOAD_REQUEST_BATCH_TRAN]
	BEGIN TRY 

		DECLARE @RC int
		DECLARE @file_id bigint
		DECLARE @load_batch_id bigint
		DECLARE @number_of_cards int
		DECLARE @load_batch_status_id bigint

		--Inserts should happen in the following order
		--1. file_history
		--2. load_batch
		--3. load_batch_status
		--4. cards
		--5. load_batch_cards

		SET @number_of_cards = (SELECT COUNT(*) FROM @card_list)

		--Insert into file history
		EXECUTE @RC = [dbo].[usp_insert_file_history] @file_load_id, @issuer_id,@name_of_file,@file_created_date
													,@file_size,@load_date,@file_status_id,@file_directory
													,@number_successful_records,@number_failed_records
													,@file_load_comments,@file_type_id,@file_id OUTPUT

		--Insert into load_batch
		EXECUTE @RC = [dbo].[usp_insert_load_batch] @load_batch_reference,@file_id,@issuer_id,@batch_status_id
												  ,@load_date,@number_of_cards,@load_batch_type_id, @load_batch_id OUTPUT

		--Insert into load_batch_status
		EXECUTE @RC = [dbo].[usp_insert_load_batch_status] @load_batch_id,@batch_status_id,@load_date
														 ,@user_id,@load_batch_status_id OUTPUT


		
		OPEN SYMMETRIC KEY Indigo_Symmetric_Key		
		DECRYPTION BY CERTIFICATE Indigo_Certificate
			DECLARE @objid int,
					@total_records int,
					@processed_records int = 0,
					@status_date DATETIME = GETDATE(),
					@processed_records_end int,
					@records_to_process int = 500 --Use this to tune the amount of records to load	

			--This section helps with creating the card_index, instead of calling the fuction each time
			--Which slows down the insers, we get the key and then just encrypt
			SET @objid = object_id('cards')			
			DECLARE @key varbinary(100)
			SET @key = null
			SELECT @key = DecryptByKeyAutoCert(cert_id('cert_ProtectIndexingKeys'), null, mac_key) 
			FROM mac_index_keys 
			WHERE table_id = @objid

			IF(@key IS NULL)
				RAISERROR (N'MAC Index Key is null.', 15, 1);

			--Determine the number of records
			SELECT @total_records = COUNT(*) FROM @card_list

			DECLARE @temp_customer_account TABLE (					
						[temp_customer_account_id] [bigint] NOT NULL,
						[card_id] [bigint] NOT NULL)

			--Used to link the actual customer account ID with the temp customer account id
			DECLARE @temp_link_customer TABLE (	
					[customer_account_id] [bigint] NOT NULL,					
					[temp_customer_account_id] [bigint] NOT NULL)

					DECLARE @temp_cards_to_process TABLE (	
			
					[temp_customer_account_id] [bigint] NULL,
	[card_number] [varchar](20) NULL,
	[reference_number] [varchar](100) NULL,
	[branch_id] [int] NULL,
	[product_id] [int] NULL,
	[card_priority_id] [int] NULL,
	[customer_account_number] [varchar](30) NULL,
	[domicile_branch_id] [int] NULL,
	[account_type_id] [int] NULL,
	[card_issue_reason_id] [int] NULL,
	[customer_first_name] [varchar](50) NULL,
	[customer_middle_name] [varchar](50) NULL,
	[customer_last_name] [varchar](50) NULL,
	[name_on_card] [varchar](100) NULL,
	[customer_title_id] [int] NULL,
	[currency_id] [int] NULL,
	[resident_id] [int] NULL,
	[customer_type_id] [int] NULL,
	[cms_id] [varchar](50) NULL,
	[contract_number] [varchar](50) NULL,
	[idnumber] [varchar](50) NULL,
	[contact_number] [varchar](50) NULL,
	[customer_id] [varchar](50) NULL,
	[fee_waiver_YN] [bit] NULL,
	[fee_editable_YN] [bit] NULL,
	[fee_charged] [decimal](10, 4) NULL,
	[fee_overridden_YN] [bit] NULL,
	[audit_user_id] [bigint] NULL,
	[audit_workstation] [varchar](100) NULL,
	[sub_product_id] [varchar](100) NULL,
	[load_product_batch_type_id] [int] NULL,
	[already_loaded] [bit] NULL,
	RowNum [int] not null
	)

	insert into @temp_cards_to_process
	SELECT *,ROW_NUMBER() OVER (ORDER BY reference_number) AS RowNum						
								 FROM @card_list

			--Insert new card records in batches
			WHILE (@processed_records < @total_records)
			BEGIN

				SET @processed_records_end = @processed_records + @records_to_process;

				DELETE FROM @temp_customer_account
				DELETE FROM @temp_link_customer

				MERGE [cards] AS cardsTable
				USING (SELECT * from
						@temp_cards_to_process AS cards_to_process
						 WHERE cards_to_process.RowNum BETWEEN @processed_records AND @processed_records_end
								AND cards_to_process.load_product_batch_type_id IN (5, 6)) AS cardList
				ON (cardsTable.card_request_reference = cardList.reference_number AND cardsTable.product_id = cardList.product_id) 
				WHEN NOT MATCHED BY TARGET THEN
					-- INSERT into Table1:
					INSERT ( [product_id], [ordering_branch_id], [branch_id], [origin_branch_id], [card_sequence], [card_index], [card_issue_method_id]
						, [card_priority_id], [fee_waiver_YN], [fee_editable_YN], [fee_charged], [fee_overridden_YN]
						, card_request_reference, card_number,delivery_branch_id)
					VALUES ( cardList.product_id, cardList.branch_id, cardList.branch_id, cardList.branch_id, 0, [dbo].[MAC]('0', @objid), 0
						, cardList.card_priority_id, cardList.fee_waiver_YN, cardList.fee_editable_YN, cardList.fee_charged, cardList.fee_overridden_YN
						, cardList.reference_number
						, ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR(MAX), cardList.card_number)),cardList.branch_id)
		   		OUTPUT					
					cardList.temp_customer_account_id					
					, inserted.card_id					
				INTO @temp_customer_account;			
				
				--Insert temp customers to actual table
				MERGE INTO [customer_account]
				USING (SELECT t2.*, t1.card_id
						FROM @temp_customer_account t1 INNER JOIN @card_list t2
								ON t1.temp_customer_account_id = t2.temp_customer_account_id
						) AS tca
				ON 1 = 0
				WHEN NOT MATCHED THEN
				  INSERT ([user_id],[card_id],[card_issue_reason_id],[account_type_id],[currency_id]
							,[resident_id],[customer_type_id],[customer_account_number]
							,[customer_first_name],[customer_middle_name],[customer_last_name]
							,[name_on_card],[date_issued],[cms_id],[contract_number],[customer_title_id]
							,[Id_number],[contact_number],[CustomerId],[domicile_branch_id])
					VALUES ([tca].audit_user_id,[tca].[card_id],[tca].[card_issue_reason_id],[tca].[account_type_id],[tca].[currency_id]
							,[tca].[resident_id],[tca].[customer_type_id]
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[customer_account_number]))
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[customer_first_name]))
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[customer_middle_name]))
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[customer_last_name]))
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[name_on_card]))
							,GETDATE(),[tca].[cms_id],[tca].[contract_number],[tca].[customer_title_id]
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[Idnumber]))
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[contact_number]))
							,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CONVERT(VARCHAR(MAX),[tca].[customer_id]))
							,[tca].[domicile_branch_id])			
				OUTPUT inserted.customer_account_id, tca.temp_customer_account_id
				INTO @temp_link_customer;

				--Insert Product Fields
				--INSERT INTO customer_fields (customer_account_id, product_field_id, value)
				--	SELECT [customer_account_id], [key2], [value]
				--	FROM @product_fields INNER JOIN @temp_link_customer
				--			ON temp_customer_account_id = key1

				--Update Product Image Fields
				INSERT INTO customer_fields (customer_account_id, product_field_id, value)
					SELECT tlc.[customer_account_id], pf.[key2], ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'), CAST(pf.[value] as varbinary(max)))
					FROM @product_fields pf INNER JOIN @temp_link_customer tlc
								ON tlc.temp_customer_account_id = pf.key1
							INNER JOIN product_fields
								ON pf.[key2] = product_fields.product_field_id
					WHERE product_fields.print_field_type_id = 0

				--Update Product Image Fields
				INSERT INTO customer_image_fields (customer_account_id, product_field_id, value)
					SELECT [customer_account_id], pf.[key2], pf.[value]
					FROM @product_fields pf INNER JOIN @temp_link_customer
								ON temp_customer_account_id = [key1]
							INNER JOIN product_fields
								ON pf.[key2] = product_fields.product_field_id
					WHERE product_fields.print_field_type_id = 1

				SET @processed_records = @processed_records_end
			END
			

			DECLARE @load_batch_records int = 0
			DECLARE @inserted_load_cards TABLE(load_batch_id bigint, card_id bigint, load_card_status_id int);

			--Insert into load_batch_cards, links cards to load batch
			INSERT INTO load_batch_cards ([load_batch_id], [card_id], [load_card_status_id])
			OUTPUT inserted.* INTO @inserted_load_cards
			SELECT @load_batch_id, cards.card_id, @load_card_status_id
			FROM cards 
				INNER JOIN (SELECT * FROM @card_list) as cardList
				ON cards.product_id = cardList.product_id
				AND cards.card_request_reference = cardList.reference_number
			--WHERE cards.card_request_reference IN (SELECT cardList.reference_number
			--										  FROM @card_list cardList
			--										  WHERE cardList.product_id = cards.product_id)
													  
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key
					
		SELECT @load_batch_records = COUNT(*) FROM @inserted_load_cards

		IF(@number_of_cards != @load_batch_records) 
			RAISERROR (N'Records inserted for loadbatch (%i) dont match those for the load (%i).', 15, 1, @load_batch_records, @number_of_cards);

		COMMIT TRANSACTION [CREATE_LOAD_REQUEST_BATCH_TRAN]

	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [CREATE_LOAD_REQUEST_BATCH_TRAN]
		RETURN ERROR_MESSAGE()
	END CATCH 

	RETURN '0'
END
GO
PRINT N'Altering [dbo].[usp_create_load_batch]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 6 March 2014
-- Description:	Create's the load batch, load batch cards, load batch status and file history within a transaction.
-- =============================================
ALTER PROCEDURE [dbo].[usp_create_load_batch] 
	@load_batch_reference varchar(50),
	@batch_status_id int,
	@user_id bigint,	
	@load_card_status_id int,
	@card_list AS dbo.load_cards_type READONLY,
	@issuer_id int,
	@file_load_id INT,
	@name_of_file varchar(60),
	@file_created_date datetime,
	@file_size int,
	@load_date datetime,
	@file_status_id int,
	@file_directory varchar(110),
	@number_successful_records int,
	@number_failed_records int,
	@file_load_comments varchar(max),
	@file_type_id int,
	@load_batch_type_id int,
	@file_id bigint = NULL OUTPUT,
	@load_batch_id bigint = NULL OUTPUT,
	@load_batch_status_id bigint = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	--SET NOCOUNT ON;
	SET QUERY_GOVERNOR_COST_LIMIT 0;

	BEGIN TRANSACTION [CREATE_LOAD_BATCH_TRAN]
	BEGIN TRY 

		DECLARE @RC int
		DECLARE @number_of_cards int

		--Inserts should happen in the following order
		--1. file_history
		--2. load_batch
		--3. load_batch_status
		--4. cards
		--5. load_batch_cards

		SET @number_of_cards = (SELECT COUNT(*) FROM @card_list)

		--Insert into file history
		EXECUTE @RC = [dbo].[usp_insert_file_history] @file_load_id, @issuer_id,@name_of_file,@file_created_date
													,@file_size,@load_date,@file_status_id,@file_directory
													,@number_successful_records,@number_failed_records
													,@file_load_comments,@file_type_id,@file_id OUTPUT

		--Insert into load_batch
		EXECUTE @RC = [dbo].[usp_insert_load_batch] @load_batch_reference,@file_id,@issuer_id,@batch_status_id
												  ,@load_date,@number_of_cards,@load_batch_type_id, @load_batch_id OUTPUT

		--Insert into load_batch_status
		EXECUTE @RC = [dbo].[usp_insert_load_batch_status] @load_batch_id,@batch_status_id,@load_date
														 ,@user_id,@load_batch_status_id OUTPUT

		
		OPEN SYMMETRIC KEY Indigo_Symmetric_Key		
		DECRYPTION BY CERTIFICATE Indigo_Certificate
			DECLARE @objid int,
					@total_records int,
					@processed_records int = 0,
					@status_date DATETIME = GETDATE(),
					@processed_records_end int,
					@records_to_process int = 500 --Use this to tune the amount of records to load	

			--This section helps with creating the card_index, instead of calling the fuction each time
			--Which slows down the insers, we get the key and then just encrypt
			SET @objid = object_id('cards')			
			DECLARE @key varbinary(100)
			SET @key = null
			SELECT @key = DecryptByKeyAutoCert(cert_id('cert_ProtectIndexingKeys'), null, mac_key) 
			FROM mac_index_keys 
			WHERE table_id = @objid

			IF(@key IS NULL)
				RAISERROR (N'MAC Index Key is null.', 15, 1);

			--Determin the number of records
			SELECT @total_records = COUNT(*) FROM @card_list

			--table car for storing the new card id's. used later when creating the ref numbers.
			DECLARE @new_card_id_list TABLE ( card_id bigint)

			--Insert new card records in batches
			WHILE (@processed_records < @total_records)
			BEGIN

				SET @processed_records_end = @processed_records + @records_to_process;

				MERGE [cards] AS cardsTable
				USING (SELECT *
						FROM (
								SELECT *, 
								ROW_NUMBER() OVER (ORDER BY card_number) AS RowNum
								 FROM @card_list								 
								 ) AS cards_to_process
						 WHERE cards_to_process.RowNum BETWEEN @processed_records AND @processed_records_end
								AND cards_to_process.load_batch_type_id IN (1, 2, 3))
								
						AS cardsList
				ON (DECRYPTBYKEY(cardsTable.card_number) = cardsList.card_number AND cardsTable.product_id = cardsList.product_id) 
				WHEN NOT MATCHED BY TARGET
					THEN INSERT ([product_id],[card_issue_method_id]
									,[ordering_branch_id],[branch_id],[origin_branch_id],[delivery_branch_id]
									,[card_number]
									,[card_sequence],[card_priority_id],[card_request_reference]
									,[card_expiry_date]
									,[card_index]) 
						VALUES(cardsList.product_id
							   --cardsList.sub_product_id,
							   ,cardsList.card_issue_method_id
							   ,cardsList.branch_id
							   ,cardsList.branch_id
							   ,cardsList.branch_id
							   ,cardsList.branch_id
							   ,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR,cardsList.card_number))
							   ,cardsList.card_sequence
							   ,1
							   ,cardsList.card_reference
							   ,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR,cardsList.[expiry_date]))
							   ,CONVERT(varbinary(24),HashBytes( N'SHA1', CONVERT(varbinary(8000), CONVERT(nvarchar(4000),RIGHT(cardsList.card_number, 4))) + @key )))
				OUTPUT inserted.card_id INTO @new_card_id_list;
				
				--Update with card reference number
				--UPDATE [cards]
				--	SET card_request_reference = dbo.GenCardReferenceNo(@status_date, [cards].card_id)
				--WHERE [card_id] IN (SELECT card_id FROM @new_card_id_list)

				DELETE FROM @new_card_id_list

				SET @processed_records = @processed_records_end
			END

			DECLARE @load_batch_records int = 0

			--Update ordered cards
			UPDATE cardsupdate
			SET cardsupdate.card_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR,card_list.card_number)),
				cardsupdate.card_expiry_date = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR,card_list.[expiry_date])),
				cardsupdate.card_request_reference = ISNULL(card_list.card_reference, cardsupdate.card_request_reference),
				cardsupdate.card_sequence = card_list.card_sequence,
				cardsupdate.branch_id = COALESCE(card_list.branch_id, cardsupdate.branch_id),
				cardsupdate.origin_branch_id = COALESCE(card_list.branch_id, cardsupdate.origin_branch_id),
				cardsupdate.card_index = CONVERT(varbinary(24),HashBytes( N'SHA1', CONVERT(varbinary(8000), CONVERT(nvarchar(4000),RIGHT(card_list.card_number, 4))) + @key ))
			FROM @card_list card_list
					INNER JOIN [cards] cardsupdate
						ON cardsupdate.card_id = card_list.card_id
			WHERE card_list.load_batch_type_id = 4


			DECLARE @inserted_load_cards TABLE(load_batch_id bigint, card_id bigint, load_card_status_id int);

			--Insert into load_batch_cards, links cards to load batch
			INSERT INTO load_batch_cards ([load_batch_id], [card_id], [load_card_status_id])
			OUTPUT inserted.* INTO @inserted_load_cards
			SELECT @load_batch_id, cards.card_id, @load_card_status_id
			FROM cards 
			WHERE cards.product_id IN (SELECT DISTINCT cards_list.product_id FROM @card_list cards_list)
			AND DECRYPTBYKEY(cards.card_number) IN (SELECT cards_list.card_number FROM @card_list cards_list)
			--	INNER JOIN (SELECT * FROM @card_list) as cardList
			--	ON cards.product_id = cardList.product_id
			--	AND DECRYPTBYKEY(cards.card_number) = cardList.card_number 
			--WHERE DECRYPTBYKEY(cards.card_number) IN (SELECT cards_list.card_number
			--										  FROM @card_list cards_list
			--										  WHERE cards_list.product_id = cards.product_id)

			--SELECT @load_batch_records = @@ROWCOUNT

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key
					
			--declare @audit_msg nvarchar(50)
			--SET @audit_msg = 'INSERT :' + CAST(@load_batch_reference AS varchar(max))  +', LOADED'
			----log the audit record		
			--EXEC usp_insert_audit @user_id, 
			--						5, --LoadBatch
			--						NULL, 
			--						'LOADED', 
			--						@audit_msg, 
			--						NULL, NULL, NULL, NULL		

			SELECT @load_batch_records = COUNT(*) FROM @inserted_load_cards

		IF(@number_of_cards != @load_batch_records) --@load_batch_records)
			RAISERROR (N'Records inserted for loadbatch (%i) dont match those for the load (%i).', 15, 1, @load_batch_records, @number_of_cards);

		COMMIT TRANSACTION [CREATE_LOAD_BATCH_TRAN]

	END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [CREATE_LOAD_BATCH_TRAN]
		RETURN ERROR_MESSAGE()
	END CATCH 

	RETURN '0'
END
GO
PRINT N'Altering [dbo].[usp_get_status_flow_roles]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_status_flow_roles] 
	@role_list AS dbo.key_value_array READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    SELECT [dist_batch_statuses_flow].*, [dist_batch_status_flow].*
	FROM [dist_batch_status_flow] INNER JOIN [dist_batch_statuses_flow]
			ON [dist_batch_status_flow].dist_batch_status_flow_id = [dist_batch_statuses_flow].dist_batch_status_flow_id
		INNER JOIN @role_list roles
			ON  [dist_batch_statuses_flow].user_role_id = roles.[key]
END
GO
PRINT N'Altering [dbo].[usp_get_productlist]...';


GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_productlist]
	@issuer_id int =null,
	@card_issue_method_id int = null,
	@Deleted_YN bit = NULL,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @StartRow INT, @EndRow INT;			

	SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
	SET @EndRow = @StartRow + @RowsPerPage - 1;

	WITH PAGE_ROWS
	AS
	(
	SELECT ROW_NUMBER() OVER(ORDER BY product_name ASC) AS ROW_NO
			, COUNT(*) OVER() AS TOTAL_ROWS
			, *
	FROM(
		SELECT DISTINCT issuer_product.product_code,
			   issuer_product.product_name,
			   issuer_product.product_id,
			   issuer_product.product_bin_code,			   
			   issuer_product.issuer_id, 
			   issuer_product.pan_length,
			   issuer_product.sub_product_code,
			   issuer_product.pin_calc_method_id,
			   issuer_product.auto_approve_batch_YN,
			   issuer_product.account_validation_YN,
			   issuer_product.name_on_card_top,                
			   issuer_product.name_on_card_left, 
			   issuer_product.Name_on_card_font_size, 
			   issuer_product.font_id, 
			   Issuer_product_font.font_name, 
               Issuer_product_font.resource_path,
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.PVK)) as PVK, 
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.PVKI)) as PVKI, 
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.CVKB)) as CVKB, 			   
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.CVKA)) as CVKA,
			   src1_id, src2_id, src3_id,
			   issuer_product.expiry_months,
			   issuer_product.fee_scheme_id,
			   issuer_product.enable_instant_pin_YN,
			   issuer_product.min_pin_length,
			   issuer_product.max_pin_length,
			   issuer_product.enable_instant_pin_reissue_YN,
			   issuer_product.cms_exportable_YN,
			   issuer_product.product_load_type_id,
			   issuer_product.pin_mailer_printing_YN,
			   issuer_product.pin_mailer_reprint_YN,
			   issuer_product.card_issue_method_id,
			   issuer_product.charge_fee_to_issuing_branch_YN,
			   issuer_product.production_dist_batch_status_flow,
			   issuer_product.distribution_dist_batch_status_flow,
			     CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.decimalisation_table)) as decimalisation_table, 
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.pin_validation_data)) as pin_validation_data,
			   pin_block_formatid,
			   issuer_product.DeletedYN,
			   issuer_product.print_issue_card_YN,
			   [issuer_product].allow_manual_uploaded_YN,
			   [issuer_product].allow_reupload_YN	
		FROM issuer_product 
				INNER JOIN Issuer_product_font 
					ON issuer_product.font_id = Issuer_product_font.font_id	
		WHERE issuer_product.issuer_id= @issuer_id 
				AND issuer_product.DeletedYN = COALESCE(@Deleted_YN, issuer_product.DeletedYN)
				AND card_issue_method_id = COALESCE(@card_issue_method_id, card_issue_method_id)
						
		)
		AS Src )
	SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
		,*
	FROM PAGE_ROWS
	WHERE ROW_NO BETWEEN @StartRow AND @EndRow
	ORDER BY product_name ASC
END
GO
PRINT N'Altering [dbo].[usp_get_products_by_bincode]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Fetch products that match the BIN. 
-- Only products that are active and have an active issuer are returned
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_products_by_bincode] 
	-- Add the parameters for the stored procedure here
	@bin_code char(6),
	@issuer_id int = null,
	@only_active_records bit
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

    SELECT [issuer_product].product_id,
			[issuer_product].product_code,
			[issuer_product].product_name,
			[issuer_product].product_bin_code,
			ISNULL([issuer_product].sub_product_code, '') as sub_product_code,
			[issuer_product].card_issue_method_id,
			[issuer_product].product_load_type_id,
			[issuer_product].DeletedYN,
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].CVKA)) as CVKA, 
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].CVKB)) as CVKB, 
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].PVK)) as PVK, 
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].PVKI)) as PVKI,
			[issuer_product].src1_id, [issuer_product].src2_id, [issuer_product].src3_id,
			[issuer_product].issuer_id,
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].decimalisation_table)) as decimalisation_table,
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].pin_validation_data)) as pin_validation_data,
			pin_block_formatid,
			pin_calc_method_id
	FROM [issuer_product]
			INNER JOIN [issuer]
				ON [issuer].issuer_id = [issuer_product].issuer_id					
	WHERE [issuer_product].product_bin_code = @bin_code
			AND [issuer_product].issuer_id = COALESCE(@issuer_id, [issuer_product].issuer_id)
			AND ((@only_active_records = 0) OR (@only_active_records = 1
												AND [issuer_product].DeletedYN = 0
												AND [issuer].issuer_status_id = 0))

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_user_roles_for_user]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 11 March 2014
-- Description:	Get all the roles linked to the specified user.
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_user_roles_for_user]
	@user_id bigint
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT [user_group].user_role_id, [issuer].issuer_id, [issuer].issuer_name, [issuer].issuer_code,
			[issuer].maker_checker_YN, 
			[issuer].classic_card_issue_YN, [issuer].instant_card_issue_YN, [issuer].card_ref_preference,
			[issuer].enable_instant_pin_YN, [issuer].authorise_pin_issue_YN, [issuer].authorise_pin_reissue_YN,			
			[issuer].back_office_pin_auth_YN,
			[user_roles].allow_multiple_login, 
			[user_group].can_read, [user_group].can_create, [user_group].can_update,
			CAST(CASE WHEN 1 = ANY (SELECT [issuer_product].account_validation_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS account_validation_YN,
			CAST(CASE WHEN 1 = ALL (SELECT [issuer_product].auto_approve_batch_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS auto_create_dist_batch
						
			,CAST(CASE WHEN 1 = ANY (SELECT [issuer_product].pin_mailer_printing_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS pin_mailer_printing_YN
			,CAST(CASE WHEN 1 = ANY (SELECT [issuer_product].pin_mailer_reprint_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS pin_mailer_reprint_YN

			,CAST(CASE WHEN 0 = ANY (SELECT [issuer_product].enable_instant_pin_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS enable__product_instant_pin_YN
			,CAST(CASE WHEN 0 = ANY (SELECT [issuer_product].enable_instant_pin_reissue_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS enable_instant_pin_reissue_YN

			,CAST(CASE WHEN 0 = ANY (SELECT [issuer_product].cms_exportable_YN FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS cms_exportable_YN

			,CAST(CASE WHEN 0 <> ANY (SELECT [issuer_product].product_load_type_id FROM [issuer_product] WHERE [issuer_product].issuer_id = [issuer].issuer_id AND [issuer_product].DeletedYN = 0)
				THEN 1 ELSE 0 END as BIT) AS EnableCardFileLoader_YN

	FROM [user_group] 
			INNER JOIN [users_to_users_groups] 
				ON [user_group].user_group_id = [users_to_users_groups].user_group_id
			INNER JOIN [user_roles]
				ON [user_group].user_role_id = [user_roles].user_role_id
			INNER JOIN [user] 
				ON [user].[user_id] = [users_to_users_groups].[user_id]			 
			INNER JOIN [issuer] 
				ON [user_group].issuer_id = [issuer].issuer_id
	WHERE [user].[user_id] = @user_id
		  AND [issuer].issuer_status_id = 0
		  AND [user].user_status_id = 0
	GROUP BY [user_group].user_role_id, [issuer].issuer_id, [issuer].issuer_name, [issuer].issuer_code,
			[issuer].maker_checker_YN, 
			[issuer].classic_card_issue_YN, [issuer].instant_card_issue_YN, [issuer].card_ref_preference,
			[issuer].enable_instant_pin_YN, [issuer].authorise_pin_issue_YN, [issuer].authorise_pin_reissue_YN,
			[issuer].back_office_pin_auth_YN, [user_roles].allow_multiple_login, 
			[user_group].can_read, [user_group].can_create, [user_group].can_update
END
GO
PRINT N'Altering [dbo].[usp_getProductbyProductid]...';


GO

-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_getProductbyProductid]
	@productid int 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

    -- Insert statements for procedure here
	SELECT issuer_product.product_code,
			   issuer_product.product_name,
			   issuer_product.product_id,
			   issuer_product.product_bin_code,
			   issuer_product.issuer_id, 
			   issuer_product.sub_product_code,
			   issuer_product.pan_length,
			   issuer_product.pin_calc_method_id,
			   issuer_product.auto_approve_batch_YN,
			   issuer_product.account_validation_YN,
			   issuer_product.name_on_card_top,                
			   issuer_product.name_on_card_left, 
			   issuer_product.Name_on_card_font_size, 
			   issuer_product.font_id, 
			   Issuer_product_font.font_name, 
               Issuer_product_font.resource_path, 
			   issuer_product.enable_instant_pin_YN,
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.PVK)) as PVK, 
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.PVKI)) as PVKI, 
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.CVKB)) as CVKB, 			   
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.CVKA)) as CVKA,
			   src1_id, src2_id, src3_id,
			   issuer_product.expiry_months,
			   issuer_product.fee_scheme_id,
			   issuer_product.charge_fee_to_issuing_branch_YN,
			   issuer_product.min_pin_length,
			   issuer_product.max_pin_length,
			   issuer_product.enable_instant_pin_reissue_YN,
			   issuer_product.cms_exportable_YN,
			   issuer_product.product_load_type_id,
			   issuer_product.pin_mailer_printing_YN,
			   issuer_product.pin_mailer_reprint_YN,
			   issuer_product.card_issue_method_id,
			   issuer_product.production_dist_batch_status_flow,
			   issuer_product.distribution_dist_batch_status_flow,
			   issuer_product.print_issue_card_YN,
			   issuer_product.allow_manual_uploaded_YN,
			   issuer_product.allow_reupload_YN,
				0 as TOTAL_ROWS, 
				CONVERT(bigint, 0) AS ROW_NO,
				0 as TOTAL_PAGES,
				     CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.decimalisation_table)) as decimalisation_table, 
			   CONVERT(VARCHAR(max),DECRYPTBYKEY(issuer_product.pin_validation_data)) as pin_validation_data,
			   pin_block_formatid,
			   issuer_product.DeletedYN
	FROM issuer_product 
			INNER JOIN Issuer_product_font 
				ON issuer_product.font_id = Issuer_product_font.font_id			
	WHERE issuer_product.product_id  = @productid

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

END
GO
PRINT N'Altering [dbo].[usp_get_product_fee_charges]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_product_fee_charges] 
	-- Add the parameters for the stored procedure here
	@fee_detail_id int,
	@card_issue_reason_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT [currency].*
		, ISNULL([product_fee_charge].fee_charge, 0) as fee_charge
		, ISNULL([product_fee_charge].vat, 0) as vat
	FROM [currency]	
			LEFT OUTER JOIN [product_fee_charge]
				ON [currency].currency_id = [product_fee_charge].currency_id
					AND [product_fee_charge].fee_detail_id = @fee_detail_id
					AND [product_fee_charge].card_issue_reason_id = @card_issue_reason_id
END
GO
PRINT N'Altering [dbo].[usp_get_reportfields_Labels]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================

ALTER PROCEDURE [dbo].[usp_get_reportfields_Labels]
	@languageId int=null,
	@ReportId int=null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
--	SELECT        report_fields.reportfieldid, reportfields_language.language_text
--FROM            reports INNER JOIN
--                         report_reportfields ON reports.Reportid = report_reportfields.reportid INNER JOIN
--                         report_fields ON report_reportfields.reportfieldid = report_fields.reportfieldid INNER JOIN
--                         reportfields_language ON report_reportfields.reportfieldid = reportfields_language.reportfieldid

--						 where reportfields_language.[language_id]=@languageid and reports.[Reportid]=@reportid

select Reportid,col1,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11,col12,col13,col14,col15,col16,col17,col18,col19,col20,col21
from
(
SELECT       reports.Reportid, reportfields_language.language_text ,
'col'+CAST( Row_Number() over (partition by  reports.Reportid order by  report_reportfields.[reportfieldorderno]) as varchar(10)) as columnsequence
FROM            reports INNER JOIN
                         report_reportfields ON reports.Reportid = report_reportfields.reportid INNER JOIN
                         report_fields ON report_reportfields.reportfieldid = report_fields.reportfieldid INNER JOIN
                         reportfields_language ON report_reportfields.reportfieldid = reportfields_language.reportfieldid

						 where reportfields_language.[language_id]=@languageId and  reports.Reportid=@ReportId
) 	 Temp
				
				
PIVOT
(
		max(language_text) 
		for columnsequence in (col1,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11,col12,col13,col14,col15,col16,col17,col18,col19,col20,col21)

)PIV
END
GO
PRINT N'Altering [dbo].[usp_get_user_for_login]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 20 March 2014
-- Description:	Gets a user for login purposes.
-- =============================================
ALTER PROCEDURE [dbo].[usp_get_user_for_login] 
	-- Add the parameters for the stored procedure here
	@username varchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

		--Update locked out user status if the locked out time has expired
		UPDATE [user]
		SET user_status_id = 0
			, number_of_incorrect_logins = 0
		WHERE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].[username])) = @username 
			AND [user].[user_status_id] = 3
			AND [user].[last_login_attempt] <= (SELECT DATEADD(HOUR, [user_admin].[PasswordAttemptLockoutDuration] * -1, GETDATE())
												FROM [user_admin])

		--There should only be one result
		SELECT TOP 1 [user].[user_id]						
			,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].[username])) as 'clr_username'
			,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].[password])) as 'clr_password'
			,[user].[online]    
			,[user].[workstation]
			,[user].last_login_attempt
			,[user].last_password_changed_date
			,[user].number_of_incorrect_logins
			,[user].language_id
			,[user].[connection_parameter_id]	
			,[user].user_status_id
			,[connection_parameters].address as domain_hostname_or_ip
			,[connection_parameters].domain_name
			,[connection_parameters].[path] as domain_path
			,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([connection_parameters].username)) as domain_username	
			,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([connection_parameters].[password])) as domain_password,
			[connection_parameters].connection_parameter_type_id, [connection_parameters].port,
			[connection_parameters].is_external_auth,[user].external_interface_id,auth_type,protocol,[path]								
		FROM [user] 
			LEFT OUTER JOIN [connection_parameters]
				ON [user].[connection_parameter_id] = [connection_parameters].[connection_parameter_id]
		WHERE CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].[username])) = @username

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Altering [dbo].[usp_get_userbyroles_auditreport]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec usp_get_userbyroles_auditreport -1 ,null,null,null
ALTER PROCEDURE [dbo].[usp_get_userbyroles_auditreport]
@issuer_id int=null,
@user_group_id int =null,
@user_role_id int =null,
--@user_id int=null,
@audit_user_id bigint,
@audit_workstation varchar(100)

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
		OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;
	if(@issuer_id=-1 or @issuer_id=0)
	set @issuer_id=null

	SELECT        ug.user_group_name, user_roles.user_role, issuer.issuer_code+'-'+ issuer.issuer_name as 'issuer_name', ug.mask_screen_pan, ug.mask_report_pan, ug.can_read, ug.can_update, ug.can_delete, 
                         ug.all_branch_access, CONVERT(VARCHAR(max),DECRYPTBYKEY([user].username)) as 'username','' as branch_name, ug.can_create
FROM            user_group AS ug INNER JOIN
                         issuer ON ug.issuer_id = issuer.issuer_id INNER JOIN
                         user_roles ON ug.user_role_id = user_roles.user_role_id INNER JOIN
                         users_to_users_groups ON ug.user_group_id = users_to_users_groups.user_group_id INNER JOIN
                         [user] ON users_to_users_groups.user_id = [user].user_id

	 WHERE ug.issuer_id = COALESCE(@issuer_id, ug.issuer_id)
			and ug.user_group_id =COALESCE(@user_group_id, ug.user_group_id)
			and ug.user_role_id=COALESCE(@user_role_id, ug.user_role_id)
			--and [user].user_id=COALESCE(@user_id, [user].user_id)
					
	ORDER BY 	issuer.issuer_name,ug.user_group_name,user_roles.user_role,username

  CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;
END
GO
PRINT N'Altering [dbo].[usp_insert_product_external_systems]...';


GO
-- =============================================
-- Author:		sandhya
-- Create date: <Create Date,,>
-- Description:Inserting external fields to product
-- =============================================
ALTER PROCEDURE [dbo].[usp_insert_product_external_systems] 
	-- Add the parameters for the stored procedure here
	@product_id int,
	@external_system_fields as dbo.[product_external_fields_array] READONLY,	
	@audit_user_id BIGINT,
	@audit_workstation varchar(100)
AS
BEGIN
	
	SET NOCOUNT ON;

	

			INSERT INTO product_external_system
						(product_id, external_system_field_id, field_value)
			SELECT @product_id, esx.external_system_field_id, field_value
			FROM @external_system_fields esx

			

END
GO
PRINT N'Altering [dbo].[usp_lang_lookup_external_system_types]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_lang_lookup_external_system_types]
		@language_id int, 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT [external_system_type_id] AS lookup_id, language_text
	FROM external_system_types_language
	WHERE language_id = @language_id
END
GO
PRINT N'Altering [dbo].[usp_search_export_batches]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Search for export batches based on filter criteria
-- =============================================
ALTER PROCEDURE [dbo].[usp_search_export_batches] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = null,
	@product_id int = null,
	@export_batch_statuses_id int = null,
	@date_from datetime2 = null,
	@date_to datetime2 = null,
	@language_id int = 0,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF @date_to IS NOT NULL
	SET @date_to = DATEADD(day, 1, @date_to)

	SELECT [export_batch_status_current].*, 
			[export_batch].date_created,
			[export_batch].batch_reference
	FROM [export_batch]
		INNER JOIN [export_batch_status_current]
			ON [export_batch].export_batch_id = [export_batch_status_current].export_batch_id
		INNER JOIN [export_batch_statuses_language]
			ON [export_batch_statuses_language].export_batch_statuses_id = [export_batch_status_current].export_batch_statuses_id
				AND [export_batch_statuses_language].language_id = @language_id
	WHERE [export_batch].issuer_id = COALESCE(@issuer_id, [export_batch].issuer_id)
		AND [export_batch].date_created BETWEEN COALESCE(@date_from, [export_batch].date_created) AND COALESCE(@date_to, [export_batch].date_created)
		AND	[export_batch_status_current].export_batch_statuses_id = COALESCE(@export_batch_statuses_id, [export_batch_status_current].export_batch_statuses_id)
		AND((@product_id IS NULL) OR ([export_batch].export_batch_id IN (SELECT export_batch_id FROM [cards] where product_id = @product_id)))
END
GO
PRINT N'Creating [dbo].[usp_create_product_fee_accounting]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_create_product_fee_accounting] 
	-- Add the parameters for the stored procedure here
	@fee_accounting_name varchar(150),
    @issuer_id int,
    @fee_revenue_account_no varchar(100),
    @fee_revenue_account_type_id int,
	@fee_revenue_branch_code varchar(10),
    @fee_revenue_narration_en varchar(150),
    @fee_revenue_narration_fr varchar(150),
    @fee_revenue_narration_pt varchar(150),
    @fee_revenue_narration_es varchar(150),
    @vat_account_no varchar(100),
    @vat_account_type_id int,
    @vat_account_branch_code varchar(10),
    @vat_narration_en varchar(150),
    @vat_narration_fr varchar(150),
    @vat_narration_pt varchar(150),
    @vat_narration_es varchar(150),
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@new_fee_accounting_id int OUTPUT,
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF (SELECT COUNT(*) FROM [product_fee_accounting] WHERE [fee_accounting_name] = @fee_accounting_name AND [issuer_id] = @issuer_id) > 0
		BEGIN
			SET @new_fee_accounting_id = 0
			SET @ResultCode = 229						
		END
	ELSE
	BEGIN 
		BEGIN TRANSACTION [INSERT_ACCOUNTING_TRAN]
		BEGIN TRY 
			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

			INSERT INTO [dbo].[product_fee_accounting]
				   ([fee_accounting_name]
				   ,[issuer_id]
				   ,[fee_revenue_account_no]
				   ,[fee_revenue_account_type_id]
				   ,[fee_revenue_branch_code]
				   ,[fee_revenue_narration_en]
				   ,[fee_revenue_narration_fr]
				   ,[fee_revenue_narration_pt]
				   ,[fee_revenue_narration_es]
				   ,[vat_account_no]
				   ,[vat_account_type_id]
				   ,[vat_account_branch_code]
				   ,[vat_narration_en]
				   ,[vat_narration_fr]
				   ,[vat_narration_pt]
				   ,[vat_narration_es])
			 VALUES
				   (@fee_accounting_name,
					@issuer_id,
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@fee_revenue_account_no)),
					@fee_revenue_account_type_id,
					@fee_revenue_branch_code,
					@fee_revenue_narration_en,
					@fee_revenue_narration_fr,
					@fee_revenue_narration_pt,
					@fee_revenue_narration_es,
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@vat_account_no)),
					@vat_account_type_id,
					@vat_account_branch_code,
					@vat_narration_en,
					@vat_narration_fr,
					@vat_narration_pt,
					@vat_narration_es)

				SET @new_fee_accounting_id = SCOPE_IDENTITY();

				CLOSE SYMMETRIC KEY Indigo_Symmetric_Key ;--Closes sym key

				--log the audit record
				DECLARE @audit_description varchar(max)
				SELECT @audit_description = 'Fee Accounting Created: ' + @fee_accounting_name
											+ ', Id: ' + CAST(@new_fee_accounting_id as varchar(max))

				EXEC usp_insert_audit @audit_user_id, 
										9,
										NULL, 
										@audit_workstation, 
										@audit_description, 
										NULL, NULL, NULL, NULL		

				SET @ResultCode = 0
				COMMIT TRANSACTION [INSERT_ACCOUNTING_TRAN]

			END TRY
		BEGIN CATCH
			ROLLBACK TRANSACTION [INSERT_ACCOUNTING_TRAN]
			DECLARE @ErrorMessage NVARCHAR(4000);
			DECLARE @ErrorSeverity INT;
			DECLARE @ErrorState INT;

			SELECT 
				@ErrorMessage = ERROR_MESSAGE(),
				@ErrorSeverity = ERROR_SEVERITY(),
				@ErrorState = ERROR_STATE();

			RAISERROR (@ErrorMessage, -- Message text.
						@ErrorSeverity, -- Severity.
						@ErrorState -- State.
						);
		END CATCH 	
	END
END
GO
PRINT N'Creating [dbo].[usp_delete_notification_batch]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_delete_notification_batch]
@issuer_id int ,
@dist_batch_type_id int ,
@dist_batch_statuses_id int ,
@channel_id int,
@audit_user_id bigint,
@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	    BEGIN TRANSACTION [DELETE_NOTIFICATIONS_BATCH_TRAN]
		BEGIN TRY 
			DELETE FROM notification_batch_messages WHERE issuer_id=@issuer_id AND
													dist_batch_type_id=@dist_batch_type_id AND 
													dist_batch_statuses_id=@dist_batch_statuses_id AND
													channel_id=@channel_id

			COMMIT TRANSACTION [DELETE_NOTIFICATIONS_BATCH_TRAN]

  END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [DELETE_NOTIFICATIONS_BATCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Creating [dbo].[usp_delete_notification_branch]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_delete_notification_branch]
@issuer_id int ,
@branch_card_statuses_id int ,
@card_issue_method_id int ,
@channel_id int,
@audit_user_id bigint,
@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	    BEGIN TRANSACTION [DELETE_NOTIFICATIONS_BRANCH_TRAN]
		BEGIN TRY 
			DELETE FROM notification_branch_messages WHERE issuer_id=@issuer_id AND
													card_issue_method_id=@card_issue_method_id AND 
													branch_card_statuses_id=@branch_card_statuses_id AND
													channel_id=@channel_id

			COMMIT TRANSACTION [DELETE_NOTIFICATIONS_BRANCH_TRAN]

  END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [DELETE_NOTIFICATIONS_BRANCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Creating [dbo].[usp_delete_product_fee_accounting]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_delete_product_fee_accounting] 
	-- Add the parameters for the stored procedure here
	@fee_accounting_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),	
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--Check that fee schemes arent using this fee_accounting_id
	IF (SELECT COUNT(*) FROM [product_fee_scheme] WHERE [fee_accounting_id] = @fee_accounting_id) > 0
		BEGIN
			SET @ResultCode = 230						
		END
	ELSE
	BEGIN 
		BEGIN TRANSACTION [DELETE_ACCOUNTING_TRAN]
		BEGIN TRY 

				DELETE FROM[dbo].[product_fee_accounting]			   
				WHERE [fee_accounting_id] = @fee_accounting_id

				--log the audit record
				DECLARE @audit_description varchar(max)
				SELECT @audit_description = 'Fee Accounting Deleted: Id: ' + CAST(@fee_accounting_id as varchar(max))

				EXEC usp_insert_audit @audit_user_id, 
										9,
										NULL, 
										@audit_workstation, 
										@audit_description, 
										NULL, NULL, NULL, NULL		

				SET @ResultCode = 0
				COMMIT TRANSACTION [DELETE_ACCOUNTING_TRAN]

			END TRY
		BEGIN CATCH
			ROLLBACK TRANSACTION [DELETE_ACCOUNTING_TRAN]
			DECLARE @ErrorMessage NVARCHAR(4000);
			DECLARE @ErrorSeverity INT;
			DECLARE @ErrorState INT;

			SELECT 
				@ErrorMessage = ERROR_MESSAGE(),
				@ErrorSeverity = ERROR_SEVERITY(),
				@ErrorState = ERROR_STATE();

			RAISERROR (@ErrorMessage, -- Message text.
						@ErrorSeverity, -- Severity.
						@ErrorState -- State.
						);
		END CATCH 	
	END
END
GO
PRINT N'Creating [dbo].[usp_get_dist_batch_flows]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_dist_batch_flows] 
	-- Add the parameters for the stored procedure here
	@card_issue_method_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT *
	FROM [dist_batch_status_flow]
	WHERE card_issue_method_id = @card_issue_method_id

END
GO
PRINT N'Creating [dbo].[usp_get_notification_batch]...';


GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_notification_batch]
@issuer_id int ,
@dist_batch_type_id int,
@dist_batch_statuses_id int,
@channel_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

SELECT        notification_batch_messages.issuer_id, notification_batch_messages.dist_batch_type_id, notification_batch_messages.dist_batch_statuses_id, notification_batch_messages.language_id, 
                         notification_batch_messages.channel_id, notification_batch_messages.notification_text, notification_batch_messages.subject_text, languages.language_name
FROM            notification_batch_messages INNER JOIN
                         dist_batch_type ON notification_batch_messages.dist_batch_type_id = dist_batch_type.dist_batch_type_id INNER JOIN
                         dist_batch_statuses ON notification_batch_messages.dist_batch_statuses_id = dist_batch_statuses.dist_batch_statuses_id INNER JOIN
                         issuer ON notification_batch_messages.issuer_id = issuer.issuer_id INNER JOIN
                         languages ON notification_batch_messages.language_id = languages.id
						 
						where notification_batch_messages.issuer_id=COALESCE(notification_batch_messages.issuer_id, @issuer_id)
						and notification_batch_messages.dist_batch_type_id=@dist_batch_type_id
						and notification_batch_messages.dist_batch_statuses_id=@dist_batch_statuses_id
						and notification_batch_messages.channel_id=@channel_id

END
GO
PRINT N'Creating [dbo].[usp_get_notification_batch_List]...';


GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_notification_batch_List]
@issuer_id int =null,
@PageIndex INT = 1,
@RowsPerPage INT = 20
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
DECLARE @StartRow INT, @EndRow INT;			


	SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
	SET @EndRow = @StartRow + @RowsPerPage - 1;

	WITH PAGE_ROWS
	AS
	(
	SELECT ROW_NUMBER() OVER(ORDER BY issuer_name ASC) AS ROW_NO
			, COUNT(*) OVER() AS TOTAL_ROWS
			, *
	FROM(
		SELECT distinct     notification_batch_messages.issuer_id, notification_batch_messages.dist_batch_type_id, notification_batch_messages.dist_batch_statuses_id,  issuer.issuer_name+'-'+ issuer.issuer_code as 'issuer_name', dist_batch_type.dist_batch_type_name, dist_batch_statuses.dist_batch_status_name,channel_id
FROM            notification_batch_messages INNER JOIN
                         dist_batch_type ON notification_batch_messages.dist_batch_type_id = dist_batch_type.dist_batch_type_id INNER JOIN
                         dist_batch_statuses ON notification_batch_messages.dist_batch_statuses_id = dist_batch_statuses.dist_batch_statuses_id INNER JOIN
                         issuer ON notification_batch_messages.issuer_id = issuer.issuer_id
						where notification_batch_messages.issuer_id=COALESCE(notification_batch_messages.issuer_id,@issuer_id)
		)
		AS Src )
	SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
		,*
	FROM PAGE_ROWS
	WHERE ROW_NO BETWEEN @StartRow AND @EndRow
	ORDER BY issuer_name ASC
END
GO
PRINT N'Creating [dbo].[usp_get_notification_branch]...';


GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_notification_branch]
@issuer_id int ,
@branch_card_statuses_id int,
@card_issue_method_id int,
@channel_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT       notification_branch_messages.issuer_id, notification_branch_messages.card_issue_method_id, notification_branch_messages.branch_card_statuses_id,notification_branch_messages.[language_id],[channel_id],[notification_text],[subject_text],languages.language_name

FROM            notification_branch_messages INNER JOIN
                         branch_card_statuses ON notification_branch_messages.branch_card_statuses_id = branch_card_statuses.branch_card_statuses_id INNER JOIN
                         card_issue_method ON notification_branch_messages.card_issue_method_id = card_issue_method.card_issue_method_id INNER JOIN
                         issuer ON notification_branch_messages.issuer_id = issuer.issuer_id
						   inner join languages ON notification_branch_messages.language_id = languages.id
						where notification_branch_messages.issuer_id=@issuer_id 
						and notification_branch_messages.branch_card_statuses_id=@branch_card_statuses_id
						and notification_branch_messages.card_issue_method_id=@card_issue_method_id
						and notification_branch_messages.channel_id=@channel_id

END
GO
PRINT N'Creating [dbo].[usp_get_notification_branch_List]...';


GO


-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_notification_branch_List]
@issuer_id int =null,
@PageIndex INT = 1,
@RowsPerPage INT = 20
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
DECLARE @StartRow INT, @EndRow INT;			

	SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
	SET @EndRow = @StartRow + @RowsPerPage - 1;

	WITH PAGE_ROWS
	AS
	(
	SELECT ROW_NUMBER() OVER(ORDER BY issuer_name ASC) AS ROW_NO
			, COUNT(*) OVER() AS TOTAL_ROWS
			, *
	FROM(
		SELECT   distinct    notification_branch_messages.issuer_id, notification_branch_messages.card_issue_method_id, notification_branch_messages.branch_card_statuses_id, issuer.issuer_name+'-'+ issuer.issuer_code as 'issuer_name',issuer.issuer_code, branch_card_statuses.branch_card_statuses_name, card_issue_method.card_issue_method_name,channel_id
FROM            notification_branch_messages INNER JOIN
                         branch_card_statuses ON notification_branch_messages.branch_card_statuses_id = branch_card_statuses.branch_card_statuses_id INNER JOIN
                         card_issue_method ON notification_branch_messages.card_issue_method_id = card_issue_method.card_issue_method_id INNER JOIN
                         issuer ON notification_branch_messages.issuer_id = issuer.issuer_id
						where notification_branch_messages.issuer_id=COALESCE(notification_branch_messages.issuer_id,@issuer_id)
		)
		AS Src )
	SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
		,*
	FROM PAGE_ROWS
	WHERE ROW_NO BETWEEN @StartRow AND @EndRow
	ORDER BY issuer_name ASC
END
GO
PRINT N'Creating [dbo].[usp_get_product_fee_accounting]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_product_fee_accounting] 
	-- Add the parameters for the stored procedure here
	@fee_accounting_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;


	SELECT [fee_accounting_id]
      ,[fee_accounting_name]
      ,[issuer_id]      
      ,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([fee_revenue_account_no])) as [fee_revenue_account_no]
      ,[fee_revenue_account_type_id]
	  ,[fee_revenue_branch_code]
      ,[fee_revenue_narration_en]
      ,[fee_revenue_narration_fr]
      ,[fee_revenue_narration_pt]
      ,[fee_revenue_narration_es]
      ,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([vat_account_no])) as [vat_account_no]
      ,[vat_account_type_id]
      ,[vat_account_branch_code]
      ,[vat_narration_en]
      ,[vat_narration_fr]
      ,[vat_narration_pt]
      ,[vat_narration_es]
	  ,0 as TOTAL_ROWS
	  ,CONVERT(bigint, 0) AS ROW_NO
	  ,0 as TOTAL_PAGES
	FROM [product_fee_accounting]
	WHERE fee_accounting_id = @fee_accounting_id

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

END
GO
PRINT N'Creating [dbo].[usp_get_product_fee_accounting_list]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_product_fee_accounting_list] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = NULL,
	@PageIndex INT = 1,
	@RowsPerPage INT = 20,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	DECLARE @StartRow INT, @EndRow INT;			

	SET @StartRow = ((@PageIndex - 1) * @RowsPerPage) + 1;
	SET @EndRow = @StartRow + @RowsPerPage - 1;

	WITH PAGE_ROWS
	AS
	(
	SELECT ROW_NUMBER() OVER(ORDER BY [fee_accounting_name] ASC) AS ROW_NO
			, COUNT(*) OVER() AS TOTAL_ROWS
			, *
	FROM(
		SELECT [fee_accounting_id]
		  ,[fee_accounting_name]
		  ,[issuer_id]      
		  ,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([fee_revenue_account_no])) as [fee_revenue_account_no]
		  ,[fee_revenue_account_type_id]
		  ,[fee_revenue_branch_code]
		  ,[fee_revenue_narration_en]
		  ,[fee_revenue_narration_fr]
		  ,[fee_revenue_narration_pt]
		  ,[fee_revenue_narration_es]
		  ,CONVERT(VARCHAR(MAX),DECRYPTBYKEY([vat_account_no])) as [vat_account_no]
		  ,[vat_account_type_id]
		  ,[vat_account_branch_code]
		  ,[vat_narration_en]
		  ,[vat_narration_fr]
		  ,[vat_narration_pt]
		  ,[vat_narration_es]
		FROM [product_fee_accounting]
		WHERE issuer_id = COALESCE(@issuer_id, issuer_id)
	)
		AS Src )
	SELECT CAST(CEILING(TOTAL_ROWS/ CAST(@RowsPerPage AS DECIMAL(20,2))) AS INT) AS TOTAL_PAGES
		,*
	FROM PAGE_ROWS
	WHERE ROW_NO BETWEEN @StartRow AND @EndRow
	ORDER BY [fee_accounting_name] ASC

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

END
GO
PRINT N'Creating [dbo].[usp_get_products_for_export]...';


GO
-- =============================================
-- Author:		Lebo Tladi
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_get_products_for_export] 
	-- Add the parameters for the stored procedure here
	@issuer_id int = null,
	@only_active_records bit
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

    SELECT [issuer_product].product_id,
			[issuer_product].product_code,
			[issuer_product].product_name,
			[issuer_product].product_bin_code,
			ISNULL([issuer_product].sub_product_code, '') as sub_product_code,
			[issuer_product].card_issue_method_id,
			[issuer_product].product_load_type_id,
			[issuer_product].DeletedYN,
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].CVKA)) as CVKA, 
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].CVKB)) as CVKB, 
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].PVK)) as PVK, 
			CONVERT(VARCHAR(MAX),DECRYPTBYKEY([issuer_product].PVKI)) as PVKI,
			[issuer_product].src1_id, [issuer_product].src2_id, [issuer_product].src3_id,
			[issuer_product].issuer_id
	FROM [issuer_product]
			INNER JOIN [issuer]
				ON [issuer].issuer_id = [issuer_product].issuer_id					
	WHERE [issuer_product].issuer_id = COALESCE(@issuer_id, [issuer_product].issuer_id)
			AND [issuer_product].cms_exportable_YN = 1
			AND ((@only_active_records = 0) OR (@only_active_records = 1
												AND [issuer_product].DeletedYN = 0
												AND [issuer].issuer_status_id = 0))

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Creating [dbo].[usp_insert_notification_batch]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_insert_notification_batch] 
@issuer_id int ,
@dist_batch_type_id int ,
@dist_batch_statuses_id int ,
@channel_id int ,
@notifications_lang_messages AS notifications_lang_messages READONLY,
@audit_user_id bigint,
@audit_workstation varchar(100),
@ResultCode int output
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  
  BEGIN TRANSACTION [INSERT_NOTIFICATIONS_BATCH_TRAN]
		BEGIN TRY 
		IF (SELECT COUNT(*) FROM notification_batch_messages WHERE (dist_batch_type_id = @dist_batch_type_id and channel_id = @channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 0
				BEGIN
					SET @ResultCode = 805						
				END
			ELSE IF (SELECT COUNT(*) FROM notification_batch_messages WHERE (dist_batch_statuses_id = @dist_batch_statuses_id and channel_id= @channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 0
				BEGIN
					SET @ResultCode = 806
				END
			ELSE
			BEGIN
		INSERT INTO notification_batch_messages
                         (issuer_id, dist_batch_type_id, dist_batch_statuses_id, language_id, channel_id, notification_text, subject_text)
		SELECT @issuer_id,@dist_batch_type_id,@dist_batch_statuses_id,nlm.language_id,@channel_id,nlm.notification_text,nlm.subject_text
		FROM @notifications_lang_messages  nlm

					SET @ResultCode = 0

			COMMIT TRANSACTION [INSERT_NOTIFICATIONS_BATCH_TRAN]
			END
  END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [INSERT_NOTIFICATIONS_BATCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Creating [dbo].[usp_insert_notification_branch]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_insert_notification_branch] 
@issuer_id int ,
@branch_card_statuses_id int ,
@card_issue_method_id int ,
@channel_id int ,
@notifications_lang_messages AS notifications_lang_messages READONLY,
@audit_user_id bigint,
@audit_workstation varchar(100),
@ResultCode int output
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	BEGIN TRANSACTION [INSERT_NOTIFICATIONS_BRANCH_TRAN]
		BEGIN TRY 
		IF (SELECT COUNT(*) FROM notification_branch_messages WHERE (card_issue_method_id = @card_issue_method_id AND channel_id=@channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 0
				BEGIN
					SET @ResultCode = 803						
				END
			ELSE IF (SELECT COUNT(*) FROM notification_branch_messages WHERE (branch_card_statuses_id = @branch_card_statuses_id AND channel_id=@channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 0
				BEGIN
					SET @ResultCode = 804
				END
			ELSE
			BEGIN
		INSERT INTO notification_branch_messages
                         (issuer_id, card_issue_method_id, branch_card_statuses_id, language_id, channel_id, notification_text, subject_text)
		SELECT @issuer_id,@card_issue_method_id,@branch_card_statuses_id,nlm.language_id,@channel_id,nlm.notification_text,nlm.subject_text
		FROM @notifications_lang_messages  nlm
					SET @ResultCode = 0

		COMMIT TRANSACTION [INSERT_NOTIFICATIONS_BRANCH_TRAN]
		END
  END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [INSERT_NOTIFICATIONS_BRANCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Creating [dbo].[usp_notification_batch_add]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Adds notification message for batch
-- =============================================
CREATE PROCEDURE [dbo].[usp_notification_batch_add]
	-- Add the parameters for the stored procedure here
	@dist_batch_id bigint,
	@dist_batch_statuses_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [notification_batch_outbox] (batch_message_id, added_time, channel_id, dist_batch_id, dist_batch_type_id, dist_batch_statuses_id, issuer_id, language_id)
	SELECT NEWID(), GETDATE(), [notification_batch_messages].channel_id, @dist_batch_id, [dist_batch].dist_batch_type_id, @dist_batch_statuses_id, [dist_batch].issuer_id, 0
	FROM [notification_batch_messages] INNER JOIN [dist_batch]
		ON [notification_batch_messages].issuer_id = [dist_batch].issuer_id
			AND [notification_batch_messages].dist_batch_type_id = [dist_batch].dist_batch_type_id
	WHERE [dist_batch].dist_batch_id = @dist_batch_id AND dist_batch_statuses_id = @dist_batch_statuses_id
END
GO
PRINT N'Creating [dbo].[usp_notification_branch_add]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Adds notification message for batch
-- =============================================
CREATE PROCEDURE [dbo].[usp_notification_branch_add]
	-- Add the parameters for the stored procedure here
	@card_id bigint,
	@branch_card_statuses_id int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	INSERT INTO [notification_branch_outbox] (branch_message_id, added_time, channel_id, card_id, branch_card_statuses_id, card_issue_method_id, issuer_id, language_id)
	SELECT NEWID(), GETDATE(), [notification_branch_messages].channel_id, @card_id, @branch_card_statuses_id, [cards].card_issue_method_id, [branch].issuer_id, 0
	FROM [notification_branch_messages] INNER JOIN [branch]
			ON [notification_branch_messages].issuer_id = [branch].issuer_id				
		INNER JOIN [cards]
			ON [branch].branch_id = [cards].branch_id
				AND [notification_branch_messages].card_issue_method_id = [cards].card_issue_method_id
	WHERE [cards].card_id = @card_id 
		AND [notification_branch_messages].branch_card_statuses_id = @branch_card_statuses_id
		
END
GO
PRINT N'Creating [dbo].[usp_notifications_batch_log]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_notifications_batch_log]
	@message_list AS dbo.[notification_array] READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [LOG_BATCH_NOTIF]
		BEGIN TRY 

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

			--Store messages
			INSERT INTO [notification_batch_log] (added_time, dist_batch_id, issuer_id, dist_batch_statuses_id, channel_id, notification_text)
			SELECT GETDATE(), dist_batch_id, issuer_id, dist_batch_statuses_id, channel_id, ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),msg_list.message_text)) 
			FROM [notification_batch_outbox]
				INNER JOIN @message_list msg_list
					ON [notification_batch_outbox].batch_message_id = msg_list.message_id
	 
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

			--Remove them from outbox
			DELETE FROM [notification_batch_outbox]
			WHERE batch_message_id IN (SELECT message_id FROM @message_list)

			COMMIT TRANSACTION [LOG_BATCH_NOTIF]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [LOG_BATCH_NOTIF]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Creating [dbo].[usp_notifications_batch_outbox]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_notifications_batch_outbox]
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT [notification_batch_outbox].issuer_id
			, [notification_batch_outbox].batch_message_id 
			, [dist_batch_statuses_flow].user_role_id
			, [dist_batch].dist_batch_type_id
			, [dist_batch].dist_batch_reference
			, [notification_batch_outbox].dist_batch_statuses_id
			, [notification_batch_messages].notification_text
			, [notification_batch_messages].subject_text
			, [notification_batch_messages].channel_id
	FROM [notification_batch_outbox]
		INNER JOIN [dist_batch]
			ON [dist_batch].dist_batch_id = [notification_batch_outbox].dist_batch_id
		INNER JOIN [dist_batch_statuses_flow]
			ON [dist_batch_statuses_flow].flow_dist_batch_statuses_id = [notification_batch_outbox].dist_batch_statuses_id
				--AND [dist_batch_statuses_flow].card_issue_method_id = [dist_batch].card_issue_method_id
				--AND ([dist_batch_statuses_flow].issuer_id = [dist_batch].issuer_id OR
						--[dist_batch_statuses_flow].issuer_id = -1)
		INNER JOIN [user_roles]
			ON [user_roles].user_role_id = [dist_batch_statuses_flow].user_role_id
		INNER JOIN [notification_batch_messages]
			ON [notification_batch_messages].issuer_id = [notification_batch_outbox].issuer_id AND
				[notification_batch_messages].dist_batch_statuses_id = [notification_batch_outbox].dist_batch_statuses_id AND				
				[notification_batch_messages].language_id = [notification_batch_outbox].language_id AND
				[notification_batch_messages].channel_id = [notification_batch_outbox].channel_id


	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Creating [dbo].[usp_notifications_batch_userlist]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_notifications_batch_userlist]
	@issuer_id int,
	@user_role_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].first_name)) as 'first_name', 
		   CONVERT(VARCHAR(MAX),DECRYPTBYKEY([user].last_name)) as 'last_name', 
		   [user].user_email
	FROM [user_group]
		INNER JOIN [users_to_users_groups]
			ON [users_to_users_groups].user_group_id = [user_group].user_group_id
				AND [user_group].user_role_id = @user_role_id
				AND  [user_group].issuer_id = @issuer_id
				AND [user_group].can_update = 1
				AND [user_group].can_create = 1
		INNER JOIN [user]
			ON [user].[user_id] = [users_to_users_groups].[user_id]
				AND [user].user_status_id = 0

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Creating [dbo].[usp_notifications_branch_log]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_notifications_branch_log]
	@message_list AS dbo.[notification_array] READONLY,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [LOG_BRANCH_NOTIF]
		BEGIN TRY 

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

			--Store messages
			INSERT INTO [notification_branch_log] (added_time, card_id, issuer_id, branch_card_statuses_id, channel_id, notification_text)
			SELECT GETDATE(), card_id, issuer_id, branch_card_statuses_id, channel_id, ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),msg_list.message_text)) 
			FROM [notification_branch_outbox]
				INNER JOIN @message_list msg_list
					ON [notification_branch_outbox].branch_message_id = msg_list.message_id
	 
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key

			--Remove them from outbox
			DELETE FROM [notification_branch_outbox]
			WHERE branch_message_id IN (SELECT message_id FROM @message_list)

			COMMIT TRANSACTION [LOG_BRANCH_NOTIF]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [LOG_BRANCH_NOTIF]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 
END
GO
PRINT N'Creating [dbo].[usp_notifications_branch_outbox]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_notifications_branch_outbox]
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	OPEN SYMMETRIC KEY Indigo_Symmetric_Key
	DECRYPTION BY CERTIFICATE Indigo_Certificate;

	SELECT [notification_branch_outbox].issuer_id
			, [notification_branch_outbox].branch_message_id 
			, [cards].card_request_reference
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].Id_number)) as 'id_number'
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].contact_number)) as 'contact_number'
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_first_name)) as 'customer_first_name'
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_middle_name)) as 'customer_middle_name'
			, CONVERT(VARCHAR(MAX),DECRYPTBYKEY([customer_account].customer_last_name)) as 'customer_last_name'
			, [customer_title_language].language_text AS 'customer_title_name'
			, [notification_branch_messages].notification_text
			, [notification_branch_messages].subject_text
			, [notification_branch_messages].channel_id
	FROM [notification_branch_outbox]
		INNER JOIN [cards]
			ON [cards].card_id = [notification_branch_outbox].card_id		
		INNER JOIN [notification_branch_messages]
			ON [notification_branch_messages].issuer_id = [notification_branch_outbox].issuer_id AND
				[notification_branch_messages].branch_card_statuses_id = [notification_branch_outbox].branch_card_statuses_id AND
				[notification_branch_messages].card_issue_method_id = [notification_branch_outbox].card_issue_method_id AND
				[notification_branch_messages].language_id = [notification_branch_outbox].language_id AND
				[notification_branch_messages].channel_id = [notification_branch_outbox].channel_id
		LEFT OUTER JOIN [customer_account]
			ON [customer_account].card_id = [notification_branch_outbox].card_id
		LEFT OUTER JOIN [customer_title_language]
			ON [customer_title_language].customer_title_id = [customer_account].customer_title_id
				AND [customer_title_language].language_id = [notification_branch_outbox].language_id

	CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
END
GO
PRINT N'Creating [dbo].[usp_outstanding_order_cards]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_outstanding_order_cards]
	-- Add the parameters for the stored procedure here
	@dist_batch_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT *
	FROM [dist_batch_cards]
	WHERE [dist_batch_id] = @dist_batch_id
END
GO
PRINT N'Creating [dbo].[usp_outstanding_orders]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_outstanding_orders]
	-- Add the parameters for the stored procedure here
	@product_id int,
	@number_of_cards int,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT DISTINCT [dist_batch].* 
	FROM [dist_batch] 
		INNER JOIN [dist_batch_status_current]
			ON [dist_batch_status_current].[dist_batch_id] = [dist_batch].[dist_batch_id]
				AND [dist_batch].dist_batch_type_id = 0
				AND [dist_batch_status_current].[dist_batch_statuses_id] = 11 
		INNER JOIN [dist_batch_cards]
			ON [dist_batch].[dist_batch_id] = [dist_batch_cards].[dist_batch_id]
		INNER JOIN [cards]
			ON [cards].[card_id] = [dist_batch_cards].[card_id]
		INNER JOIN [issuer_product]
			ON [issuer_product].[product_id] = [cards].[product_id]
				AND [issuer_product].DeletedYN = 0
				AND [issuer_product].product_load_type_id = 4
		INNER JOIN [issuer]
			ON [issuer].issuer_id = [dist_batch].[issuer_id]
				AND [issuer].issuer_status_id = 0
	WHERE [issuer_product].[product_id] = @product_id
		  AND [dist_batch].no_cards = @number_of_cards
END
GO
PRINT N'Creating [dbo].[usp_update_notification_batch]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_update_notification_batch] 
@issuer_id int ,
@dist_batch_type_id int ,
@dist_batch_statuses_id int ,
@channel_id INT,
@notifications_lang_messages AS notifications_lang_messages READONLY,
@audit_user_id bigint,
@audit_workstation varchar(100),
@ResultCode int output
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  

		BEGIN TRY 
		IF (SELECT COUNT(dist_batch_type_id) FROM notification_batch_messages WHERE (dist_batch_type_id = @dist_batch_type_id AND channel_id=@channel_id AND  [issuer_id] = @issuer_id and language_id=0)) >1
				BEGIN
					SET @ResultCode = 805						
				END
			ELSE IF (SELECT COUNT(dist_batch_type_id) FROM notification_batch_messages WHERE (dist_batch_statuses_id = @dist_batch_statuses_id AND channel_id=@channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 1
				BEGIN
					SET @ResultCode = 806
				END
			ELSE
			BEGIN
			  BEGIN TRANSACTION [UPDATE_NOTIFICATIONS_BATCH_TRAN]
			UPDATE notification_batch_messages
                         SET issuer_id =@issuer_id, 
						 dist_batch_type_id=@dist_batch_type_id, 
						 dist_batch_statuses_id=@dist_batch_statuses_id,
						  language_id =nlm.language_id, 
						  channel_id=@channel_id, 
						  notification_text=nlm.notification_text,
						   subject_text=nlm.subject_text		
					FROM @notifications_lang_messages  nlm
					INNER JOIN notification_batch_messages ON  nlm.language_id =notification_batch_messages.language_id
					and notification_batch_messages.issuer_id=@issuer_id
					SET @ResultCode = 0

			COMMIT TRANSACTION [UPDATE_NOTIFICATIONS_BATCH_TRAN]
			END
  END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_NOTIFICATIONS_BATCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Creating [dbo].[usp_update_notification_branch]...';


GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [dbo].[usp_update_notification_branch] 
@issuer_id int ,
@branch_card_statuses_id int ,
@card_issue_method_id int ,
@channel_id INT,
@notifications_lang_messages AS notifications_lang_messages READONLY,
@audit_user_id bigint,
@audit_workstation varchar(100),
@ResultCode int output
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	BEGIN TRANSACTION [UPDATE_NOTIFICATIONS_BRANCH_TRAN]
		BEGIN TRY 
		IF (SELECT COUNT(*) FROM notification_branch_messages WHERE (card_issue_method_id = @card_issue_method_id AND channel_id=@channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 1
				BEGIN
					SET @ResultCode = 803						
				END
			ELSE IF (SELECT COUNT(*) FROM notification_branch_messages WHERE (branch_card_statuses_id = @branch_card_statuses_id AND channel_id=@channel_id AND [issuer_id] = @issuer_id and language_id=0)) > 1
				BEGIN
					SET @ResultCode = 804
				END
			ELSE
			BEGIN
				UPDATE notification_branch_messages
                         SET issuer_id =@issuer_id, 
						 card_issue_method_id=@card_issue_method_id, 
						 branch_card_statuses_id=@branch_card_statuses_id,
						  language_id =nlm.language_id, 
						  channel_id=@channel_id, 
						  notification_text=nlm.notification_text,
						   subject_text=nlm.subject_text		
					FROM @notifications_lang_messages  nlm
					INNER JOIN notification_batch_messages ON  nlm.language_id =notification_batch_messages.language_id
					and notification_batch_messages.issuer_id=@issuer_id
					SET @ResultCode = 0


		COMMIT TRANSACTION [UPDATE_NOTIFICATIONS_BRANCH_TRAN]
		END
  END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_NOTIFICATIONS_BRANCH_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	
END
GO
PRINT N'Creating [dbo].[usp_update_pan]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_update_pan] 
	@pan varchar(19),
	@expiry_date Datetime2,
	@card_id bigint,
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [UPDATE_PAN_TRAN]
		BEGIN TRY 
		
			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

				UPDATE [cards]
				SET	[cards].card_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@pan)),
					[cards].card_expiry_date = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@expiry_date))
				WHERE card_id = @card_id

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key
				
			COMMIT TRANSACTION [UPDATE_PAN_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_PAN_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Creating [dbo].[usp_update_product_fee_accounting]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [dbo].[usp_update_product_fee_accounting] 
	-- Add the parameters for the stored procedure here
	@fee_accounting_id int,
	@fee_accounting_name varchar(150),
    @issuer_id int,
    @fee_revenue_account_no varchar(100),
    @fee_revenue_account_type_id int,
	@fee_revenue_branch_code varchar(10),
    @fee_revenue_narration_en varchar(150),
    @fee_revenue_narration_fr varchar(150),
    @fee_revenue_narration_pt varchar(150),
    @fee_revenue_narration_es varchar(150),
    @vat_account_no varchar(100),
    @vat_account_type_id int,
    @vat_account_branch_code varchar(10),
    @vat_narration_en varchar(150),
    @vat_narration_fr varchar(150),
    @vat_narration_pt varchar(150),
    @vat_narration_es varchar(150),
	@audit_user_id bigint,
	@audit_workstation varchar(100),	
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF (SELECT COUNT(*) FROM [product_fee_accounting] WHERE [fee_accounting_name] = @fee_accounting_name 
																AND [issuer_id] = @issuer_id
																AND [fee_accounting_id] != @fee_accounting_id) > 0
		BEGIN
			SET @ResultCode = 229						
		END
	ELSE
	BEGIN 
		BEGIN TRANSACTION [UPDATE_ACCOUNTING_TRAN]
		BEGIN TRY 
			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate;

			UPDATE [dbo].[product_fee_accounting]
			   SET [fee_accounting_name] = @fee_accounting_name
				  ,[issuer_id] = @issuer_id
				  ,[fee_revenue_account_no] = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@fee_revenue_account_no))
				  ,[fee_revenue_account_type_id] = @fee_revenue_account_type_id
				  ,[fee_revenue_branch_code] = @fee_revenue_branch_code
				  ,[fee_revenue_narration_en] = @fee_revenue_narration_en
				  ,[fee_revenue_narration_fr] = @fee_revenue_narration_fr
				  ,[fee_revenue_narration_pt] = @fee_revenue_narration_pt
				  ,[fee_revenue_narration_es] = @fee_revenue_narration_es
				  ,[vat_account_no] = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@vat_account_no))
				  ,[vat_account_type_id] = @vat_account_type_id
				  ,[vat_account_branch_code] = @vat_account_branch_code
				  ,[vat_narration_en] = @vat_narration_en
				  ,[vat_narration_fr] = @vat_narration_fr
				  ,[vat_narration_pt] = @vat_narration_pt
				  ,[vat_narration_es] = @vat_narration_es
			 WHERE [fee_accounting_id] = @fee_accounting_id


				CLOSE SYMMETRIC KEY Indigo_Symmetric_Key ;--Closes sym key

				--log the audit record
				DECLARE @audit_description varchar(max)
				SELECT @audit_description = 'Fee Accounting Updated: ' + @fee_accounting_name
											+ ', Id: ' + CAST(@fee_accounting_id as varchar(max))

				EXEC usp_insert_audit @audit_user_id, 
										9,
										NULL, 
										@audit_workstation, 
										@audit_description, 
										NULL, NULL, NULL, NULL		

				SET @ResultCode = 0
				COMMIT TRANSACTION [UPDATE_ACCOUNTING_TRAN]

			END TRY
		BEGIN CATCH
			ROLLBACK TRANSACTION [UPDATE_ACCOUNTING_TRAN]
			DECLARE @ErrorMessage NVARCHAR(4000);
			DECLARE @ErrorSeverity INT;
			DECLARE @ErrorState INT;

			SELECT 
				@ErrorMessage = ERROR_MESSAGE(),
				@ErrorSeverity = ERROR_SEVERITY(),
				@ErrorState = ERROR_STATE();

			RAISERROR (@ErrorMessage, -- Message text.
						@ErrorSeverity, -- Severity.
						@ErrorState -- State.
						);
		END CATCH 	
	END
END
GO
PRINT N'Altering [dbo].[usp_request_card_stock]...';


GO
-- =============================================
-- Author:	Nduvho Mukhavhuli
-- Create date: 2014/09/25
-- Description:	Creates a new card order
-- =============================================
ALTER PROCEDURE [dbo].[usp_request_card_stock] 
	@issuer_id int,
	@branch_id int,
	@product_id int,	
	@card_priority_id int,
	@card_issue_method_id int,	
	@cards_in_batch int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@dist_batch_id bigint OUTPUT,
	@dist_batch_ref varchar(50) OUTPUT,
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [CREATE_CARDS_STOCK]
		BEGIN TRY 

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @status_date datetime
			DECLARE @card_id bigint,
					@newGuid uniqueidentifier

			DECLARE @objid int
			SET @objid = object_id('cards')
			SET @status_date = GETDATE()


			--create the production batch
			INSERT INTO [dist_batch]
				([card_issue_method_id],[issuer_id], [branch_id], [no_cards],[date_created],[dist_batch_reference],[dist_batch_type_id])
			VALUES (@card_issue_method_id, @issuer_id, @branch_id, @cards_in_batch, @status_date, @status_date, 0)

			SET @dist_batch_id = SCOPE_IDENTITY();

			--add prod batch status of created
			INSERT INTO [dbo].[dist_batch_status]
				([dist_batch_id],[dist_batch_statuses_id],[user_id],[status_date],[status_notes])
			VALUES(@dist_batch_id, 0, @audit_user_id, @status_date, 'Batch Created')

			--Generate prod batch reference
			SELECT @dist_batch_ref =  [issuer].issuer_code + '' + 
										CONVERT(VARCHAR(MAX),[issuer_product].product_id) + '' +										  
										CONVERT(VARCHAR(8), @status_date, 112) + '' +
										CAST(@dist_batch_id AS varchar(max))
			FROM [issuer]					
				INNER JOIN [issuer_product]
					ON [issuer_product].issuer_id = [issuer].issuer_id
			WHERE [issuer_product].product_id = @product_id

			--UPDATE prod batch with reference and number of cards
			UPDATE [dist_batch]
			SET [dist_batch_reference] = @dist_batch_ref,
				[no_cards] = @cards_in_batch
			WHERE [dist_batch].dist_batch_id = @dist_batch_id

			--This section helps with creating the card_index, instead of calling the fuction each time
			--Which slows down the insers, we get the key and then just encrypt
			SET @objid = object_id('cards')			
			DECLARE @key varbinary(100)
			SET @key = null
			SELECT @key = DecryptByKeyAutoCert(cert_id('cert_ProtectIndexingKeys'), null, mac_key) 
			FROM mac_index_keys 
			WHERE table_id = @objid

			IF(@key IS NULL)
				RAISERROR (N'MAC Index Key is null.', 10, 1);

			--Table for storing new card id's
			Declare @inserted_cards TABLE (	card_id bigint )

			--Create Cards for the Batch
			DECLARE @index int = 0			
			WHILE @index < @cards_in_batch
			BEGIN
				SET @newGuid = NEWID();

				--Inserting a card record with an empty card number, the card number will be generated later in the process. 
				-- when that happens this record should be populated with a card number.
				INSERT INTO [cards]	([product_id], [ordering_branch_id], [branch_id], [delivery_branch_id],[origin_branch_id],[card_number],[card_sequence],
										[card_issue_method_id], [card_priority_id], [card_request_reference], [card_index]) 
					OUTPUT Inserted.card_id INTO @inserted_cards
					VALUES(@product_id, @branch_id, @branch_id, @branch_id, @branch_id, ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR(max), @newGuid)), 0,
						   --[dbo].[MAC]('0', @objid), 
						   @card_issue_method_id, @card_priority_id
						   ,CONVERT(varchar(100), @newGuid)
						   ,CONVERT(varbinary(24),HashBytes( N'SHA1', CONVERT(varbinary(8000), CONVERT(nvarchar(4000), @newGuid)) + @key )))

				--SET @card_id = SCOPE_IDENTITY();

				SET @index = @index +1
			END			

			--UPDATE CARDS WITH UNIQUE REF
			UPDATE [cards]
				SET card_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR, dbo.GenCardReferenceNo(@status_date, [cards].card_id))),
					card_request_reference = dbo.GenCardReferenceNo(@status_date, [cards].card_id),
					card_index = CONVERT(varbinary(24),HashBytes( N'SHA1', CONVERT(varbinary(8000), CONVERT(nvarchar(4000), RIGHT(dbo.GenCardReferenceNo(@status_date, [cards].card_id),4))) + @key ))
			WHERE [card_id] IN (SELECT card_id FROM @inserted_cards)

			--LINK CARDS TO THE BATCH
			INSERT INTO [dist_batch_cards] (card_id, dist_batch_id, dist_card_status_id)
				SELECT card_id, @dist_batch_id, 12 FROM @inserted_cards

			--UPDATE CARDS WITH UNIQUE REF
			--UPDATE [cards]
			--		SET [cards].card_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),
			--									CONVERT(VARCHAR, dbo.GenCardReferenceNo(@status_date, [cards].card_id))),
			--			[cards].card_request_reference = dbo.GenCardReferenceNo(@status_date, [cards].card_id)
			--FROM [cards]
			--		INNER JOIN [dist_batch_cards]
			--			ON [cards].card_id = [dist_batch_cards].card_id
			--WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id

			EXEC usp_notification_batch_add @dist_batch_id, 0		

			--Add audit for dist batch creation	
			DECLARE @dist_batch_status_name varchar(50),
					@audit_msg nvarchar(500)
			SELECT @dist_batch_status_name =  dist_batch_status_name
			FROM dist_batch_statuses
			WHERE dist_batch_statuses_id = 0
											
			SET @audit_msg = 'Create: ' + CAST(@dist_batch_id AS varchar(max)) +
								', ' + COALESCE(@dist_batch_ref, 'UNKNOWN') +
								', ' + COALESCE(@dist_batch_status_name, 'UNKNOWN')
								   
			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									2,
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

			SET @ResultCode = 0


			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key

			COMMIT TRANSACTION [CREATE_CARDS_STOCK]			
		END TRY

		BEGIN CATCH
			ROLLBACK TRANSACTION [CREATE_CARDS_STOCK]
			DECLARE @ErrorMessage NVARCHAR(4000);
			DECLARE @ErrorSeverity INT;
			DECLARE @ErrorState INT;

			SELECT 
				@ErrorMessage = ERROR_MESSAGE(),
				@ErrorSeverity = ERROR_SEVERITY(),
				@ErrorState = ERROR_STATE();

			RAISERROR (@ErrorMessage, -- Message text.
					   @ErrorSeverity, -- Severity.
					   @ErrorState -- State.
					   );
		END CATCH	
END
GO
PRINT N'Altering [dbo].[usp_create_dist_batch]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Manually create a new distribution batch. 
-- This distributin batch is created from cards received at a card centre
-- =============================================
ALTER PROCEDURE [dbo].[usp_create_dist_batch] 
	-- Add the parameters for the stored procedure here
	@issuer_id int,
	@branch_id int,	
	@to_branch_id int,
	@card_issue_method_id int,
	@product_id int,
	--@sub_product_id int = NULL,
	@batch_card_size int = NULL,
	@create_batch_option int,
	@start_ref varchar(100),
	@end_ref varchar(100),
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT,
	@dist_batchid int OUTPUT,
	@dist_batch_refnumber varchar(50) OUTPUT
AS
BEGIN

	BEGIN TRANSACTION [CREATE_DIST_BATCH]
		BEGIN TRY 

			DECLARE @number_of_dist_cards int = 0,
					@start_card_id bigint,
					@end_card_id bigint,
					@cards_total int = 0,
					@dist_batch_id int,
					@dist_batch_statuses_id int,
					@status_date datetime = GETDATE(),
					@audit_msg varchar,
					@card_centre bit


			--Determin direction of batch
			SELECT @card_centre = card_centre_branch_YN
			FROM [branch]
			WHERE branch_id  = @branch_id


			IF(@create_batch_option = 2)
			BEGIN
				--Get the start card id
				SELECT @start_card_id = card_id 
				FROM [cards]				
				WHERE [cards].card_request_reference  = @start_ref
						AND [cards].product_id = @product_id
						--AND ((@sub_product_id IS NULL) OR ([cards].sub_product_id = @sub_product_id))
						AND [cards].card_issue_method_id = @card_issue_method_id
						AND [cards].branch_id = @branch_id
			
				--Get the end card if
				SELECT @end_card_id = card_id 
				FROM [cards]				
				WHERE [cards].card_request_reference  = @end_ref
						AND [cards].product_id = @product_id
						--AND ((@sub_product_id IS NULL) OR ([cards].sub_product_id = @sub_product_id))
						AND [cards].card_issue_method_id = @card_issue_method_id
						AND [cards].branch_id = @branch_id
		

				--Validations
				--Make sure the cards references are correct
				IF(@start_card_id IS NULL OR @end_card_id IS NULL)
				BEGIN
					SET @ResultCode = 4
					SET @dist_batchid=0
					SET @dist_batch_refnumber=0
					ROLLBACK TRANSACTION [CREATE_DIST_BATCH]
					RETURN;
				END
				--TODO make sure start ref is smaller than end ref
				IF(@start_card_id > @end_card_id)
				BEGIN
					SET @ResultCode = 1
					SET @dist_batchid=0
					SET @dist_batch_refnumber=0
					ROLLBACK TRANSACTION [CREATE_DIST_BATCH]
					RETURN;
				END			

				IF(@card_centre = 1)
				BEGIN				
					SELECT @batch_card_size = COUNT([cards].card_id)
					FROM [cards]
							INNER JOIN [avail_cc_and_load_cards]
								ON [cards].card_id = [avail_cc_and_load_cards].card_id						
					WHERE [cards].branch_id = @branch_id
							AND [cards].product_id = @product_id
							--AND ((@sub_product_id IS NULL) OR ([cards].sub_product_id = @sub_product_id))
							AND [cards].card_issue_method_id = @card_issue_method_id
							AND [cards].card_id >= @start_card_id AND [cards].card_id <= @end_card_id									
				
				END
				ELSE
				BEGIN
				
					SELECT @batch_card_size = COUNT([cards].card_id)
					FROM [cards]
							INNER JOIN [branch_card_status_current]
								ON [cards].card_id = [branch_card_status_current].card_id
					WHERE [cards].branch_id = @branch_id
							AND [cards].product_id = @product_id
							--AND ((@sub_product_id IS NULL) OR ([cards].sub_product_id = @sub_product_id))
							AND [branch_card_status_current].branch_card_statuses_id = 0
							AND [cards].card_issue_method_id = @card_issue_method_id
							AND [cards].card_id >= @start_card_id AND [cards].card_id <= @end_card_id				
					
				END				
			END

			IF(@batch_card_size = 0)
				BEGIN
					SET @ResultCode = 1
					SET @dist_batchid=0
					set @dist_batch_refnumber=0
					ROLLBACK TRANSACTION [CREATE_DIST_BATCH]
					RETURN;
				END	

			--create the distribution batch
			INSERT INTO [dist_batch]
				([branch_id], [no_cards],[date_created],[dist_batch_reference], [card_issue_method_id],
					[dist_batch_type_id], [issuer_id])
			VALUES (@to_branch_id, 0, @status_date, @status_date, @card_issue_method_id, 1, @issuer_id)

			SET @dist_batch_id = SCOPE_IDENTITY();

			IF(@card_centre = 1)
			BEGIN
				--Add cards to distribution batch from card centre
				INSERT INTO [dist_batch_cards]
					([dist_batch_id],[card_id],[dist_card_status_id])
				SELECT TOP(@batch_card_size)	@dist_batch_id, [cards].card_id, 0
				FROM [cards]
						INNER JOIN [avail_cc_and_load_cards]
							ON [cards].card_id = [avail_cc_and_load_cards].card_id						
				WHERE [cards].branch_id = @branch_id
						AND [cards].product_id = @product_id
						--AND ((@sub_product_id IS NULL) OR ([cards].sub_product_id = @sub_product_id))
						AND [cards].card_issue_method_id = @card_issue_method_id
						AND (((@create_batch_option = 2) AND ([cards].card_id >= @start_card_id AND [cards].card_id <= @end_card_id))
								OR @create_batch_option = 1)
				ORDER BY [cards].card_id
				
			END
			ELSE
			BEGIN
				--Add cards to distribution batch from branch
				INSERT INTO [dist_batch_cards]
					([dist_batch_id],[card_id],[dist_card_status_id])
				SELECT TOP(@batch_card_size)
						@dist_batch_id, 
						[cards].card_id, 
						0
				FROM [cards]
						INNER JOIN [branch_card_status_current]
							ON [cards].card_id = [branch_card_status_current].card_id
				WHERE [cards].branch_id = @branch_id
						AND [cards].product_id = @product_id
						--AND ((@sub_product_id IS NULL) OR ([cards].sub_product_id = @sub_product_id))
						AND [branch_card_status_current].branch_card_statuses_id = 0
						AND [cards].card_issue_method_id = @card_issue_method_id
						AND (((@create_batch_option = 2) AND ([cards].card_id >= @start_card_id AND [cards].card_id <= @end_card_id))
								OR @create_batch_option = 1)
				ORDER BY [cards].card_id
			END
							
			--Get the number of cards inserted
			SELECT @number_of_dist_cards = @@ROWCOUNT										

			--Make sure we've insered enough cards
			IF(@number_of_dist_cards = @batch_card_size)
			BEGIN
				IF(@card_centre = 1)
				BEGIN
					SET @dist_batch_statuses_id = 0

					--add dist batch status of created
					INSERT INTO [dbo].[dist_batch_status]
						([dist_batch_id],[dist_batch_statuses_id],[user_id],[status_date],[status_notes])
					VALUES(@dist_batch_id, @dist_batch_statuses_id, @audit_user_id, @status_date, 'Batch Created')
				END
				ELSE
				BEGIN
					SET @dist_batch_statuses_id = 19

					--add dist batch status of created
					INSERT INTO [dbo].[dist_batch_status]
						([dist_batch_id],[dist_batch_statuses_id],[user_id],[status_date],[status_notes])
					VALUES(@dist_batch_id, @dist_batch_statuses_id, @audit_user_id, @status_date, 'Batch Created')
				END

				--Generate dist batch reference
				DECLARE @dist_batch_ref varchar(50)
				SELECT @dist_batch_ref =  [issuer].issuer_code + '' + 
										  [branch].branch_code + '' + 
										  CONVERT(VARCHAR(8), @status_date, 112) + '' +
										  CAST(@dist_batch_id AS varchar(max))
				FROM [branch] INNER JOIN [issuer]
					ON [branch].issuer_id = [issuer].issuer_id
				WHERE [branch].branch_id = @branch_id

				--UPDATE dist batch with reference and number of cards
				UPDATE [dist_batch]
				SET [dist_batch_reference] = @dist_batch_ref,
					[no_cards] = @number_of_dist_cards
				WHERE [dist_batch].dist_batch_id = @dist_batch_id

				----UPDATE the load batch cards status to allocated							
				--UPDATE [load_batch_cards]
				--SET [load_batch_cards].load_card_status_id = 2
				--WHERE [load_batch_cards].card_id IN 
				--		(SELECT [dist_batch_cards].card_id
				--		 FROM [dist_batch_cards]
				--		 WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id)

				IF(@card_centre = 1)
				BEGIN
					UPDATE [dist_batch_cards]
					SET [dist_batch_cards].dist_card_status_id = 0
					FROM [dist_batch_cards]
						INNER JOIN [cards]
							ON [cards].card_id = [dist_batch_cards].card_id
								AND [dist_batch_cards].dist_card_status_id = 18
						INNER JOIN [dist_batch_cards] batch_cards
							ON [cards].card_id = batch_cards.card_id
					WHERE batch_cards.dist_batch_id = @dist_batch_id

					UPDATE [load_batch_cards]
					SET [load_batch_cards].load_card_status_id = 2
					FROM [load_batch_cards]
						INNER JOIN [cards]
							ON [cards].card_id = [load_batch_cards].card_id
								AND [load_batch_cards].load_card_status_id = 1
						INNER JOIN [dist_batch_cards]
							ON [dist_batch_cards].card_id = [cards].card_id
					WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id	

				END
				ELSE
				BEGIN
					INSERT INTO [branch_card_status] (card_id,branch_id, branch_card_statuses_id, comments, status_date, [user_id])
					SELECT card_id,@branch_id, 13, '', GETDATE(), @audit_user_id
					FROM [dist_batch_cards]
					WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id
				END

				--Update the cards to the new destination branch.
				UPDATE [cards]
				SET branch_id = @to_branch_id
				FROM [cards]
						INNER JOIN [dist_batch_cards]
							ON [cards].card_id = [dist_batch_cards].card_id
				WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id


				--UPDATE [dist_batch_cards]
				--SET [dist_batch_cards].dist_batch_id = 0
				--FROM [cards]
				--	INNER JOIN [dist_batch_cards]
				--		ON [cards].card_id = [dist_batch_cards].card_id
				--	INNER JOIN [dist_batch_cards] prod_batch_cards
				--		ON [cards].card_id = prod_batch_cards.card_id
				--			AND .dist_card_status_id = 18
				--	INNER JOIN [dist_batch]
				--		ON [dist_batch_cards].dist_batch_id = [dist_batch].dist_batch_id
				--	INNER JOIN [dist_batch_status_current]
				--		ON [dist_batch].dist_batch_id = [dist_batch_status_current].dist_batch_id
				--WHERE [cards].branch_id = @branch_id
				--		AND [cards].product_id = @product_id
				--		AND [cards].sub_product_id = @sub_product_id
				--		AND [dist_batch].dist_batch_type_id = 0
				--		AND [dist_batch_status_current].dist_batch_statuses_id = 14
				--		AND [dist_batch_cards].dist_card_status_id = 18
				--		AND [cards].card_issue_method_id = COALESCE(@card_issue_method_id, [cards].card_issue_method_id)

				--NOTIFICATION of BATCH
				EXEC usp_notification_batch_add @dist_batch_id, @dist_batch_statuses_id	
				
				DECLARE @dist_batch_status_name varchar(50)
				SELECT @dist_batch_status_name =  dist_batch_status_name
				FROM dist_batch_statuses
				WHERE dist_batch_statuses_id = 0

				--Add audit for dist batch creation								
				SET @audit_msg = 'Create: ' + CAST(@dist_batch_id AS varchar(max)) +
									', ' + COALESCE(@dist_batch_ref, 'UNKNOWN') +
									', ' + COALESCE(@dist_batch_status_name, 'UNKNOWN')
								   
				--log the audit record		
				EXEC usp_insert_audit @audit_user_id, 
										2,
										NULL, 
										@audit_workstation, 
										@audit_msg, 
										NULL, NULL, NULL, NULL

				SET @ResultCode = 0
				SET @dist_batchid=@dist_batch_id
				SET @dist_batch_refnumber=@dist_batch_ref

				COMMIT TRANSACTION [CREATE_DIST_BATCH]	
			END
			ELSE
			BEGIN
				--Size fo cards for batch doesnt match number of records inserted.
				SET @ResultCode = 70
				SET @dist_batchid=0
				SET @dist_batch_refnumber=0
				ROLLBACK TRANSACTION [CREATE_DIST_BATCH]
			END						
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [CREATE_DIST_BATCH]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				  );
	END CATCH				
END
GO
PRINT N'Altering [dbo].[usp_dist_batch_status_reject]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Change batch status - Reject
-- =============================================
ALTER PROCEDURE [dbo].[usp_dist_batch_status_reject] 
	@dist_batch_id bigint,
	@new_dist_batch_status_id int,
	@status_notes varchar(150) = null,
	@language_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [BATCH_STATUS_CHANGE_REJECT]
		BEGIN TRY 
			
			DECLARE @audit_msg varchar(max),
					@new_dist_card_statuses_id int,
					@new_branch_card_statuses_id int

			--Check that someone hasn't already updated the dist batch
			IF(dbo.DistBatchInCorrectStatusReject(@new_dist_batch_status_id, @dist_batch_id) = 0)
				BEGIN
					SET @ResultCode = 100
				END
			ELSE
				BEGIN
					SELECT @new_dist_card_statuses_id = reject_dist_card_statuses_id,
							@new_branch_card_statuses_id = reject_branch_card_statuses_id
					FROM [dist_batch_status_current]
						INNER JOIN [dist_batch]
							ON [dist_batch_status_current].dist_batch_id = [dist_batch].dist_batch_id
						INNER JOIN [dist_batch_cards]
							ON [dist_batch].dist_batch_id = [dist_batch_cards].dist_batch_id
						INNER JOIN cards  
							ON [dist_batch_cards].card_id = cards.card_id
						INNER JOIN [issuer_product]
							ON cards.product_id = [issuer_product].product_id
						INNER JOIN [dist_batch_statuses_flow] AS [product_flow]
							ON (([dist_batch].dist_batch_type_id = 0 AND 
									[product_flow].dist_batch_status_flow_id = [issuer_product].production_dist_batch_status_flow)
								OR ([dist_batch].dist_batch_type_id = 1 AND 
									[product_flow].dist_batch_status_flow_id = [issuer_product].distribution_dist_batch_status_flow))
								AND [product_flow].dist_batch_statuses_id = [dist_batch_status_current].dist_batch_statuses_id
						INNER JOIN [dist_batch_status_flow]
							ON [dist_batch_status_flow].dist_batch_status_flow_id = [product_flow].dist_batch_status_flow_id
					WHERE dist_batch_status_current.dist_batch_id = @dist_batch_id



					--	FROM [dist_batch_statuses_flow]
					--		INNER JOIN [dist_batch]
					--			ON [dist_batch_statuses_flow].card_issue_method_id = [dist_batch].card_issue_method_id
					--				AND [dist_batch_statuses_flow].dist_batch_type_id = [dist_batch].dist_batch_type_id
					--		INNER JOIN [dist_batch_status_current]
					--			ON [dist_batch_status_current].dist_batch_statuses_id = [dist_batch_statuses_flow].dist_batch_statuses_id
					--				AND [dist_batch_status_current].dist_batch_id = [dist_batch].dist_batch_id
					--WHERE [dist_batch].dist_batch_id = @dist_batch_id
					--		AND [dist_batch_statuses_flow].reject_dist_batch_statuses_id = @new_dist_batch_status_id


					--Update the batch status.
					INSERT [dist_batch_status]
							([dist_batch_id], [dist_batch_statuses_id], [user_id], [status_date], [status_notes])
					VALUES (@dist_batch_id, @new_dist_batch_status_id, @audit_user_id, GETDATE(), @status_notes)

					--Check if we need to update the card status
					IF (@new_dist_card_statuses_id IS NOT NULL)
					BEGIN 
						--Update the cards linked to the dist batch with the new status.
						UPDATE dist_batch_cards
						SET dist_card_status_id = @new_dist_card_statuses_id
						WHERE dist_batch_id = @dist_batch_id

						--Going back to checked in or destroying, make sure cards are back at originating branch
						IF(@new_dist_card_statuses_id = 18 OR @new_dist_card_statuses_id = 11)
						BEGIN
							UPDATE [cards]
							SET branch_id = [cards].origin_branch_id
							FROM [cards]
								INNER JOIN [dist_batch_cards]
									ON [cards].card_id = [dist_batch_cards].card_id
							WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id 
						END
					END

					IF(@new_branch_card_statuses_id IS NOT NULL)
					BEGIN
						INSERT INTO [branch_card_status] (branch_card_statuses_id, card_id, status_date, [user_id])
						SELECT @new_branch_card_statuses_id, [dist_batch_cards].card_id, GETDATE(), @audit_user_id
						FROM [dist_batch_cards]
						WHERE dist_batch_id = @dist_batch_id
						
					END
				
					--AUDIT
					DECLARE @batch_status_name varchar(100),
							@batch_ref varchar(100)

					SELECT @batch_status_name =  dist_batch_status_name
					FROM dist_batch_statuses
					WHERE dist_batch_statuses_id = @new_dist_batch_status_id

					SELECT @batch_ref = dist_batch_reference
					FROM dist_batch
					WHERE dist_batch_id = @dist_batch_id

					--Add audit for pin batch update								
					SET @audit_msg = 'Update: ' + CAST(@dist_batch_id AS varchar(max)) +
										', ' + COALESCE(@batch_ref, 'UNKNOWN') +
										', ' + COALESCE(@batch_status_name, 'UNKNOWN')
								   
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
											2,
											NULL, 
											@audit_workstation, 
											@audit_msg, 
											NULL, NULL, NULL, NULL

					SET @ResultCode = 0					
				END

				--Fetch the batch with latest details
				EXEC usp_get_dist_batch @dist_batch_id,
										@language_id,
										@audit_user_id,
										@audit_workstation

				COMMIT TRANSACTION [BATCH_STATUS_CHANGE_REJECT]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [BATCH_STATUS_CHANGE_REJECT]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_insert_product]...';


GO

-- =============================================
-- Author:		Sandhya konduru
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
--exec [usp_insert_product] 'Ghana_Visa_Black_Card','GVBC02','484680',-1,50.00,50.00,15,2,null,-1,'veneka-04'
ALTER PROCEDURE [dbo].[usp_insert_product]
	-- Add the parameters for the stored procedure here
	@product_name varchar(100),
	@product_code varchar(50),
	@product_bin_code varchar(9),
	@issuer_id  int,
	@pan_length smallint,
	@sub_product_code varchar(4),
	@expiry_months int,
	@fee_scheme_id int = null,
	@charge_fee_to_issuing_branch_YN bit,
	@card_issue_method_id int,
	@print_issue_card_YN bit,

	@name_on_card_top decimal(8,2)=0,
	@name_on_card_left decimal(8,2)=0,
	@Name_on_card_font_size int=0,
	@font_id int=1,	

	@src1_id int,
	@src2_id int,
	@src3_id int,
	@PVKI varchar(100),
	@PVK varchar(100),
	@CVKA varchar(100),
	@CVKB varchar(100),	
		
	@enable_instant_pin_YN bit,
	@enable_instant_pin_reissue_YN bit,
	@pin_calc_method_id int,
	@min_pin_length int,
	@max_pin_length int,	

	@cms_exportable_YN bit,
	@product_load_type_id int,
	@auto_approve_batch_YN bit,
	@account_validation_YN bit,
	@pin_mailer_printing_YN bit,
	@pin_mailer_reprint_YN bit,

	@card_issue_reasons_list as dbo.key_value_array READONLY,
	@account_types_list as dbo.key_value_array READONLY,
	@currencylist AS dbo.product_currency_array READONLY,	
	@external_system_fields AS  dbo.[product_external_fields_array] READONLY,	
	@prod_interface_parameters_list AS dbo.bikey_value_array READONLY,
	@issue_interface_parameters_list AS dbo.bikey_value_array READONLY,

	@decimalisation_table varchar(100),
	@pin_validation_data varchar(100),
	@pin_block_formatid int,

	@production_dist_batch_status_flow_id int, 
	@distribution_dist_batch_status_flow_id int,
	@allow_manual_uploaded_YN bit,
	@allow_reupload_YN bit,

	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int =null OUTPUT,
	@new_product_id int =null OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
		BEGIN TRANSACTION [INSERT_Product_TRAN]
		BEGIN TRY 

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate
			--Check for duplicate's
			IF EXISTS(SELECT * FROM [issuer_product] WHERE [product_code] = @product_code AND issuer_id = @issuer_id)
				BEGIN
					SET @new_product_id = 0
					SET @ResultCode = 221						
				END
			 ELSE
			IF EXISTS(SELECT * FROM [issuer_product] WHERE [product_name] = @product_name)
				BEGIN
					SET @new_product_id = 0
					SET @ResultCode = 220
				END
			ELSE IF dbo.ProductValidation(NULL, @product_bin_code, @sub_product_code) = 0
				BEGIN
					SET @new_product_id = 0
					SET @ResultCode = 222
				END
			ELSE IF 0 = ANY(SELECT dbo.FileParameterValidation(key2, value, key1) FROM @prod_interface_parameters_list)
				BEGIN
					SET @new_product_id = 0
					SET @ResultCode = 228
				END
			ELSE			
			BEGIN
				INSERT INTO [dbo].[issuer_product]
					   ([product_code], [product_name], [product_bin_code], [issuer_id],
						[name_on_card_top], [name_on_card_left], [Name_on_card_font_size], [font_id],DeletedYN,
						[src1_id],[src2_id],[src3_id],[PVKI],[PVK],[CVKA],CVKB,[expiry_months], 
						[fee_scheme_id], [enable_instant_pin_YN],[min_pin_length],[max_pin_length],
						[enable_instant_pin_reissue_YN],[cms_exportable_YN],[product_load_type_id],
						[pan_length],[sub_product_code],[pin_calc_method_id],
						[auto_approve_batch_YN],[account_validation_YN], [pin_mailer_printing_YN],
						[pin_mailer_reprint_YN], [card_issue_method_id],[decimalisation_table],[pin_validation_data],pin_block_formatid,
						production_dist_batch_status_flow, distribution_dist_batch_status_flow,
						charge_fee_to_issuing_branch_YN, print_issue_card_YN, allow_manual_uploaded_YN, allow_reupload_YN)
				VALUES (@product_code, @product_name, @product_bin_code, @issuer_id,
						@name_on_card_top, @name_on_card_left, @Name_on_card_font_size, @font_id, 0,
						@src1_id, @src2_id, @src3_id, 
						ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@PVKI)), 
						ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@PVK)), 
						ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@CVKA)),
						ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@CVKB)), @expiry_months,
						@fee_scheme_id, @enable_instant_pin_YN,
						@min_pin_length, @max_pin_length, @enable_instant_pin_reissue_YN, @cms_exportable_YN,
						@product_load_type_id,@pan_length,@sub_product_code,@pin_calc_method_id,
						@auto_approve_batch_YN,@account_validation_YN, @pin_mailer_printing_YN,@pin_mailer_reprint_YN,
						@card_issue_method_id,ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@decimalisation_table)), 
						ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@pin_validation_data)),@pin_block_formatid,
						@production_dist_batch_status_flow_id, @distribution_dist_batch_status_flow_id,
						@charge_fee_to_issuing_branch_YN, @print_issue_card_YN, @allow_manual_uploaded_YN
					    , @allow_reupload_YN)
			
				SET @new_product_id= SCOPE_IDENTITY()

				--insert issuing reason
				INSERT INTO [product_issue_reason] (product_id, card_issue_reason_id)
				SELECT @new_product_id, value
				FROM @card_issue_reasons_list	

				--insert account types
				INSERT INTO [products_account_types] (product_id, account_type_id)
				SELECT @new_product_id, value
				FROM @account_types_list

				--insert production interfaces
				INSERT INTO [product_interface] (product_id, interface_type_id, connection_parameter_id, interface_guid, interface_area)
				SELECT @new_product_id, key1, key2, value, 0
				FROM @prod_interface_parameters_list

				--insert issuing interfaces
				INSERT INTO [product_interface] (product_id, interface_type_id, connection_parameter_id, interface_guid, interface_area)
				SELECT @new_product_id, key1, key2, value, 1
				FROM @issue_interface_parameters_list

				--insert currencies
				DECLARE @RC int
				EXECUTE @RC = [usp_insert_product_currency] @new_product_id, @currencylist, @audit_user_id, @audit_workstation

				--insert external system fields

				DECLARE @RCExternal int
				EXECUTE @RCExternal = [usp_insert_product_external_systems] @new_product_id, @external_system_fields, @audit_user_id, @audit_workstation

				DECLARE @audit_description varchar(500)
				SELECT @audit_description = 'Product Created: ' + @product_code  + ', Product Name:' + @product_name + 
																     ', bin code:' + @product_bin_code 
															+ ' , Product Id: ' + CAST(@new_product_id as varchar(max))
																	
				EXEC usp_insert_audit @audit_user_id, 
									 4,
									 NULL, 
									 @audit_workstation, 
									 @audit_description, 
									 @issuer_id, NULL, NULL, NULL

				SET @ResultCode = 0				
			END
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key
			COMMIT TRANSACTION [INSERT_Product_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [INSERT_Product_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	

END
GO
PRINT N'Altering [dbo].[usp_issue_card_complete]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_complete] 
	@card_id bigint,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [ISSUE_CARD_COMPLETE_TRAN]
		BEGIN TRY 
			
			DECLARE @current_card_status_id int,
					@branch_id int,
					@status_date datetime,
					@operator_user_id bigint
					

			--get the current status and operator for the card
			SELECT @current_card_status_id = branch_card_statuses_id, @operator_user_id = operator_user_id
			FROM branch_card_status_current
			WHERE card_id = @card_id
										  
			--Check that someone hasn't already updated the card
			IF(@current_card_status_id = 8 OR @current_card_status_id = 9)				
				BEGIN

					SET @status_date = GETDATE()

					SELECT @branch_id = branch_id
					FROM [cards]
					WHERE card_id = @card_id

					--Update the cards status.
					INSERT branch_card_status
							(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id)
					VALUES (@card_id, @branch_id, 6, @status_date, @audit_user_id, @operator_user_id) 

					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					DECLARE @cardnumber varchar(50),
							@branch_card_status_name varchar(50),
							@audit_msg varchar(max)

					SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
					FROM cards 
					WHERE cards.card_id = @card_id

					SELECT @branch_card_status_name = branch_card_statuses_name
					FROM [branch_card_statuses]
					WHERE branch_card_statuses_id = 6

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

					--NOTIFICATION
					EXEC usp_notification_branch_add @card_id, 6

					SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
									 ', ' + dbo.MaskString(@cardnumber, 6, 4)
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
										 3,
										 NULL, 
										 @audit_workstation, 
										 @audit_msg, 
										 NULL, NULL, NULL, NULL

					SET @ResultCode = 0					
				END
			ELSE
				BEGIN
					SET @ResultCode = 100
				END
			

				COMMIT TRANSACTION [ISSUE_CARD_COMPLETE_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_COMPLETE_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_issue_card_PIN_captured]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_issue_card_PIN_captured] 
	@card_id bigint,
	@pin_auth_user_id bigint = null,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [ISSUE_CARD_PIN_CAPTURED_TRAN]
		BEGIN TRY 
			
			DECLARE @current_card_status_id int,
					@branch_id int,
					@status_date datetime
					

			--get the current status for the card
			SELECT @current_card_status_id = branch_card_statuses_id
			FROM branch_card_status_current
			WHERE card_id = @card_id
										  
			--Check that someone hasn't already updated the card
			IF(@current_card_status_id = 4 OR @current_card_status_id = 5)				
				BEGIN

					--TODO: Need to update card table the pin

					SET @status_date = GETDATE()

					SELECT @branch_id = branch_id
					FROM [cards]
					WHERE card_id = @card_id

					--Update the cards status.
					INSERT branch_card_status
							(card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, pin_auth_user_id)
					VALUES (@card_id, @branch_id, 5, @status_date, @audit_user_id, null, @pin_auth_user_id) 

					OPEN SYMMETRIC KEY Indigo_Symmetric_Key
					DECRYPTION BY CERTIFICATE Indigo_Certificate

					DECLARE @cardnumber varchar(50),
							@branch_card_status_name varchar(50),
							@audit_msg varchar(max)

					SELECT @cardnumber = CONVERT(VARCHAR,DECRYPTBYKEY(cards.card_number)) 
					FROM cards 
					WHERE cards.card_id = @card_id

					SELECT @branch_card_status_name = branch_card_statuses_name
					FROM [branch_card_statuses]
					WHERE branch_card_statuses_id = 5

					CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;

					--NOTIFICATION
					EXEC usp_notification_branch_add @card_id, 5

					SET @audit_msg = '' + COALESCE(@branch_card_status_name, 'UNKNOWN') + 
									 ', ' + dbo.MaskString(@cardnumber, 6, 4)
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
										 3,
										 NULL, 
										 @audit_workstation, 
										 @audit_msg, 
										 NULL, NULL, NULL, NULL

					SET @ResultCode = 0					
				END
			ELSE
				BEGIN
					SET @ResultCode = 100
				END
			

				COMMIT TRANSACTION [ISSUE_CARD_PIN_CAPTURED_TRAN]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [ISSUE_CARD_PIN_CAPTURED_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Altering [dbo].[usp_prod_to_dist_batch]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_prod_to_dist_batch] 
	-- Add the parameters for the stored procedure here
	@dist_batch_id bigint, 
	@audit_user_id bigint,
	@audit_workstation varchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	--SET NOCOUNT ON;

	--BEGIN TRANSACTION [PROD_TO_DIST_TRAN]
	--BEGIN TRY 

		--Get a distinct list of branches from the batch
		DECLARE @branch_id int,
				@cards_total int = 0,
				@card_issue_method_id int,
				@check_prod_batch_id int,
				@new_dist_batch_id int,
				@cc_branch_id int,
				@audit_msg varchar(max)

		SELECT @cc_branch_id = [branch].branch_id
		FROM [branch] INNER JOIN [dist_batch]
			ON [branch].issuer_id = [dist_batch].issuer_id
				AND [branch].card_centre_branch_YN = 1
				AND [branch].branch_status_id = 0		 

		SELECT @card_issue_method_id = card_issue_method_id, @check_prod_batch_id = dist_batch_type_id
		FROM dist_batch
		WHERE dist_batch_id = @dist_batch_id

		IF (@check_prod_batch_id = 1)
			RAISERROR ('Can only create distribution batchs from a production batch.', 12, 12 );


		--Loop through all distinct branches for the production batch and create distribution batches
		DECLARE branchId_cursor CURSOR FOR 
			SELECT DISTINCT [cards].delivery_branch_id
			FROM [cards] 
				INNER JOIN [dist_batch_cards]
					ON [cards].card_id = [dist_batch_cards].card_id
			WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id
						

		OPEN branchId_cursor

		FETCH NEXT FROM branchId_cursor 
		INTO @branch_id

		WHILE @@FETCH_STATUS = 0
		BEGIN
			DECLARE @number_of_dist_cards int = 0,
					@dist_status_date datetime = GETDATE()

			--IF(SELECT [issuer].auto_create_dist_batch
			--	FROM [issuer] INNER JOIN [branch]
			--			ON [issuer].issuer_id = [branch].issuer_id
			--	WHERE [branch].branch_id = @branch_id) = 1
			--	BEGIN							
								
					--create the distribution batch
					INSERT INTO [dist_batch]
						([issuer_id], [branch_id], [no_cards],[date_created],[dist_batch_reference], [card_issue_method_id], [dist_batch_type_id])
					SELECT issuer_id, @branch_id, 0, @dist_status_date, @dist_status_date, @card_issue_method_id, 1
					FROM [branch]
					WHERE branch_id = @branch_id

					SET @new_dist_batch_id = SCOPE_IDENTITY();

					--Add cards to distribution batch
					INSERT INTO [dist_batch_cards]
						([dist_batch_id],[card_id],[dist_card_status_id])
					SELECT
						@new_dist_batch_id, [cards].card_id, 0
					FROM [cards] INNER JOIN [dist_batch_cards]
						ON [cards].card_id = [dist_batch_cards].card_id
					WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id
							AND [cards].delivery_branch_id = @branch_id
							
					--Get the number of cards inserted
					SELECT @number_of_dist_cards = @@ROWCOUNT										

					--add dist batch status of created
					INSERT INTO [dbo].[dist_batch_status]
						([dist_batch_id],[dist_batch_statuses_id],[user_id],[status_date],[status_notes])
					VALUES(@new_dist_batch_id, 0, @audit_user_id, @dist_status_date, 'Distribution Batch Create From Production: ' + CONVERT(VARCHAR(max),@dist_batch_id))

					--Generate dist batch reference
					DECLARE @dist_batch_ref varchar(50)
					SELECT @dist_batch_ref =  [issuer].issuer_code + '' + 
												[branch].branch_code + '' + 
												CONVERT(VARCHAR(8), @dist_status_date, 112) + '' +
												CAST(@new_dist_batch_id AS varchar(max))
					FROM [branch] INNER JOIN [issuer]
						ON [branch].issuer_id = [issuer].issuer_id
					WHERE [branch].branch_id = @branch_id

					--UPDATE dist batch with reference and number of cards
					UPDATE [dist_batch]
					SET [dist_batch_reference] = @dist_batch_ref,
						[no_cards] = @number_of_dist_cards
					WHERE [dist_batch].dist_batch_id = @new_dist_batch_id

					--UPDATE the production batch cards status to allocated							
					UPDATE [dist_batch_cards]
					SET [dist_batch_cards].dist_card_status_id = 0
					WHERE dist_batch_id = @dist_batch_id
						AND	[dist_batch_cards].card_id IN 
							(SELECT [dist_batch_cards].card_id
								FROM [dist_batch_cards]
								WHERE [dist_batch_cards].dist_batch_id = @new_dist_batch_id)

					--UPDATE cards to delivery branch ID
					UPDATE [cards]
					SET branch_id = @branch_id,
					    origin_branch_id = COALESCE(@cc_branch_id, @branch_id)
					WHERE card_id IN (SELECT [dist_batch_cards].card_id
									  FROM [dist_batch_cards]
									  WHERE [dist_batch_cards].dist_batch_id = @new_dist_batch_id)
							
					--NOTIFICATION
					EXEC usp_notification_batch_add @new_dist_batch_id, 0

					DECLARE @dist_batch_status_name varchar(50)
					SELECT @dist_batch_status_name =  dist_batch_status_name
					FROM dist_batch_statuses
					WHERE dist_batch_statuses_id = 0

					--Add audit for dist batch creation								
					SET @audit_msg = 'Create: ' + CAST(@new_dist_batch_id AS varchar(max)) +
										', ' + COALESCE(@dist_batch_ref, 'UNKNOWN') +
										', ' + COALESCE(@dist_batch_status_name, 'UNKNOWN')
								   
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
											2,
											NULL, 
											@audit_workstation, 
											@audit_msg, 
											NULL, NULL, NULL, NULL

					--TODO: look at the dist_batch_flow table
					--auto add approve the distbatch
					INSERT INTO [dbo].[dist_batch_status]
						([dist_batch_id],[dist_batch_statuses_id],[user_id],[status_date],[status_notes])
					VALUES(@new_dist_batch_id, 1, @audit_user_id, DATEADD(ss,1,@dist_status_date), 'Auto Dist Batch Create Approval')								

					SELECT @dist_batch_status_name =  dist_batch_status_name
					FROM dist_batch_statuses
					WHERE dist_batch_statuses_id = 1

					--Add audit for dist batch update								
					SET @audit_msg = 'Update: ' + CAST(@new_dist_batch_id AS varchar(max)) +
										', ' + COALESCE(@dist_batch_ref, 'UNKNOWN') +
										', ' + COALESCE(@dist_batch_status_name, 'UNKNOWN')
								   
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
											2,
											NULL, 
											@audit_workstation, 
											@audit_msg, 
											NULL, NULL, NULL, NULL

			--	END
			--ELSE
			--	BEGIN
			--		--Update the cards linked to the load batch and cursors branch with the available status.
			--		UPDATE [load_batch_cards]
			--		SET load_card_status_id = 1
			--		FROM [load_batch_cards] INNER JOIN [cards]
			--				ON [load_batch_cards].card_id = [cards].card_id
			--		WHERE [load_batch_cards].load_batch_id = @load_batch_id
			--				AND [cards].branch_id = @branch_id

			--		--Get the number of cards updated
			--		SELECT @number_of_dist_cards = @@ROWCOUNT
			--	END						

			SELECT @cards_total += @number_of_dist_cards

				-- Get the next branch.
			FETCH NEXT FROM branchId_cursor 
			INTO @branch_id
			END 
		CLOSE branchId_cursor;
		DEALLOCATE branchId_cursor;

		--Check that all cards for the load batch have been updated
		IF (SELECT COUNT(card_id) FROM [dist_batch_cards] WHERE dist_batch_id = @dist_batch_id) != @cards_total
		BEGIN
			RAISERROR ('Not all cards have been moved from production batch to distribution batch.',
						12,
						12 );
		END

	--	COMMIT TRANSACTION [PROD_TO_DIST_TRAN]				
	--	END TRY
	--BEGIN CATCH
	--	ROLLBACK TRANSACTION [PROD_TO_DIST_TRAN]
	--	DECLARE @ErrorMessage NVARCHAR(4000);
	--	DECLARE @ErrorSeverity INT;
	--	DECLARE @ErrorState INT;

	--	SELECT 
	--		@ErrorMessage = ERROR_MESSAGE(),
	--		@ErrorSeverity = ERROR_SEVERITY(),
	--		@ErrorState = ERROR_STATE();

	--	RAISERROR (@ErrorMessage, -- Message text.
	--			   @ErrorSeverity, -- Severity.
	--			   @ErrorState -- State.
	--			   );
	--END CATCH


END
GO
PRINT N'Altering [dbo].[usp_request_card_for_customer]...';


GO
-- =============================================
-- Author:		
-- Create date: 
-- Description:	This proc is used to add details to the DB to request a card for a customer
-- =============================================
ALTER PROCEDURE [dbo].[usp_request_card_for_customer] 
	@delivery_branch_id int,
	@branch_id int,
	@product_id int,		
	@card_priority_id int,
    @customer_account_number varchar(27),
	@domicile_branch_id int,
	@account_type_id int,
	@card_issue_reason_id int,
	@customer_first_name varchar(50),
	@customer_middle_name varchar(50),
	@customer_last_name varchar(50),
	@name_on_card varchar(30),
	@customer_title_id int,	
	@currency_id int,
	@resident_id int,
	@customer_type_id int,
	@cms_id varchar(50),
	@contract_number varchar(50),
	@idnumber varchar(50),
	@contact_number varchar(50),
	@customer_id varchar(50),
	@fee_waiver_YN bit = NULL,
	@fee_editable_YN bit = NULL,
	@fee_charged decimal(10,4) = NULL,
	@fee_overridden_YN bit = NULL,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@card_id bigint OUTPUT,
	@ResultCode int OUTPUT,
	@new_customer_account_id int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [REQUEST_CARD_FOR_CUST_TRAN]
		BEGIN TRY 

			IF @customer_middle_name IS NULL
				SET @customer_middle_name = ''
			
			DECLARE @status_date datetime,
					@branch_card_statuses_id int

			SET @branch_card_statuses_id = 2

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate

			DECLARE @objid int
			SET @objid = object_id('cards')
			SET @status_date = GETDATE()

			--Inserting a card record with an empty card number, the card number will be generated later in the process. 
			-- when that happens this record should be populated with a card number.
			INSERT INTO [cards]	([product_id],[ordering_branch_id],[branch_id],[origin_branch_id],[delivery_branch_id],[card_number],[card_sequence],[card_index], 
									card_issue_method_id, card_priority_id, fee_waiver_YN, fee_editable_YN, fee_charged, fee_overridden_YN) 
				VALUES(@product_id, @branch_id, @branch_id, @branch_id, @delivery_branch_id, ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR, '')), 0,
					   [dbo].[MAC]('0', @objid), 0, @card_priority_id, @fee_waiver_YN, @fee_editable_YN, @fee_charged, @fee_overridden_YN)

			SET @card_id = SCOPE_IDENTITY();

			--Update card with reference number
			--Generate card reference
			DECLARE @card_ref varchar(100)
			SET @card_ref =  'CCR' + CONVERT(VARCHAR(8), GETDATE(), 112) + CAST(@product_id AS varchar(max)) + CAST(@card_id AS varchar(max))

			UPDATE [cards]
				SET card_number = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(VARCHAR(max), @card_ref)),
					card_request_reference = @card_ref
			WHERE [card_id] = @card_id


			--The initial card status.
			INSERT branch_card_status (card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id)
			VALUES (@card_id, @branch_id, @branch_card_statuses_id, @status_date, @audit_user_id, @audit_user_id)

			--NOTIFICATION for creation of request
			exec usp_notification_branch_add @card_id, @branch_card_statuses_id

			--Check if we need to do maker/checker for the request.
			--If no maker checker then we "Auto" approve the card for issue.
			IF ((SELECT [issuer].maker_checker_YN
				FROM [issuer] INNER JOIN [branch]
					ON [issuer].issuer_id = [branch].issuer_id
				WHERE [branch].branch_id = @branch_id) = 0)		
				BEGIN		
					SET @branch_card_statuses_id = 3       --Not MakerChecker	
					--Add additional second to the request so that the order is preserved,
					INSERT branch_card_status (card_id, branch_id, branch_card_statuses_id, status_date, [user_id], operator_user_id, comments)
					VALUES (@card_id, @branch_id, @branch_card_statuses_id, DATEADD(ss, 1, @status_date), @audit_user_id, @audit_user_id, 'Auto Approve Card For Issue')

					--NOTIFICATION for approval
					exec usp_notification_branch_add @card_id, @branch_card_statuses_id
				END	
						 

			--Save customer details
			INSERT customer_account
					([user_id], card_id, card_issue_reason_id, account_type_id, customer_account_number,
						customer_first_name, customer_middle_name, customer_last_name, name_on_card, customer_title_id, 
						date_issued, customer_type_id, currency_id, resident_id, cms_id, contract_number, Id_number,contact_number, CustomerId,
						domicile_branch_id)
			VALUES (@audit_user_id, @card_id, @card_issue_reason_id, @account_type_id, 
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_account_number)),
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_first_name)),
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_middle_name)), 
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_last_name)), 
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),UPPER(@name_on_card))), 
					@customer_title_id, @status_date, @customer_type_id, @currency_id, @resident_id, @cms_id, @contract_number,
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@idnumber)),
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@contact_number)),
					ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@customer_id)),
					@domicile_branch_id)		

			SET @new_customer_account_id = SCOPE_IDENTITY()			
			
			--Log audit stuff
			DECLARE @branchcardstatus  varchar(max),
					@Scenario  varchar(max),
					@audit_msg varchar(max),
					@cardnumber varchar(16),
					@obranch varchar(max),
					@dbranch varchar(max)

			SELECT @obranch = branch_code from branch where branch_id = @branch_id
			SELECT @dbranch = branch_code from branch where branch_id = @delivery_branch_id

			SELECT  @branchcardstatus =  branch_card_statuses.branch_card_statuses_name
			FROM    branch_card_statuses 
			WHERE	branch_card_statuses.branch_card_statuses_id = @branch_card_statuses_id

			SELECT  @Scenario =  card_issue_reason.[card_issuer_reason_name]
			FROM	card_issue_reason 
			WHERE	card_issue_reason.[card_issue_reason_id] = @card_issue_reason_id

			SET @audit_msg =  'card request-' + 
								COALESCE(@branchcardstatus, 'UNKNWON') +  
								', cust id:' + COALESCE(CAST(@cms_id as varchar(max)), 'n/a') +
								', a/c:' + dbo.MaskString(@customer_account_number, 3, 4) + 
								', o/branch:' + COALESCE(@obranch, 'UNKNWON') +  
								', d/branch:' + COALESCE(@dbranch, 'UNKNWON') +  
								', ' + COALESCE(@Scenario, 'UNKNWON')

			--log the audit record		
			EXEC usp_insert_audit @audit_user_id, 
									3,---IssueCard
									NULL, 
									@audit_workstation, 
									@audit_msg, 
									NULL, NULL, NULL, NULL

			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key			
				
			COMMIT TRANSACTION [REQUEST_CARD_FOR_CUST_TRAN]
			SET @ResultCode = 0

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [REQUEST_CARD_FOR_CUST_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH

END
GO
PRINT N'Altering [dbo].[usp_request_create_dist_batch]...';


GO
-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	
-- =============================================
ALTER PROCEDURE [dbo].[usp_request_create_dist_batch] 
	@card_issue_method_id int,
	@issuer_id int,
	@branch_id int = null,
	@product_id int,
	@card_priority_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@cards_in_batch int OUTPUT,
	@dist_batch_id int OUTPUT,
	@dist_batch_ref varchar(50) OUTPUT,
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    BEGIN TRANSACTION [CREATE_DIST_BATCH]
		BEGIN TRY 

		SET @cards_in_batch = 0
		SET	@dist_batch_id = 0
		SET @dist_batch_ref = ''

		DECLARE @branch_card_statuses_id int
		SET @branch_card_statuses_id = 3

		--RAB: Card should always be in approved for issue state. Card Request will do an "Auto Approval" for maker/checker
		--See if the issuer of the branch requires MakerChecker, set branch card statis accordingly.
		--IF((SELECT TOP 1 [issuer].maker_checker_YN
		 
		--    FROM [issuer] INNER JOIN [branch] ON [branch].issuer_id = [issuer].issuer_id 
		--    WHERE [branch].branch_id = @branch_id) = 1)
		--	BEGIN
		--		SET @branch_card_statuses_id = 3
		--	END
		--ELSE
		--	BEGIN
		--		SET @branch_card_statuses_id = 2
		--	END


		--Only create a batch if there are cards for the batch
		IF( (SELECT COUNT(*) 
			 FROM branch_card_status_current
					INNER JOIN branch
						ON branch_card_status_current.branch_id = branch.branch_id					
			 WHERE branch_card_statuses_id = @branch_card_statuses_id
					AND product_id = @product_id
					AND card_issue_method_id = @card_issue_method_id
					AND card_priority_id = @card_priority_id
					AND branch_card_status_current.branch_id = COALESCE(@branch_id, branch_card_status_current.branch_id)
					AND issuer_id = @issuer_id) = 0)
		BEGIN
			SET @ResultCode = 400
			COMMIT TRANSACTION [CREATE_DIST_BATCH]
		END			
		ELSE
			BEGIN

				DECLARE @cards_total int = 0,
						@batch_branch_id int,
						@audit_msg nvarchar(500)


				
				--SELECT TOP 1 @batch_branch_id = branch_card_status_current.branch_id
				--FROM branch_card_status_current
				--INNER JOIN branch
				--	ON branch_card_status_current.branch_id = branch.branch_id					
				--	WHERE branch_card_statuses_id = @branch_card_statuses_id
				--		AND product_id = @product_id
				--		AND card_issue_method_id = @card_issue_method_id
				--		AND card_priority_id = @card_priority_id
				--		AND branch_card_status_current.branch_id = COALESCE(@branch_id, branch_card_status_current.branch_id)
				--		AND issuer_id = @issuer_id


				--create the production batch
				INSERT INTO [dist_batch]
					([card_issue_method_id],[issuer_id],[branch_id], [no_cards],[date_created],[dist_batch_reference],[dist_batch_type_id])
				VALUES (@card_issue_method_id, @issuer_id, @branch_id, 0, GETDATE(), GETDATE(),0)

				SET @dist_batch_id = SCOPE_IDENTITY();

				--Add cards to production batch
				INSERT INTO [dist_batch_cards]
					([dist_batch_id],[card_id],[dist_card_status_id])
				SELECT @dist_batch_id, card_id, 12
				FROM branch_card_status_current
						INNER JOIN branch
							ON branch_card_status_current.branch_id = branch.branch_id	
				WHERE branch_card_statuses_id = @branch_card_statuses_id 
					AND product_id = @product_id
					AND card_issue_method_id = @card_issue_method_id
					AND card_priority_id = @card_priority_id
					AND branch_card_status_current.branch_id = COALESCE(@branch_id, branch_card_status_current.branch_id)
					AND issuer_id = @issuer_id


				--add prod batch status of created
				INSERT INTO [dbo].[dist_batch_status]
					([dist_batch_id],[dist_batch_statuses_id],[user_id],[status_date],[status_notes])
				VALUES(@dist_batch_id, 0, @audit_user_id, GETDATE(), 'Batch Created')

				--Generate dist batch reference
				SELECT @dist_batch_ref =  [issuer].issuer_code + '' + 
										  CONVERT(VARCHAR(MAX),[issuer_product].product_id) + '' +										  
										  CONVERT(VARCHAR(8), GETDATE(), 112) + '' +
										  CAST(@dist_batch_id AS varchar(max))
				FROM [issuer]					
					INNER JOIN [issuer_product]
						ON [issuer_product].issuer_id = [issuer].issuer_id
				WHERE [issuer].issuer_id = @issuer_id

				SELECT @cards_in_batch = COUNT(*)
				FROM dist_batch_cards
				WHERE dist_batch_id = @dist_batch_id 

				--UPDATE prod batch with reference and number of cards
				UPDATE [dist_batch]
				SET [dist_batch_reference] = @dist_batch_ref,
					[no_cards] = @cards_in_batch
				WHERE [dist_batch].dist_batch_id = @dist_batch_id

				--UPDATE branch card status for those cards that have been added to the new dist batch.
				INSERT INTO [branch_card_status]
					(branch_card_statuses_id, card_id, branch_id, comments, status_date, [user_id])
				SELECT 10, dist_batch_cards.card_id, [cards].branch_id, 'Assigned to batch', GETDATE(), @audit_user_id
				FROM dist_batch_cards INNER JOIN [cards]
					ON [cards].card_id = dist_batch_cards.card_id
				WHERE dist_batch_id = @dist_batch_id

				--Notification
				EXEC usp_notification_batch_add @dist_batch_id, 0

				--Add audit for dist batch creation	
				DECLARE @dist_batch_status_name varchar(50)
				SELECT @dist_batch_status_name =  dist_batch_status_name
				FROM dist_batch_statuses
				WHERE dist_batch_statuses_id = 0
											
				SET @audit_msg = 'Create: ' + CAST(@dist_batch_id AS varchar(max)) +
									', ' + COALESCE(@dist_batch_ref, 'UNKNOWN') +
									', ' + COALESCE(@dist_batch_status_name, 'UNKNOWN')
								   
				--log the audit record		
				EXEC usp_insert_audit @audit_user_id, 
										2,
										NULL, 
										@audit_workstation, 
										@audit_msg, 
										NULL, NULL, NULL, NULL

				SELECT @ResultCode = 0
				COMMIT TRANSACTION [CREATE_DIST_BATCH]	

			END					
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [CREATE_DIST_BATCH]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				  );
	END CATCH	
END
GO
PRINT N'Altering [dbo].[usp_update_product]...';


GO

-- =============================================
-- Author:		Sandhya konduru
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
ALTER PROCEDURE [dbo].[usp_update_product]
	-- Add the parameters for the stored procedure here
	@product_id int,
	@product_name varchar(100),
	@product_code varchar(50),
	@product_bin_code varchar(9),
	@issuer_id  int,
	@pan_length smallint,
	@sub_product_code varchar(4),
	@expiry_months int,
	@fee_scheme_id int = null,
	@charge_fee_to_issuing_branch_YN bit,
	@card_issue_method_id int,
	@print_issue_card_YN bit,

	@name_on_card_top decimal(8,2) =0 ,
	@name_on_card_left decimal(8,2)=0,
	@Name_on_card_font_size int=0,
	@font_id int=1,

	@src1_id int,
	@src2_id int,
	@src3_id int,
	@PVKI varchar(100),
	@PVK varchar(100),
	@CVKA varchar(100),
	@CVKB varchar(100),
	
	@enable_instant_pin_YN bit,
	@enable_instant_pin_reissue_YN bit,
	@pin_calc_method_id int,
	@min_pin_length int,
	@max_pin_length int,	

	@cms_exportable_YN bit,
	@product_load_type_id int,
	@auto_approve_batch_YN bit,
	@account_validation_YN bit,

	@pin_mailer_printing_YN bit,
	@pin_mailer_reprint_YN bit,

	@card_issue_reasons_list as dbo.key_value_array READONLY,
	@account_types_list as dbo.key_value_array READONLY,
	@currencylist AS dbo.product_currency_array READONLY,
	@external_system_fields as dbo.[product_external_fields_array] READONLY,			
	@prod_interface_parameters_list AS dbo.bikey_value_array READONLY,
	@issue_interface_parameters_list AS dbo.bikey_value_array READONLY,

	@decimalisation_table varchar(100),
	@pin_validation_data varchar(100),
	@pin_block_formatid int,

	@production_dist_batch_status_flow_id int, 
	@distribution_dist_batch_status_flow_id int,

	@allow_manual_uploaded_YN bit,
	@allow_reupload_YN bit,

	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int =null OUTPUT,
	@new_product_id int =null OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	BEGIN TRANSACTION [UPDATE_Product_TRAN]
		BEGIN TRY 			

			OPEN SYMMETRIC KEY Indigo_Symmetric_Key
			DECRYPTION BY CERTIFICATE Indigo_Certificate
			--Check for duplicate's
			IF EXISTS(SELECT * FROM [issuer_product] WHERE ([product_code] = @product_code AND [product_id] != @product_id AND issuer_id = @issuer_id))
				BEGIN
					SET @ResultCode = 221						
				END
			IF EXISTS(SELECT * FROM [issuer_product] WHERE ([product_name] = @product_name AND [product_id] != @product_id))
				BEGIN
					SET @ResultCode = 220
				END
			ELSE IF dbo.ProductValidation(@product_id, @product_bin_code, @sub_product_code) = 0
				BEGIN
					SET @ResultCode = 222
				END
			ELSE IF 0 = ANY(SELECT dbo.FileParameterValidation(key2, value, key1) FROM @prod_interface_parameters_list)
				BEGIN
					SET @new_product_id = 0
					SET @ResultCode = 228
				END
			ELSE			
			BEGIN

				UPDATE [dbo].[issuer_product]
					SET [product_code] = @product_code,
						[product_name] = @product_name,
						[product_bin_code] = @product_bin_code,
						[issuer_id] = @issuer_id,
						[font_id] = @font_id,
						[name_on_card_top] = @name_on_card_top,
						[name_on_card_left] = @name_on_card_left,
						[Name_on_card_font_size] = @Name_on_card_font_size,
						[src1_id] = @src1_id,
						[src2_id] = @src2_id,
						[src3_id] = @src3_id,
						[PVKI] = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@PVKI)),
						[PVK] = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@PVK)),
						[CVKA] = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@CVKA)),
						[CVKB] = ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@CVKB)),
						[expiry_months] = @expiry_months,						
						[fee_scheme_id] = @fee_scheme_id,
						[charge_fee_to_issuing_branch_YN] = @charge_fee_to_issuing_branch_YN,
						[enable_instant_pin_YN] = @enable_instant_pin_YN,
						[min_pin_length] = @min_pin_length,
						[max_pin_length] = @max_pin_length,
						[enable_instant_pin_reissue_YN] = @enable_instant_pin_reissue_YN,
						[cms_exportable_YN] = @cms_exportable_YN,
						[product_load_type_id] = @product_load_type_id,
						[pan_length] = @pan_length,
						[sub_product_code] = @sub_product_code,
						[pin_calc_method_id] = @pin_calc_method_id,
						[auto_approve_batch_YN] = @auto_approve_batch_YN,
						[account_validation_YN] = @account_validation_YN,
						[pin_mailer_printing_YN] = @pin_mailer_printing_YN,
						[pin_mailer_reprint_YN] = @pin_mailer_reprint_YN,
						[card_issue_method_id] = @card_issue_method_id,
						[decimalisation_table]=ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@decimalisation_table)), 
						[pin_validation_data]=ENCRYPTBYKEY(KEY_GUID('Indigo_Symmetric_Key'),CONVERT(varchar(max),@pin_validation_data)),
						[pin_block_formatid]=@pin_block_formatid,
						[production_dist_batch_status_flow] = @production_dist_batch_status_flow_id, 
						[distribution_dist_batch_status_flow] = @distribution_dist_batch_status_flow_id,
						[print_issue_card_YN] = @print_issue_card_YN
						, [allow_manual_uploaded_YN] = @allow_manual_uploaded_YN
					    , [allow_reupload_YN] = @allow_reupload_YN
					WHERE [product_id] = @product_id



				--insert issuing reason
				DELETE FROM [product_issue_reason] WHERE product_id = @product_id

				INSERT INTO [product_issue_reason] (product_id, card_issue_reason_id)
				SELECT @product_id, value
				FROM @card_issue_reasons_list	

				--insert account types
				DELETE FROM [products_account_types] WHERE product_id = @product_id

				INSERT INTO [products_account_types] (product_id, account_type_id)
				SELECT @product_id, value
				FROM @account_types_list

				--Insert interfaces
				DELETE FROM [product_interface]
				WHERE [product_id] = @product_id

				INSERT INTO [product_interface] (product_id, interface_type_id, connection_parameter_id, interface_guid, interface_area)
				SELECT @product_id, key1, key2, value, 0
				FROM @prod_interface_parameters_list

				INSERT INTO [product_interface] (product_id, interface_type_id, connection_parameter_id, interface_guid, interface_area)
				SELECT @product_id, key1, key2, value, 1
				FROM @issue_interface_parameters_list

				--Update the products currency
				DELETE FROM product_currency
				WHERE [product_id] = @product_id

				Declare  @RC as int
				EXECUTE @RC = [usp_insert_product_currency] @product_id, @currencylist, @audit_user_id, @audit_workstation


					--Update the products currency
				DELETE FROM product_external_system
				WHERE [product_id] = @product_id

				DECLARE @RCExternal int
				EXECUTE @RCExternal = [usp_insert_product_external_systems] @product_id, @external_system_fields, @audit_user_id, @audit_workstation

										
				
				DECLARE @audit_description varchar(500)
				SELECT @audit_description = 'Product updated: ' + @product_code  + ', Product Name: ' + @product_name + 
																     ', bin code: ' + @product_bin_code 
																	 + ', Product Id: ' + CAST(@product_id as varchar(max))
																	
				EXEC usp_insert_audit @audit_user_id, 
									 4,
									 NULL, 
									 @audit_workstation, 
									 @audit_description, 
									 @Issuer_id, NULL, NULL, NULL

				SELECT @ResultCode = 0				
			END
			CLOSE SYMMETRIC KEY Indigo_Symmetric_Key;--Closes sym key
			COMMIT TRANSACTION [UPDATE_Product_TRAN]

		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [UPDATE_Product_TRAN]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH 	

END
GO
PRINT N'Altering [dbo].[usp_dist_batch_status_change]...';


GO

-- =============================================
-- Author:		Richard Brenchley
-- Create date: 
-- Description:	Change batch status - Change
-- =============================================
ALTER PROCEDURE [dbo].[usp_dist_batch_status_change] 
	@dist_batch_id bigint,
	@dist_batch_statuses_id int = null,
	@new_dist_batch_statuses_id int = null,
	@status_notes varchar(150) = null,
	@language_id int,
	@audit_user_id bigint,
	@audit_workstation varchar(100),
	@ResultCode int OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRANSACTION [BATCH_STATUS_CHANGE]
		BEGIN TRY 
			
			DECLARE @audit_msg varchar(max),
					@original_batch_type_id int,
					@new_batch_type_id int,
					@new_dist_card_statuses_id int,
					@new_branch_card_statuses_id int


			--Find the current status of the batch and check if the user can move it to the next status
			IF(@dist_batch_statuses_id is NULL AND @new_dist_batch_statuses_id is NULL)
			BEGIN
				SELECT @dist_batch_statuses_id = [dist_batch_statuses_id], 
						@new_dist_batch_statuses_id = [flow_dist_batch_statuses_id]
				FROM [dist_batch_statuses_flow]
				WHERE dist_batch_status_flow_id =
					(SELECT TOP 1 production_dist_batch_status_flow
						FROM [dist_batch_cards]
							INNER JOIN [cards] ON [cards].card_id = [dist_batch_cards].card_id
							INNER JOIN [issuer_product] ON [issuer_product].product_id = [cards].product_id
						WHERE dist_batch_id = @dist_batch_id)
					AND dist_batch_statuses_id = 
					 (SELECT dist_batch_statuses_id
						FROM [dbo].[dist_batch_status_current]
						WHERE dist_batch_id = @dist_batch_id)
					AND user_role_id IN 
					 (SELECT user_role_id
						FROM [user_group] 
							INNER JOIN [dist_batch] ON ([user_group].issuer_id = [dist_batch].issuer_id OR [user_group].issuer_id = -1)
							INNER JOIN [users_to_users_groups] ON [users_to_users_groups].user_group_id = [user_group].user_group_id
								AND [users_to_users_groups].[user_id] = @audit_user_id)
			END						
						  
			--Check that someone hasn't already updated the dist batch
			IF(dbo.DistBatchInCorrectStatus(@dist_batch_statuses_id, @new_dist_batch_statuses_id, @dist_batch_id) = 0)
				BEGIN
					SET @ResultCode = 100
				END
			ELSE
				BEGIN	
					--Check if we need to create dist batch
					SELECT @original_batch_type_id = [dist_batch_status_flow].dist_batch_type_id,
							  @new_batch_type_id = flow_dist_batch_type_id,
							  @new_dist_card_statuses_id = flow_dist_card_statuses_id,
							  @new_branch_card_statuses_id = branch_card_statuses_id
					FROM [dist_batch_status_current]
						INNER JOIN [dist_batch]
							ON [dist_batch_status_current].dist_batch_id = [dist_batch].dist_batch_id
						INNER JOIN [dist_batch_cards]
							ON [dist_batch].dist_batch_id = [dist_batch_cards].dist_batch_id
						INNER JOIN cards  
							ON [dist_batch_cards].card_id = cards.card_id
						INNER JOIN [issuer_product]
							ON cards.product_id = [issuer_product].product_id
						INNER JOIN [dist_batch_statuses_flow] AS [product_flow]
							ON (([dist_batch].dist_batch_type_id = 0 AND 
									[product_flow].dist_batch_status_flow_id = [issuer_product].production_dist_batch_status_flow)
								OR ([dist_batch].dist_batch_type_id = 1 AND 
									[product_flow].dist_batch_status_flow_id = [issuer_product].distribution_dist_batch_status_flow))
								AND [product_flow].dist_batch_statuses_id = [dist_batch_status_current].dist_batch_statuses_id
						INNER JOIN [dist_batch_status_flow]
							ON [dist_batch_status_flow].dist_batch_status_flow_id = [product_flow].dist_batch_status_flow_id
					WHERE dist_batch_status_current.dist_batch_id = @dist_batch_id
					

					--Update the batch status.
					INSERT [dist_batch_status]
							([dist_batch_id], [dist_batch_statuses_id], [user_id], [status_date], [status_notes])
					VALUES (@dist_batch_id, @new_dist_batch_statuses_id, @audit_user_id, GETDATE(), @status_notes)


					--Receiving at card centre, update originating batch to batchid
					IF(@new_dist_batch_statuses_id = 14)
					BEGIN
						UPDATE [cards]
						SET origin_branch_id = [cards].branch_id
						FROM [cards]
							INNER JOIN [dist_batch_cards]
								ON [cards].card_id = [dist_batch_cards].card_id
						WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id
					END


					--Check if we need to update the card status
					IF (@new_dist_card_statuses_id IS NOT NULL)
					BEGIN 
						--Update the cards linked to the dist batch with the new status.
						UPDATE dist_batch_cards
						SET dist_card_status_id = @new_dist_card_statuses_id
						WHERE dist_batch_id = @dist_batch_id

						--Reject status, make sure cards are back at originating branch
						IF(@new_dist_card_statuses_id = 18 OR @new_dist_card_statuses_id = 11 OR
							@new_dist_card_statuses_id = 7)
							BEGIN
								UPDATE [cards]
								SET branch_id = [cards].origin_branch_id
								FROM [cards]
									INNER JOIN [dist_batch_cards]
										ON [cards].card_id = [dist_batch_cards].card_id
								WHERE [dist_batch_cards].dist_batch_id = @dist_batch_id 

								IF(@new_branch_card_statuses_id = 0)
								BEGIN
									INSERT INTO [branch_card_status] (branch_card_statuses_id, branch_id, card_id, status_date, [user_id])
									SELECT @new_branch_card_statuses_id, [cards].branch_id, [dist_batch_cards].card_id, GETDATE(), @audit_user_id
									FROM [dist_batch_cards] INNER JOIN [cards]
										ON [cards].card_id = [dist_batch_cards].card_id
									WHERE dist_batch_id = @dist_batch_id
								END
							END						
					END
					
					--Do we need to create a distribution batch from a production batch
					IF(@original_batch_type_id = 0 AND @new_batch_type_id = 1)
					BEGIN
						EXEC usp_prod_to_dist_batch @dist_batch_id, @audit_user_id, @audit_workstation
					END

					--PINS_PRINTED check if we need to create pin mailer batch
					IF (@new_dist_batch_statuses_id = 18)
					BEGIN
						EXEC usp_prod_to_pin @dist_batch_id, @audit_user_id, @audit_workstation
					END

					--RECEIVED_AT_BRANCH needs to add cards to branch_card_status
					IF (@new_dist_batch_statuses_id = 3)
					BEGIN
						EXEC usp_dist_batch_to_vault @dist_batch_id, @audit_user_id, @audit_workstation

						--Check if the cards should be changed to another status, overriding previous sp.
						IF(@new_branch_card_statuses_id IS NOT NULL)
						BEGIN
							INSERT INTO [branch_card_status] (branch_card_statuses_id, branch_id, card_id, status_date, [user_id])
							SELECT @new_branch_card_statuses_id, [cards].branch_id, [dist_batch_cards].card_id, DATEADD(s, 1,GETDATE()), @audit_user_id
							FROM [dist_batch_cards] INNER JOIN [cards]
								ON [cards].card_id = [dist_batch_cards].card_id
							WHERE dist_batch_id = @dist_batch_id
						END
					END

					--NOTIFICATION of BATCH
					EXEC usp_notification_batch_add @dist_batch_id, @new_dist_batch_statuses_id					

					--AUDIT 
					DECLARE @batch_status_name varchar(100),
							@batch_ref varchar(100)

					SELECT @batch_status_name =  dist_batch_status_name
					FROM dist_batch_statuses
					WHERE dist_batch_statuses_id = @new_dist_batch_statuses_id

					SELECT @batch_ref = dist_batch_reference
					FROM dist_batch
					WHERE dist_batch_id = @dist_batch_id

					--Add audit for pin batch update								
					SET @audit_msg = 'Update: ' + CAST(@dist_batch_id AS varchar(max)) +
										', ' + COALESCE(@batch_ref, 'UNKNOWN') +
										', ' + COALESCE(@batch_status_name, 'UNKNOWN')
								   
					--log the audit record		
					EXEC usp_insert_audit @audit_user_id, 
											2,
											NULL, 
											@audit_workstation, 
											@audit_msg, 
											NULL, NULL, NULL, NULL

					 

					SET @ResultCode = 0					
				END

				--Fetch the batch with latest details
				EXEC usp_get_dist_batch @dist_batch_id,
										@language_id,
										@audit_user_id,
										@audit_workstation

				COMMIT TRANSACTION [BATCH_STATUS_CHANGE]
		END TRY
	BEGIN CATCH
		ROLLBACK TRANSACTION [BATCH_STATUS_CHANGE]
		DECLARE @ErrorMessage NVARCHAR(4000);
		DECLARE @ErrorSeverity INT;
		DECLARE @ErrorState INT;

		SELECT 
			@ErrorMessage = ERROR_MESSAGE(),
			@ErrorSeverity = ERROR_SEVERITY(),
			@ErrorState = ERROR_STATE();

		RAISERROR (@ErrorMessage, -- Message text.
				   @ErrorSeverity, -- Severity.
				   @ErrorState -- State.
				   );
	END CATCH
END
GO
PRINT N'Refreshing [dbo].[usp_get_auditdata]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_auditdata]';


GO
PRINT N'Refreshing [dbo].[usp_insert_audit]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_insert_audit]';


GO
PRINT N'Refreshing [dbo].[mod_usp_insert_Flexcube_audit]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[mod_usp_insert_Flexcube_audit]';


GO
PRINT N'Refreshing [dbo].[usp_activate_product]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_activate_product]';


GO
PRINT N'Refreshing [dbo].[usp_connection_parameter_create]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_connection_parameter_create]';


GO
PRINT N'Refreshing [dbo].[usp_connection_parameter_update]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_connection_parameter_update]';


GO
PRINT N'Refreshing [dbo].[usp_create_cms_upload_batch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_cms_upload_batch]';


GO
PRINT N'Refreshing [dbo].[usp_create_customer_fields]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_customer_fields]';


GO
PRINT N'Refreshing [dbo].[usp_create_external_system_fields]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_external_system_fields]';


GO
PRINT N'Refreshing [dbo].[usp_create_external_systems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_external_systems]';


GO
PRINT N'Refreshing [dbo].[usp_create_ldap]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_ldap]';


GO
PRINT N'Refreshing [dbo].[usp_create_masterkey]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_masterkey]';


GO
PRINT N'Refreshing [dbo].[usp_create_user_group]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_user_group]';


GO
PRINT N'Refreshing [dbo].[usp_create_useradminsettings]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_useradminsettings]';


GO
PRINT N'Refreshing [dbo].[usp_delete_connenction_params]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_delete_connenction_params]';


GO
PRINT N'Refreshing [dbo].[usp_delete_masterkey]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_delete_masterkey]';


GO
PRINT N'Refreshing [dbo].[usp_delete_subproduct]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_delete_subproduct]';


GO
PRINT N'Refreshing [dbo].[usp_delete_terminaldetails]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_delete_terminaldetails]';


GO
PRINT N'Refreshing [dbo].[usp_export_batch_status_approve]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_export_batch_status_approve]';


GO
PRINT N'Refreshing [dbo].[usp_export_batch_status_reject]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_export_batch_status_reject]';


GO
PRINT N'Refreshing [dbo].[usp_export_batch_status_request]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_export_batch_status_request]';


GO
PRINT N'Refreshing [dbo].[usp_finalise_login]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_finalise_login]';


GO
PRINT N'Refreshing [dbo].[usp_finalise_logout]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_finalise_logout]';


GO
PRINT N'Refreshing [dbo].[usp_insert_FlexcubeAudit]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_insert_FlexcubeAudit]';


GO
PRINT N'Refreshing [dbo].[usp_insert_pin_reissue]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_insert_pin_reissue]';


GO
PRINT N'Refreshing [dbo].[usp_insert_user]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_insert_user]';


GO
PRINT N'Refreshing [dbo].[usp_load_batch_approve]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_load_batch_approve]';


GO
PRINT N'Refreshing [dbo].[usp_load_batch_reject]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_load_batch_reject]';


GO
PRINT N'Refreshing [dbo].[usp_pin_mailer_reprint_approve]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_mailer_reprint_approve]';


GO
PRINT N'Refreshing [dbo].[usp_pin_mailer_reprint_reject]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_mailer_reprint_reject]';


GO
PRINT N'Refreshing [dbo].[usp_pin_mailer_reprint_request]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_mailer_reprint_request]';


GO
PRINT N'Refreshing [dbo].[usp_pin_prod_to_pin_batch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_prod_to_pin_batch]';


GO
PRINT N'Refreshing [dbo].[usp_prod_to_pin]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_prod_to_pin]';


GO
PRINT N'Refreshing [dbo].[usp_request_pin_mailer_reprints]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_request_pin_mailer_reprints]';


GO
PRINT N'Refreshing [dbo].[usp_reset_user_password]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_reset_user_password]';


GO
PRINT N'Refreshing [dbo].[usp_update_external_system_fields]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_external_system_fields]';


GO
PRINT N'Refreshing [dbo].[usp_update_external_systems]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_external_systems]';


GO
PRINT N'Refreshing [dbo].[usp_update_instant_authorisation_pin]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_instant_authorisation_pin]';


GO
PRINT N'Refreshing [dbo].[usp_update_issuer]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_issuer]';


GO
PRINT N'Refreshing [dbo].[usp_update_ldap]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_ldap]';


GO
PRINT N'Refreshing [dbo].[usp_update_masterkey]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_masterkey]';


GO
PRINT N'Refreshing [dbo].[usp_update_user]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_user]';


GO
PRINT N'Refreshing [dbo].[usp_update_useradminsettings]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_useradminsettings]';


GO
PRINT N'Refreshing [dbo].[usp_card_branch_spoil]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_card_branch_spoil]';


GO
PRINT N'Refreshing [dbo].[usp_get_load_batch_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_load_batch_cards]';


GO
PRINT N'Refreshing [dbo].[usp_get_operator_cards_inprogress]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_operator_cards_inprogress]';


GO
PRINT N'Refreshing [dbo].[usp_search_branch_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_search_branch_cards]';


GO
PRINT N'Refreshing [dbo].[usp_search_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_search_cards]';


GO
PRINT N'Refreshing [dbo].[usp_get_pin_reissue]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_pin_reissue]';


GO
PRINT N'Refreshing [dbo].[usp_search_pin_mailer_reprint]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_search_pin_mailer_reprint]';


GO
PRINT N'Refreshing [dbo].[usp_find_reissue_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_find_reissue_cards]';


GO
PRINT N'Refreshing [dbo].[usp_get_cards_in_error]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_cards_in_error]';


GO
PRINT N'Refreshing [dbo].[usp_get_centercardstock_report]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_centercardstock_report]';


GO
PRINT N'Refreshing [dbo].[usp_get_export_batch_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_export_batch_cards]';


GO
PRINT N'Refreshing [dbo].[usp_card_object_details]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_card_object_details]';


GO
PRINT N'Refreshing [dbo].[usp_get_authpin_by_user_id]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_authpin_by_user_id]';


GO
PRINT N'Refreshing [dbo].[usp_get_brachesperusergroup_auditreport]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_brachesperusergroup_auditreport]';


GO
PRINT N'Refreshing [dbo].[usp_get_branch_by_id]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branch_by_id]';


GO
PRINT N'Refreshing [dbo].[usp_get_branches_for_issuer]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branches_for_issuer]';


GO
PRINT N'Refreshing [dbo].[usp_get_branches_for_user]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branches_for_user]';


GO
PRINT N'Refreshing [dbo].[usp_get_branches_for_user_admin]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branches_for_user_admin]';


GO
PRINT N'Refreshing [dbo].[usp_get_branches_for_userroles]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branches_for_userroles]';


GO
PRINT N'Refreshing [dbo].[usp_get_branches_with_load_card_count]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branches_with_load_card_count]';


GO
PRINT N'Refreshing [dbo].[usp_get_card_centre_card_count]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_card_centre_card_count]';


GO
PRINT N'Refreshing [dbo].[usp_get_card_object]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_card_object]';


GO
PRINT N'Refreshing [dbo].[usp_get_cms_parameters]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_cms_parameters]';


GO
PRINT N'Refreshing [dbo].[usp_get_dist_batch_card_details]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_dist_batch_card_details]';


GO
PRINT N'Refreshing [dbo].[usp_get_dist_batch_history]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_dist_batch_history]';


GO
PRINT N'Refreshing [dbo].[usp_get_feerevenue_report]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_feerevenue_report]';


GO
PRINT N'Refreshing [dbo].[usp_get_issuer_by_branch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_issuer_by_branch]';


GO
PRINT N'Refreshing [dbo].[usp_get_issuer_by_product_and_branchcode]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_issuer_by_product_and_branchcode]';


GO
PRINT N'Refreshing [dbo].[usp_get_load_batch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_load_batch]';


GO
PRINT N'Refreshing [dbo].[usp_get_pin_batch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_pin_batch]';


GO
PRINT N'Refreshing [dbo].[usp_get_pin_batch_card_details]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_pin_batch_card_details]';


GO
PRINT N'Refreshing [dbo].[usp_get_pin_batches_for_user]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_pin_batches_for_user]';


GO
PRINT N'Refreshing [dbo].[usp_get_terminals_list]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_terminals_list]';


GO
PRINT N'Refreshing [dbo].[usp_get_tmk_by_terminal]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_tmk_by_terminal]';


GO
PRINT N'Refreshing [dbo].[usp_get_user_groups_admin]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_user_groups_admin]';


GO
PRINT N'Refreshing [dbo].[usp_get_users_by_branch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_users_by_branch]';


GO
PRINT N'Refreshing [dbo].[usp_get_users_by_branch_admin]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_users_by_branch_admin]';


GO
PRINT N'Refreshing [dbo].[usp_pin_mailer_report]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_mailer_report]';


GO
PRINT N'Refreshing [dbo].[usp_search_branch]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_search_branch]';


GO
PRINT N'Refreshing [dbo].[usp_search_terminal]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_search_terminal]';


GO
PRINT N'Refreshing [dbo].[usp_search_user]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_search_user]';


GO
PRINT N'Refreshing [dbo].[usp_get_card_history_reference]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_card_history_reference]';


GO
PRINT N'Refreshing [dbo].[usp_get_cardrequests]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_cardrequests]';


GO
PRINT N'Refreshing [dbo].[usp_get_pin_batch_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_pin_batch_cards]';


GO
PRINT N'Refreshing [dbo].[usp_find_distinct_load_cards]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_find_distinct_load_cards]';


GO
PRINT N'Refreshing [dbo].[usp_card_pvv]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_card_pvv]';


GO
PRINT N'Refreshing [dbo].[usp_find_distinct_load_requests]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_find_distinct_load_requests]';


GO
PRINT N'Refreshing [dbo].[usp_get_branch_card_count]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_branch_card_count]';


GO
PRINT N'Refreshing [dbo].[usp_get_card_history_status]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_card_history_status]';


GO
PRINT N'Refreshing [dbo].[usp_get_pin_mailer_reprint_requests]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_pin_mailer_reprint_requests]';


GO
PRINT N'Refreshing [dbo].[usp_rswitch_hsm_pin_printed]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_rswitch_hsm_pin_printed]';


GO
PRINT N'Refreshing [dbo].[usp_rswitch_update_card_numbers]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_rswitch_update_card_numbers]';


GO
PRINT N'Refreshing [dbo].[usp_update_card_fee_reference]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_card_fee_reference]';


GO
PRINT N'Refreshing [dbo].[usp_update_card_fee_reversal_ref]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_card_fee_reversal_ref]';


GO
PRINT N'Refreshing [dbo].[usp_update_card_numbers]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_card_numbers]';


GO
PRINT N'Refreshing [dbo].[usp_update_card_numbers_bikey]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_update_card_numbers_bikey]';


GO
PRINT N'Refreshing [dbo].[usp_validate_cards_ordered]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_validate_cards_ordered]';


GO
PRINT N'Refreshing [dbo].[usp_get_all_issuers_for_role]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_all_issuers_for_role]';


GO
PRINT N'Refreshing [dbo].[usp_get_product_details_by_product]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_product_details_by_product]';


GO
PRINT N'Refreshing [dbo].[usp_get_product_print_fields_by_code]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_product_print_fields_by_code]';


GO
PRINT N'Refreshing [dbo].[usp_get_products_by_productcode]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_products_by_productcode]';


GO
PRINT N'Refreshing [dbo].[usp_get_terminal_parameters]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_terminal_parameters]';


GO
PRINT N'Refreshing [dbo].[usp_getproductcode]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_getproductcode]';


GO
PRINT N'Refreshing [dbo].[usp_get_current_product_fee]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_current_product_fee]';


GO
PRINT N'Refreshing [dbo].[usp_get_product_fee_scheme]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_product_fee_scheme]';


GO
PRINT N'Refreshing [dbo].[usp_get_product_fee_scheme_list]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_get_product_fee_scheme_list]';


GO
PRINT N'Refreshing [dbo].[usp_create_issuer]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_create_issuer]';


GO
PRINT N'Refreshing [dbo].[usp_dist_batch_reject_production]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_dist_batch_reject_production]';


GO
PRINT N'Refreshing [dbo].[usp_pin_batch_status_change]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_batch_status_change]';


GO
PRINT N'Refreshing [dbo].[usp_pin_batch_status_reject]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_batch_status_reject]';


GO
PRINT N'Refreshing [dbo].[usp_pin_reissue_approve]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_reissue_approve]';


GO
PRINT N'Refreshing [dbo].[usp_pin_reissue_complete]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_reissue_complete]';


GO
PRINT N'Refreshing [dbo].[usp_pin_reissue_expired]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_reissue_expired]';


GO
PRINT N'Refreshing [dbo].[usp_pin_reissue_reject]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_pin_reissue_reject]';


GO
PRINT N'Refreshing [dbo].[usp_request_pin_reissue]...';


GO
EXECUTE sp_refreshsqlmodule N'[dbo].[usp_request_pin_reissue]';


GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[pin_batch_cards] WITH CHECK CHECK CONSTRAINT [FK_pin_batch_cards_cards];

ALTER TABLE [dbo].[dist_batch_cards] WITH CHECK CHECK CONSTRAINT [FK_dist_batch_cards_cards];

ALTER TABLE [dbo].[branch_card_status] WITH CHECK CHECK CONSTRAINT [FK_branch_card_status_cards];

ALTER TABLE [dbo].[load_batch_cards] WITH CHECK CHECK CONSTRAINT [FK_load_batch_cards_cards];

ALTER TABLE [dbo].[pin_mailer_reprint] WITH CHECK CHECK CONSTRAINT [FK_pin_mailer_reprint_cards];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK_cards_issuer_product];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK__cards__card_issu__67A95F59];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK__cards__card_prio__0539C240];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK_cards_cards];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK_export_batch_cards];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK_origin_branch_id];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK_delivery_branch_id];

ALTER TABLE [dbo].[cards] WITH CHECK CHECK CONSTRAINT [FK_ordering_branch_id];

ALTER TABLE [dbo].[dist_batch_statuses_flow] WITH CHECK CHECK CONSTRAINT [FK_dist_batch_status_flow_dist_batch_statuses_flow];

ALTER TABLE [dbo].[dist_batch_status_flow] WITH CHECK CHECK CONSTRAINT [FK_dist_batch_status_flow_dist_batcht_ype];

ALTER TABLE [dbo].[dist_batch_status_flow] WITH CHECK CHECK CONSTRAINT [FK_dist_batch_status_flow_card_issue_method];

ALTER TABLE [dbo].[notification_batch_messages] WITH CHECK CHECK CONSTRAINT [FK_issuer_id];

ALTER TABLE [dbo].[notification_batch_messages] WITH CHECK CHECK CONSTRAINT [FK_dist_batch_statuses];

ALTER TABLE [dbo].[notification_batch_messages] WITH CHECK CHECK CONSTRAINT [FK_languages];

ALTER TABLE [dbo].[notification_batch_messages] WITH CHECK CHECK CONSTRAINT [FK_notification_batch_messages_dist_batch_type_id];

ALTER TABLE [dbo].[notification_branch_messages] WITH CHECK CHECK CONSTRAINT [FK_notification_branch_messages_issuer_id];

ALTER TABLE [dbo].[notification_branch_messages] WITH CHECK CHECK CONSTRAINT [FK_notification_branch_messages_branch_card_statuses];

ALTER TABLE [dbo].[notification_branch_messages] WITH CHECK CHECK CONSTRAINT [FK_notification_branch_messages_card_issue_method];

ALTER TABLE [dbo].[notification_branch_messages] WITH CHECK CHECK CONSTRAINT [FK_notification_branch_messages_languages];

ALTER TABLE [dbo].[product_fee_accounting] WITH CHECK CHECK CONSTRAINT [FK_product_fee_accounting_customer_account_type];

ALTER TABLE [dbo].[product_fee_accounting] WITH CHECK CHECK CONSTRAINT [FK_product_fee_accounting_customer_account_type1];

ALTER TABLE [dbo].[product_fee_accounting] WITH CHECK CHECK CONSTRAINT [FK_product_fee_accounting_issuer];

ALTER TABLE [dbo].[branch_card_status] WITH CHECK CHECK CONSTRAINT [FK_branch_card_status_branch_id];

ALTER TABLE [dbo].[issuer_product] WITH CHECK CHECK CONSTRAINT [FK_dist_batch_status_flow_issuer_product];

ALTER TABLE [dbo].[issuer_product] WITH CHECK CHECK CONSTRAINT [FK_production_dist_batch_status_flow_issuer_product];

ALTER TABLE [dbo].[product_fee_scheme] WITH CHECK CHECK CONSTRAINT [FK_product_fee_scheme_product_fee_accounting];


GO
CREATE TABLE [#__checkStatus] (
    id           INT            IDENTITY (1, 1) PRIMARY KEY CLUSTERED,
    [Schema]     NVARCHAR (256),
    [Table]      NVARCHAR (256),
    [Constraint] NVARCHAR (256)
);

SET NOCOUNT ON;

DECLARE tableconstraintnames CURSOR LOCAL FORWARD_ONLY
    FOR SELECT SCHEMA_NAME([schema_id]),
               OBJECT_NAME([parent_object_id]),
               [name],
               0
        FROM   [sys].[objects]
        WHERE  [parent_object_id] IN (OBJECT_ID(N'dbo.customer_account'))
               AND [type] IN (N'F', N'C')
                   AND [object_id] IN (SELECT [object_id]
                                       FROM   [sys].[check_constraints]
                                       WHERE  [is_not_trusted] <> 0
                                              AND [is_disabled] = 0
                                       UNION
                                       SELECT [object_id]
                                       FROM   [sys].[foreign_keys]
                                       WHERE  [is_not_trusted] <> 0
                                              AND [is_disabled] = 0);

DECLARE @schemaname AS NVARCHAR (256);

DECLARE @tablename AS NVARCHAR (256);

DECLARE @checkname AS NVARCHAR (256);

DECLARE @is_not_trusted AS INT;

DECLARE @statement AS NVARCHAR (1024);

BEGIN TRY
    OPEN tableconstraintnames;
    FETCH tableconstraintnames INTO @schemaname, @tablename, @checkname, @is_not_trusted;
    WHILE @@fetch_status = 0
        BEGIN
            PRINT N'Checking constraint: ' + @checkname + N' [' + @schemaname + N'].[' + @tablename + N']';
            SET @statement = N'ALTER TABLE [' + @schemaname + N'].[' + @tablename + N'] WITH ' + CASE @is_not_trusted WHEN 0 THEN N'CHECK' ELSE N'NOCHECK' END + N' CHECK CONSTRAINT [' + @checkname + N']';
            BEGIN TRY
                EXECUTE [sp_executesql] @statement;
            END TRY
            BEGIN CATCH
                INSERT  [#__checkStatus] ([Schema], [Table], [Constraint])
                VALUES                  (@schemaname, @tablename, @checkname);
            END CATCH
            FETCH tableconstraintnames INTO @schemaname, @tablename, @checkname, @is_not_trusted;
        END
END TRY
BEGIN CATCH
    PRINT ERROR_MESSAGE();
END CATCH

IF CURSOR_STATUS(N'LOCAL', N'tableconstraintnames') >= 0
    CLOSE tableconstraintnames;

IF CURSOR_STATUS(N'LOCAL', N'tableconstraintnames') = -1
    DEALLOCATE tableconstraintnames;

SELECT N'Constraint verification failed:' + [Schema] + N'.' + [Table] + N',' + [Constraint]
FROM   [#__checkStatus];

IF @@ROWCOUNT > 0
    BEGIN
        DROP TABLE [#__checkStatus];
        RAISERROR (N'An error occurred while verifying constraints', 16, 127);
    END

SET NOCOUNT OFF;

DROP TABLE [#__checkStatus];


GO
PRINT N'Update complete.';


GO
